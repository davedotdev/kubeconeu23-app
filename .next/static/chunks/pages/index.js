/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/index"],{

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fdgee%2FDocuments%2FRethink%2Fkubecon22%2Fdemo%2Fpages%2Findex.tsx&page=%2F!":
/*!******************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fdgee%2FDocuments%2FRethink%2Fkubecon22%2Fdemo%2Fpages%2Findex.tsx&page=%2F! ***!
  \******************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/\",\n      function () {\n        return __webpack_require__(/*! ./pages/index.tsx */ \"./pages/index.tsx\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD0lMkZVc2VycyUyRmRnZWUlMkZEb2N1bWVudHMlMkZSZXRoaW5rJTJGa3ViZWNvbjIyJTJGZGVtbyUyRnBhZ2VzJTJGaW5kZXgudHN4JnBhZ2U9JTJGIS5qcyIsIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDRDQUFtQjtBQUMxQztBQUNBO0FBQ0EsT0FBTyxJQUFVO0FBQ2pCLE1BQU0sVUFBVTtBQUNoQjtBQUNBLE9BQU87QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/ZTMwNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICAod2luZG93Ll9fTkVYVF9QID0gd2luZG93Ll9fTkVYVF9QIHx8IFtdKS5wdXNoKFtcbiAgICAgIFwiL1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZShcIi4vcGFnZXMvaW5kZXgudHN4XCIpO1xuICAgICAgfVxuICAgIF0pO1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdpbmRvdy5fX05FWFRfUC5wdXNoKFtcIi9cIl0pXG4gICAgICB9KTtcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fdgee%2FDocuments%2FRethink%2Fkubecon22%2Fdemo%2Fpages%2Findex.tsx&page=%2F!\n"));

/***/ }),

/***/ "./components/demo.tsx":
/*!*****************************!*\
  !*** ./components/demo.tsx ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Demo\": function() { return /* binding */ Demo; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_src_async_iterator_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @swc/helpers/src/_async_iterator.mjs */ \"./node_modules/@swc/helpers/src/_async_iterator.mjs\");\n/* harmony import */ var _swc_helpers_src_async_to_generator_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @swc/helpers/src/_async_to_generator.mjs */ \"./node_modules/@swc/helpers/src/_async_to_generator.mjs\");\n/* harmony import */ var _swc_helpers_src_to_consumable_array_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @swc/helpers/src/_to_consumable_array.mjs */ \"./node_modules/@swc/helpers/src/_to_consumable_array.mjs\");\n/* harmony import */ var _swc_helpers_src_ts_generator_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @swc/helpers/src/_ts_generator.mjs */ \"./node_modules/@swc/helpers/src/_ts_generator.mjs\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var nats_ws__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! nats.ws */ \"./node_modules/nats.ws/esm/nats.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/dynamic */ \"./node_modules/next/dynamic.js\");\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_dynamic__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var react_confetti__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-confetti */ \"./node_modules/react-confetti/dist/react-confetti.min.js\");\n/* harmony import */ var react_confetti__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_confetti__WEBPACK_IMPORTED_MODULE_4__);\n\n\n\n\nvar _this = undefined;\n\nvar _s = $RefreshSig$();\n\n\n\n\nvar Chart = next_dynamic__WEBPACK_IMPORTED_MODULE_3___default()(function() {\n    return __webpack_require__.e(/*! import() */ \"node_modules_react-apexcharts_dist_react-apexcharts_min_js\").then(__webpack_require__.bind(__webpack_require__, /*! react-apexcharts */ \"./node_modules/react-apexcharts/dist/react-apexcharts.min.js\"));\n}, {\n    loadableGenerated: {\n        modules: [\n            \"../components/demo.tsx -> \" + \"react-apexcharts\"\n        ]\n    },\n    ssr: false\n});\n_c = Chart;\nvar subscribe = function(nc, subject, cb, opts) {\n    var sub = nc.subscribe(subject, opts);\n    (0,_swc_helpers_src_async_to_generator_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(function() {\n        var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, m, err;\n        return (0,_swc_helpers_src_ts_generator_mjs__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    _iteratorAbruptCompletion = false, _didIteratorError = false;\n                    _state.label = 1;\n                case 1:\n                    _state.trys.push([\n                        1,\n                        6,\n                        7,\n                        12\n                    ]);\n                    _iterator = (0,_swc_helpers_src_async_iterator_mjs__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(sub);\n                    _state.label = 2;\n                case 2:\n                    return [\n                        4,\n                        _iterator.next()\n                    ];\n                case 3:\n                    if (!(_iteratorAbruptCompletion = !(_step = _state.sent()).done)) return [\n                        3,\n                        5\n                    ];\n                    _value = _step.value;\n                    m = _value;\n                    cb(m);\n                    _state.label = 4;\n                case 4:\n                    _iteratorAbruptCompletion = false;\n                    return [\n                        3,\n                        2\n                    ];\n                case 5:\n                    return [\n                        3,\n                        12\n                    ];\n                case 6:\n                    err = _state.sent();\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                    return [\n                        3,\n                        12\n                    ];\n                case 7:\n                    _state.trys.push([\n                        7,\n                        ,\n                        10,\n                        11\n                    ]);\n                    if (!(_iteratorAbruptCompletion && _iterator.return != null)) return [\n                        3,\n                        9\n                    ];\n                    return [\n                        4,\n                        _iterator.return()\n                    ];\n                case 8:\n                    _state.sent();\n                    _state.label = 9;\n                case 9:\n                    return [\n                        3,\n                        11\n                    ];\n                case 10:\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                    return [\n                        7\n                    ];\n                case 11:\n                    return [\n                        7\n                    ];\n                case 12:\n                    return [\n                        2\n                    ];\n            }\n        });\n    })();\n};\nvar questions = [\n    {\n        label: \"How familiar are you with NATS?\",\n        id: \"familiarity\",\n        options: [\n            \"I'm a complete newbie\",\n            \"I've dabbled a bit\",\n            \"I've evaluated NATS at my company\",\n            \"I'm using NATS in production\", \n        ]\n    },\n    {\n        label: \"What topic are you most interested in learning more about?\",\n        id: \"topic\",\n        options: [\n            \"NATS for microservice architectures\",\n            \"Streaming, KV & Object Store with NATS JetStream\",\n            \"Deploying NATS with Kubernetes\",\n            \"Scaling your service globally from cloud to edge\", \n        ]\n    },\n    {\n        label: \"How familiar are you with microservices?\",\n        id: \"microservices\",\n        options: [\n            \"I am still learning the concepts of microservices\",\n            \"I am in the process of building a microservices-based application\",\n            \"I am running microservices in production and loving it!\",\n            \"I have felt pain with developing or productionizing microservices\"\n        ]\n    }, \n];\nvar Demo = function(props) {\n    _s();\n    var nc = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)();\n    var eventName = props.eventName, name = props.name, server = props.server;\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)({\n        name: name\n    }), survey = ref[0], setSurvey = ref[1];\n    var ref1 = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]), surveyData = ref1[0], setSurveyData = ref1[1];\n    var ref2 = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]), logs = ref2[0], setLogs = ref2[1];\n    var ref3 = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(localStorage.getItem(\"survey\") == \"true\"), submitted = ref3[0], setSubmitted = ref3[1];\n    var ref4 = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false), wonLottery = ref4[0], setWonLottery = ref4[1];\n    var updateSurvey = function(k, v) {\n        survey[k] = v;\n        setSurvey(survey);\n    };\n    var submitSurvey = function() {\n        var ref;\n        var jc = (0,nats_ws__WEBPACK_IMPORTED_MODULE_1__.JSONCodec)();\n        log(\"Submitting survey: \".concat(JSON.stringify(survey)));\n        (ref = nc.current) === null || ref === void 0 ? void 0 : ref.publish(\"\".concat(eventName, \".survey\"), jc.encode(survey));\n        setSubmitted(true);\n        localStorage.setItem(\"name\", name);\n        localStorage.setItem(\"survey\", \"true\");\n    };\n    var seriesData = function(question) {\n        return question.options.map(function(option) {\n            var n = 0;\n            surveyData.forEach(function(data) {\n                if (data[question.id] == option) {\n                    n++;\n                }\n            });\n            return n;\n        });\n    };\n    var log = function(text) {\n        var d = new Date();\n        text = \"[\".concat(d.toLocaleTimeString(\"en-US\", {\n            timeStyle: \"long\"\n        }), \"] \").concat(text);\n        setLogs(function(current) {\n            return (0,_swc_helpers_src_to_consumable_array_mjs__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(current).concat([\n                text\n            ]);\n        });\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(function() {\n        function natsConnect() {\n            return _natsConnect.apply(this, arguments);\n        }\n        function _natsConnect() {\n            _natsConnect = (0,_swc_helpers_src_async_to_generator_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(function() {\n                var sc, jc, opts, sub, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _loop, _iterator, _step, err;\n                return (0,_swc_helpers_src_ts_generator_mjs__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(this, function(_state) {\n                    switch(_state.label){\n                        case 0:\n                            sc = (0,nats_ws__WEBPACK_IMPORTED_MODULE_1__.StringCodec)();\n                            jc = (0,nats_ws__WEBPACK_IMPORTED_MODULE_1__.JSONCodec)();\n                            if (!!nc.current) return [\n                                3,\n                                2\n                            ];\n                            log(\"Connecting to NATS...\");\n                            return [\n                                4,\n                                (0,nats_ws__WEBPACK_IMPORTED_MODULE_1__.connect)({\n                                    servers: [\n                                        server\n                                    ]\n                                })\n                            ];\n                        case 1:\n                            nc.current = _state.sent();\n                            log(\"Connected to \".concat(server));\n                            _state.label = 2;\n                        case 2:\n                            subscribe(nc.current, \"\".concat(eventName, \".rolecall\"), function(m) {\n                                log(\"Recieved message on \".concat(eventName, \".rolecall\"));\n                                m.respond(sc.encode(name));\n                                log('Responded with \"'.concat(name, '\"'));\n                            });\n                            subscribe(nc.current, \"\".concat(eventName, \".lottery\"), function(m) {\n                                log(\"\\uD83C\\uDF89 You won the lottery!\");\n                                setWonLottery(true);\n                                m.respond(sc.encode(name));\n                            }, {\n                                queue: \"lottery\"\n                            });\n                            subscribe(nc.current, \"\".concat(eventName, \".navigate\"), function(m) {\n                                var url = sc.decode(m.data);\n                                log(\"Navigating to \".concat(url, \"...\"));\n                                window.location.replace(url);\n                            });\n                            opts = (0,nats_ws__WEBPACK_IMPORTED_MODULE_1__.consumerOpts)();\n                            opts.orderedConsumer();\n                            return [\n                                4,\n                                nc.current.jetstream().subscribe(\"\".concat(eventName, \".survey\"), opts)\n                            ];\n                        case 3:\n                            sub = _state.sent();\n                            _iteratorAbruptCompletion = false, _didIteratorError = false;\n                            _state.label = 4;\n                        case 4:\n                            _state.trys.push([\n                                4,\n                                9,\n                                10,\n                                15\n                            ]);\n                            _loop = function() {\n                                var _value = _step.value;\n                                var m = _value;\n                                setSurveyData(function(current) {\n                                    return (0,_swc_helpers_src_to_consumable_array_mjs__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(current).concat([\n                                        jc.decode(m.data)\n                                    ]);\n                                });\n                            };\n                            _iterator = (0,_swc_helpers_src_async_iterator_mjs__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(sub);\n                            _state.label = 5;\n                        case 5:\n                            return [\n                                4,\n                                _iterator.next()\n                            ];\n                        case 6:\n                            if (!(_iteratorAbruptCompletion = !(_step = _state.sent()).done)) return [\n                                3,\n                                8\n                            ];\n                            _loop();\n                            _state.label = 7;\n                        case 7:\n                            _iteratorAbruptCompletion = false;\n                            return [\n                                3,\n                                5\n                            ];\n                        case 8:\n                            return [\n                                3,\n                                15\n                            ];\n                        case 9:\n                            err = _state.sent();\n                            _didIteratorError = true;\n                            _iteratorError = err;\n                            return [\n                                3,\n                                15\n                            ];\n                        case 10:\n                            _state.trys.push([\n                                10,\n                                ,\n                                13,\n                                14\n                            ]);\n                            if (!(_iteratorAbruptCompletion && _iterator.return != null)) return [\n                                3,\n                                12\n                            ];\n                            return [\n                                4,\n                                _iterator.return()\n                            ];\n                        case 11:\n                            _state.sent();\n                            _state.label = 12;\n                        case 12:\n                            return [\n                                3,\n                                14\n                            ];\n                        case 13:\n                            if (_didIteratorError) {\n                                throw _iteratorError;\n                            }\n                            return [\n                                7\n                            ];\n                        case 14:\n                            return [\n                                7\n                            ];\n                        case 15:\n                            return [\n                                2\n                            ];\n                    }\n                });\n            });\n            return _natsConnect.apply(this, arguments);\n        }\n        natsConnect();\n    }, [\n        name,\n        server\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: [\n            !submitted && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"bg-white shadow rounded-lg\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"px-4 py-5 sm:p-6\",\n                    children: [\n                        questions.map(function(question, i) {\n                            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"mb-8\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                            className: \"text-base font-medium text-gray-900\",\n                                            children: question.label\n                                        }, void 0, false, {\n                                            fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/components/demo.tsx\",\n                                            lineNumber: 156,\n                                            columnNumber: 19\n                                        }, _this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"fieldset\", {\n                                            className: \"mt-4\",\n                                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"space-y-3\",\n                                                children: question.options.map(function(option) {\n                                                    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        className: \"flex items-center\",\n                                                        children: [\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                                id: option,\n                                                                name: question.id,\n                                                                type: \"radio\",\n                                                                className: \"h-4 w-4 border-gray-300 text-indigo-600 focus:ring-indigo-500\",\n                                                                onChange: function() {\n                                                                    return updateSurvey(question.id, option);\n                                                                }\n                                                            }, void 0, false, {\n                                                                fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/components/demo.tsx\",\n                                                                lineNumber: 161,\n                                                                columnNumber: 27\n                                                            }, _this),\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                                                htmlFor: option,\n                                                                className: \"ml-3 block text-sm font-medium text-gray-700\",\n                                                                children: option\n                                                            }, void 0, false, {\n                                                                fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/components/demo.tsx\",\n                                                                lineNumber: 168,\n                                                                columnNumber: 27\n                                                            }, _this)\n                                                        ]\n                                                    }, option, true, {\n                                                        fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/components/demo.tsx\",\n                                                        lineNumber: 160,\n                                                        columnNumber: 25\n                                                    }, _this);\n                                                })\n                                            }, void 0, false, {\n                                                fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/components/demo.tsx\",\n                                                lineNumber: 158,\n                                                columnNumber: 21\n                                            }, _this)\n                                        }, void 0, false, {\n                                            fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/components/demo.tsx\",\n                                            lineNumber: 157,\n                                            columnNumber: 19\n                                        }, _this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/components/demo.tsx\",\n                                    lineNumber: 155,\n                                    columnNumber: 17\n                                }, _this)\n                            }, i, false, {\n                                fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/components/demo.tsx\",\n                                lineNumber: 154,\n                                columnNumber: 15\n                            }, _this);\n                        }),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            type: \"submit\",\n                            className: \"mt-3 inline-flex w-full items-center justify-center rounded-md border border-transparent bg-indigo-600 px-4 py-2 font-medium text-white shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 sm:mt-0 sm:ml-3 sm:w-auto sm:text-sm\",\n                            onClick: submitSurvey,\n                            children: \"Submit\"\n                        }, void 0, false, {\n                            fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/components/demo.tsx\",\n                            lineNumber: 179,\n                            columnNumber: 13\n                        }, _this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/components/demo.tsx\",\n                    lineNumber: 152,\n                    columnNumber: 11\n                }, _this)\n            }, void 0, false, {\n                fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/components/demo.tsx\",\n                lineNumber: 151,\n                columnNumber: 9\n            }, _this),\n            submitted && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"mb-8\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        className: \"text-3xl mb-6 text-bold\",\n                        children: \"Survey Results\"\n                    }, void 0, false, {\n                        fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/components/demo.tsx\",\n                        lineNumber: 188,\n                        columnNumber: 11\n                    }, _this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"grid grid-cols-1 md:grid-cols-3 gap-4\",\n                        children: questions.map(function(question, i) {\n                            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"bg-white shadow rounded-lg\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"px-4 py-5 sm:p-6\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                            className: \"text-xl font-semibold mb-4 line-clamp-2\",\n                                            children: question.label\n                                        }, void 0, false, {\n                                            fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/components/demo.tsx\",\n                                            lineNumber: 193,\n                                            columnNumber: 19\n                                        }, _this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Chart, {\n                                            type: \"donut\",\n                                            options: {\n                                                labels: question.options,\n                                                legend: {\n                                                    show: false\n                                                }\n                                            },\n                                            series: seriesData(question)\n                                        }, void 0, false, {\n                                            fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/components/demo.tsx\",\n                                            lineNumber: 194,\n                                            columnNumber: 19\n                                        }, _this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/components/demo.tsx\",\n                                    lineNumber: 192,\n                                    columnNumber: 17\n                                }, _this)\n                            }, i, false, {\n                                fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/components/demo.tsx\",\n                                lineNumber: 191,\n                                columnNumber: 15\n                            }, _this);\n                        })\n                    }, void 0, false, {\n                        fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/components/demo.tsx\",\n                        lineNumber: 189,\n                        columnNumber: 11\n                    }, _this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/components/demo.tsx\",\n                lineNumber: 187,\n                columnNumber: 9\n            }, _this),\n            submitted && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        className: \"text-3xl mb-6 text-bold\",\n                        children: \"Logs\"\n                    }, void 0, false, {\n                        fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/components/demo.tsx\",\n                        lineNumber: 209,\n                        columnNumber: 11\n                    }, _this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"bg-slate-800 rounded-lg min-h-[384px] text-gray-50 p-6 font-mono break-all\",\n                        children: [\n                            \" \",\n                            logs.map(function(log, i) {\n                                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    children: log\n                                }, i, false, {\n                                    fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/components/demo.tsx\",\n                                    lineNumber: 211,\n                                    columnNumber: 13\n                                }, _this);\n                            })\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/components/demo.tsx\",\n                        lineNumber: 210,\n                        columnNumber: 11\n                    }, _this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/components/demo.tsx\",\n                lineNumber: 208,\n                columnNumber: 9\n            }, _this),\n            wonLottery && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((react_confetti__WEBPACK_IMPORTED_MODULE_4___default()), {\n                numberOfPieces: 2000,\n                colors: [\n                    \"#27aae1\",\n                    \"#34a574\",\n                    \"#375c93\",\n                    \"#8dc63f\"\n                ],\n                recycle: true,\n                drawShape: function(ctx) {\n                    ctx.beginPath();\n                    var x1 = 0;\n                    var y1 = 0;\n                    ctx.lineTo(x1, y1);\n                    var x2 = 0;\n                    var y2 = 20;\n                    ctx.lineTo(x2, y2);\n                    var x3 = 20;\n                    var y3 = 0;\n                    ctx.lineTo(x3, y3);\n                    var x4 = 20;\n                    var y4 = 20;\n                    ctx.lineTo(x4, y4);\n                    ctx.stroke();\n                    ctx.closePath();\n                }\n            }, void 0, false, {\n                fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/components/demo.tsx\",\n                lineNumber: 218,\n                columnNumber: 9\n            }, _this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/components/demo.tsx\",\n        lineNumber: 148,\n        columnNumber: 5\n    }, _this);\n};\n_s(Demo, \"y1BIQ+1ufWvm1u91bh0/TpGukWg=\");\n_c1 = Demo;\nvar _c, _c1;\n$RefreshReg$(_c, \"Chart\");\n$RefreshReg$(_c1, \"Demo\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFFQyxFQUFFLENBQUM7b0JBRWxCLElBQU1FLEVBQUUsR0FBRyxDQUFDO29CQUNaLElBQU1DLEVBQUUsR0FBRyxFQUFFO29CQUNiTixHQUFHLENBQUNJLE1BQU0sQ0FBQ0MsRUFBRSxFQUFFQyxFQUFFLENBQUM7b0JBRWxCLElBQU1DLEVBQUUsR0FBRyxFQUFFO29CQUNiLElBQU1DLEVBQUUsR0FBRyxDQUFDO29CQUNaUixHQUFHLENBQUNJLE1BQU0sQ0FBQ0csRUFBRSxFQUFFQyxFQUFFLENBQUM7b0JBRWxCLElBQU1DLEVBQUUsR0FBRyxFQUFFO29CQUNiLElBQU1DLEVBQUUsR0FBRyxFQUFFO29CQUNiVixHQUFHLENBQUNJLE1BQU0sQ0FBQ0ssRUFBRSxFQUFFQyxFQUFFLENBQUM7b0JBRXBCVixHQUFHLENBQUNXLE1BQU0sRUFBRTtvQkFDWlgsR0FBRyxDQUFDWSxTQUFTLEVBQUU7Z0JBQ2pCLENBQUM7Ozs7O3FCQUNEOzs7Ozs7YUFFUSxDQUNQO0FBQ0gsQ0FBQztHQXZMWXJGLElBQUk7QUFBSkEsTUFBQUEsSUFBSSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL2RlbW8udHN4P2QyZDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29ubmVjdCwgY29uc3VtZXJPcHRzLCBKU09OQ29kZWMsIE1zZywgTmF0c0Nvbm5lY3Rpb24sIFN0cmluZ0NvZGVjLCBTdWJzY3JpcHRpb25PcHRpb25zIH0gZnJvbSAnbmF0cy53cydcbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCBkeW5hbWljIGZyb20gJ25leHQvZHluYW1pYydcbmltcG9ydCBSZWFjdENvbmZldHRpIGZyb20gJ3JlYWN0LWNvbmZldHRpJztcblxuY29uc3QgQ2hhcnQgPSBkeW5hbWljKCgpID0+IGltcG9ydCgncmVhY3QtYXBleGNoYXJ0cycpLCB7IHNzcjogZmFsc2UgfSk7XG5cbnR5cGUgRGVtb1Byb3BzID0ge1xuICBuYW1lOiBzdHJpbmdcbiAgc2VydmVyOiBzdHJpbmdcbiAgZXZlbnROYW1lOiBzdHJpbmdcbn1cblxudHlwZSBRdWVzdGlvbiA9IHtcbiAgaWQ6IHN0cmluZyxcbiAgb3B0aW9uczogQXJyYXk8c3RyaW5nPlxufVxuXG5jb25zdCBzdWJzY3JpYmUgPSAoXG4gIG5jOiBOYXRzQ29ubmVjdGlvbixcbiAgc3ViamVjdDogc3RyaW5nLFxuICBjYjogKG06IE1zZykgPT4gdm9pZCxcbiAgb3B0cz86IFN1YnNjcmlwdGlvbk9wdGlvbnMpID0+IHtcblxuICBjb25zdCBzdWIgPSBuYy5zdWJzY3JpYmUoc3ViamVjdCwgb3B0cyk7XG4gIChhc3luYyAoKSA9PiB7XG4gICAgZm9yIGF3YWl0IChjb25zdCBtIG9mIHN1YikgeyBjYihtKSB9XG4gIH0pKClcblxufVxuXG5jb25zdCBxdWVzdGlvbnMgPSBbXG4gIHtcbiAgICBsYWJlbDogXCJIb3cgZmFtaWxpYXIgYXJlIHlvdSB3aXRoIE5BVFM/XCIsXG4gICAgaWQ6IFwiZmFtaWxpYXJpdHlcIixcbiAgICBvcHRpb25zOiBbXG4gICAgICBcIkknbSBhIGNvbXBsZXRlIG5ld2JpZVwiLFxuICAgICAgXCJJJ3ZlIGRhYmJsZWQgYSBiaXRcIixcbiAgICAgIFwiSSd2ZSBldmFsdWF0ZWQgTkFUUyBhdCBteSBjb21wYW55XCIsXG4gICAgICBcIkknbSB1c2luZyBOQVRTIGluIHByb2R1Y3Rpb25cIixcbiAgICBdLFxuICB9LFxuICB7XG4gICAgbGFiZWw6IFwiV2hhdCB0b3BpYyBhcmUgeW91IG1vc3QgaW50ZXJlc3RlZCBpbiBsZWFybmluZyBtb3JlIGFib3V0P1wiLFxuICAgIGlkOiBcInRvcGljXCIsXG4gICAgb3B0aW9uczogW1xuICAgICAgXCJOQVRTIGZvciBtaWNyb3NlcnZpY2UgYXJjaGl0ZWN0dXJlc1wiLFxuICAgICAgXCJTdHJlYW1pbmcsIEtWICYgT2JqZWN0IFN0b3JlIHdpdGggTkFUUyBKZXRTdHJlYW1cIixcbiAgICAgIFwiRGVwbG95aW5nIE5BVFMgd2l0aCBLdWJlcm5ldGVzXCIsXG4gICAgICBcIlNjYWxpbmcgeW91ciBzZXJ2aWNlIGdsb2JhbGx5IGZyb20gY2xvdWQgdG8gZWRnZVwiLFxuICAgIF0sXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogXCJIb3cgZmFtaWxpYXIgYXJlIHlvdSB3aXRoIG1pY3Jvc2VydmljZXM/XCIsXG4gICAgaWQ6IFwibWljcm9zZXJ2aWNlc1wiLFxuICAgIG9wdGlvbnM6IFtcbiAgICAgIFwiSSBhbSBzdGlsbCBsZWFybmluZyB0aGUgY29uY2VwdHMgb2YgbWljcm9zZXJ2aWNlc1wiLFxuICAgICAgXCJJIGFtIGluIHRoZSBwcm9jZXNzIG9mIGJ1aWxkaW5nIGEgbWljcm9zZXJ2aWNlcy1iYXNlZCBhcHBsaWNhdGlvblwiLFxuICAgICAgXCJJIGFtIHJ1bm5pbmcgbWljcm9zZXJ2aWNlcyBpbiBwcm9kdWN0aW9uIGFuZCBsb3ZpbmcgaXQhXCIsXG4gICAgICBcIkkgaGF2ZSBmZWx0IHBhaW4gd2l0aCBkZXZlbG9waW5nIG9yIHByb2R1Y3Rpb25pemluZyBtaWNyb3NlcnZpY2VzXCJcbiAgICBdLFxuICB9LFxuXVxuXG5leHBvcnQgY29uc3QgRGVtbyA9IChwcm9wczogRGVtb1Byb3BzKSA9PiB7XG4gIGNvbnN0IG5jID0gdXNlUmVmPE5hdHNDb25uZWN0aW9uPigpXG4gIGNvbnN0IHsgZXZlbnROYW1lLCBuYW1lLCBzZXJ2ZXIgfSA9IHByb3BzXG5cbiAgY29uc3QgW3N1cnZleSwgc2V0U3VydmV5XSA9IHVzZVN0YXRlPGFueT4oeyBuYW1lOiBuYW1lIH0pXG4gIGNvbnN0IFtzdXJ2ZXlEYXRhLCBzZXRTdXJ2ZXlEYXRhXSA9IHVzZVN0YXRlPEFycmF5PGFueT4+KFtdKVxuICBjb25zdCBbbG9ncywgc2V0TG9nc10gPSB1c2VTdGF0ZTxBcnJheTxzdHJpbmc+PihbXSlcbiAgY29uc3QgW3N1Ym1pdHRlZCwgc2V0U3VibWl0dGVkXSA9IHVzZVN0YXRlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwic3VydmV5XCIpID09IFwidHJ1ZVwiKVxuICBjb25zdCBbd29uTG90dGVyeSwgc2V0V29uTG90dGVyeV0gPSB1c2VTdGF0ZShmYWxzZSlcblxuICBjb25zdCB1cGRhdGVTdXJ2ZXkgPSAoazogc3RyaW5nLCB2OiBzdHJpbmcpID0+IHtcbiAgICBzdXJ2ZXlba10gPSB2XG4gICAgc2V0U3VydmV5KHN1cnZleSlcbiAgfVxuXG4gIGNvbnN0IHN1Ym1pdFN1cnZleSA9ICgpID0+IHtcbiAgICBjb25zdCBqYyA9IEpTT05Db2RlYygpO1xuICAgIGxvZyhgU3VibWl0dGluZyBzdXJ2ZXk6ICR7SlNPTi5zdHJpbmdpZnkoc3VydmV5KX1gKVxuICAgIG5jLmN1cnJlbnQ/LnB1Ymxpc2goYCR7ZXZlbnROYW1lfS5zdXJ2ZXlgLCBqYy5lbmNvZGUoc3VydmV5KSlcbiAgICBzZXRTdWJtaXR0ZWQodHJ1ZSlcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcIm5hbWVcIiwgbmFtZSlcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInN1cnZleVwiLCBcInRydWVcIilcbiAgfVxuXG4gIGNvbnN0IHNlcmllc0RhdGEgPSAocXVlc3Rpb246IFF1ZXN0aW9uKSA9PiB7XG4gICAgcmV0dXJuIHF1ZXN0aW9uLm9wdGlvbnMubWFwKChvcHRpb24pID0+IHtcbiAgICAgIHZhciBuID0gMFxuICAgICAgc3VydmV5RGF0YS5mb3JFYWNoKChkYXRhKSA9PiB7XG4gICAgICAgIGlmIChkYXRhW3F1ZXN0aW9uLmlkXSA9PSBvcHRpb24pIHtcbiAgICAgICAgICBuKytcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHJldHVybiBuXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IGxvZyA9ICh0ZXh0OiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCBkID0gbmV3IERhdGUoKVxuICAgIHRleHQgPSBgWyR7ZC50b0xvY2FsZVRpbWVTdHJpbmcoXCJlbi1VU1wiLCB7IHRpbWVTdHlsZTogXCJsb25nXCIgfSl9XSAke3RleHR9YFxuICAgIHNldExvZ3MoY3VycmVudCA9PiBbLi4uY3VycmVudCwgdGV4dF0pXG4gIH1cblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGFzeW5jIGZ1bmN0aW9uIG5hdHNDb25uZWN0KCkge1xuICAgICAgY29uc3Qgc2MgPSBTdHJpbmdDb2RlYygpO1xuICAgICAgY29uc3QgamMgPSBKU09OQ29kZWMoKTtcblxuICAgICAgaWYgKCFuYy5jdXJyZW50KSB7XG4gICAgICAgIGxvZyhcIkNvbm5lY3RpbmcgdG8gTkFUUy4uLlwiKVxuICAgICAgICBuYy5jdXJyZW50ID0gYXdhaXQgY29ubmVjdCh7IHNlcnZlcnM6IFtzZXJ2ZXJdIH0pO1xuICAgICAgICBsb2coYENvbm5lY3RlZCB0byAke3NlcnZlcn1gKVxuICAgICAgfVxuXG4gICAgICBzdWJzY3JpYmUobmMuY3VycmVudCwgYCR7ZXZlbnROYW1lfS5yb2xlY2FsbGAsIChtKSA9PiB7XG4gICAgICAgIGxvZyhgUmVjaWV2ZWQgbWVzc2FnZSBvbiAke2V2ZW50TmFtZX0ucm9sZWNhbGxgKVxuICAgICAgICBtLnJlc3BvbmQoc2MuZW5jb2RlKG5hbWUpKVxuICAgICAgICBsb2coYFJlc3BvbmRlZCB3aXRoIFwiJHtuYW1lfVwiYClcbiAgICAgIH0pXG5cbiAgICAgIHN1YnNjcmliZShuYy5jdXJyZW50LCBgJHtldmVudE5hbWV9LmxvdHRlcnlgLCAobSkgPT4ge1xuICAgICAgICBsb2coXCLwn46JIFlvdSB3b24gdGhlIGxvdHRlcnkhXCIpXG4gICAgICAgIHNldFdvbkxvdHRlcnkodHJ1ZSlcbiAgICAgICAgbS5yZXNwb25kKHNjLmVuY29kZShuYW1lKSlcbiAgICAgIH0sIHsgcXVldWU6IFwibG90dGVyeVwiIH0pXG5cbiAgICAgIHN1YnNjcmliZShuYy5jdXJyZW50LCBgJHtldmVudE5hbWV9Lm5hdmlnYXRlYCwgKG0pID0+IHtcbiAgICAgICAgY29uc3QgdXJsID0gc2MuZGVjb2RlKG0uZGF0YSlcbiAgICAgICAgbG9nKGBOYXZpZ2F0aW5nIHRvICR7dXJsfS4uLmApXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHVybClcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IG9wdHMgPSBjb25zdW1lck9wdHMoKVxuICAgICAgb3B0cy5vcmRlcmVkQ29uc3VtZXIoKVxuICAgICAgY29uc3Qgc3ViID0gYXdhaXQgbmMuY3VycmVudC5qZXRzdHJlYW0oKS5zdWJzY3JpYmUoYCR7ZXZlbnROYW1lfS5zdXJ2ZXlgLCBvcHRzKVxuICAgICAgZm9yIGF3YWl0IChjb25zdCBtIG9mIHN1Yikge1xuICAgICAgICBzZXRTdXJ2ZXlEYXRhKGN1cnJlbnQgPT4gWy4uLmN1cnJlbnQsIGpjLmRlY29kZShtLmRhdGEpXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBuYXRzQ29ubmVjdCgpXG4gIH0sIFtuYW1lLCBzZXJ2ZXJdKVxuXG4gIHJldHVybiAoXG4gICAgPGRpdj5cblxuICAgICAgeyFzdWJtaXR0ZWQgJiYgKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJnLXdoaXRlIHNoYWRvdyByb3VuZGVkLWxnXCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJweC00IHB5LTUgc206cC02XCI+XG4gICAgICAgICAgICB7cXVlc3Rpb25zLm1hcCgocXVlc3Rpb24sIGkpID0+IChcbiAgICAgICAgICAgICAgPGRpdiBrZXk9e2l9IGNsYXNzTmFtZT1cIm1iLThcIj5cbiAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzTmFtZT1cInRleHQtYmFzZSBmb250LW1lZGl1bSB0ZXh0LWdyYXktOTAwXCI+e3F1ZXN0aW9uLmxhYmVsfTwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICA8ZmllbGRzZXQgY2xhc3NOYW1lPVwibXQtNFwiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNwYWNlLXktM1wiPlxuICAgICAgICAgICAgICAgICAgICAgIHtxdWVzdGlvbi5vcHRpb25zLm1hcCgob3B0aW9uKSA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGtleT17b3B0aW9ufSBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZD17b3B0aW9ufVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9e3F1ZXN0aW9uLmlkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJyYWRpb1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiaC00IHctNCBib3JkZXItZ3JheS0zMDAgdGV4dC1pbmRpZ28tNjAwIGZvY3VzOnJpbmctaW5kaWdvLTUwMFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eygpID0+IHVwZGF0ZVN1cnZleShxdWVzdGlvbi5pZCwgb3B0aW9uKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGh0bWxGb3I9e29wdGlvbn0gY2xhc3NOYW1lPVwibWwtMyBibG9jayB0ZXh0LXNtIGZvbnQtbWVkaXVtIHRleHQtZ3JheS03MDBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7b3B0aW9ufVxuICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgPC9maWVsZHNldD5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApKX1cblxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwic3VibWl0XCJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibXQtMyBpbmxpbmUtZmxleCB3LWZ1bGwgaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHJvdW5kZWQtbWQgYm9yZGVyIGJvcmRlci10cmFuc3BhcmVudCBiZy1pbmRpZ28tNjAwIHB4LTQgcHktMiBmb250LW1lZGl1bSB0ZXh0LXdoaXRlIHNoYWRvdy1zbSBob3ZlcjpiZy1pbmRpZ28tNzAwIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTIgZm9jdXM6cmluZy1pbmRpZ28tNTAwIGZvY3VzOnJpbmctb2Zmc2V0LTIgc206bXQtMCBzbTptbC0zIHNtOnctYXV0byBzbTp0ZXh0LXNtXCJcbiAgICAgICAgICAgICAgb25DbGljaz17c3VibWl0U3VydmV5fT5TdWJtaXQ8L2J1dHRvbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuXG4gICAgICB7c3VibWl0dGVkICYmIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYi04XCI+XG4gICAgICAgICAgPGgyIGNsYXNzTmFtZT1cInRleHQtM3hsIG1iLTYgdGV4dC1ib2xkXCI+U3VydmV5IFJlc3VsdHM8L2gyPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ3JpZCBncmlkLWNvbHMtMSBtZDpncmlkLWNvbHMtMyBnYXAtNFwiPlxuICAgICAgICAgICAge3F1ZXN0aW9ucy5tYXAoKHF1ZXN0aW9uLCBpKSA9PiAoXG4gICAgICAgICAgICAgIDxkaXYga2V5PXtpfSBjbGFzc05hbWU9XCJiZy13aGl0ZSBzaGFkb3cgcm91bmRlZC1sZ1wiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicHgtNCBweS01IHNtOnAtNlwiPlxuICAgICAgICAgICAgICAgICAgPGgzIGNsYXNzTmFtZT1cInRleHQteGwgZm9udC1zZW1pYm9sZCBtYi00IGxpbmUtY2xhbXAtMlwiPntxdWVzdGlvbi5sYWJlbH08L2gzPlxuICAgICAgICAgICAgICAgICAgPENoYXJ0IHR5cGU9XCJkb251dFwiIG9wdGlvbnM9e3tcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxzOiBxdWVzdGlvbi5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICBzaG93OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9fSBzZXJpZXM9e3Nlcmllc0RhdGEocXVlc3Rpb24pfSAvPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICkpfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG5cbiAgICAgIHtzdWJtaXR0ZWQgJiYgKFxuICAgICAgICA8ZGl2PlxuICAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LTN4bCBtYi02IHRleHQtYm9sZFwiPkxvZ3M8L2gyPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYmctc2xhdGUtODAwIHJvdW5kZWQtbGcgbWluLWgtWzM4NHB4XSB0ZXh0LWdyYXktNTAgcC02IGZvbnQtbW9ubyBicmVhay1hbGxcIj4ge2xvZ3MubWFwKChsb2csIGkpID0+IChcbiAgICAgICAgICAgIDxkaXYga2V5PXtpfT57bG9nfTwvZGl2PlxuICAgICAgICAgICkpfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG5cbiAgICAgIHt3b25Mb3R0ZXJ5ICYmIChcbiAgICAgICAgPFJlYWN0Q29uZmV0dGlcbiAgICAgICAgbnVtYmVyT2ZQaWVjZXM9ezIwMDB9XG4gICAgICAgIGNvbG9ycz17WycjMjdhYWUxJywgJyMzNGE1NzQnLCAnIzM3NWM5MycsICcjOGRjNjNmJ119XG4gICAgICAgIHJlY3ljbGU9e3RydWV9XG4gIGRyYXdTaGFwZT17Y3R4ID0+IHtcbiAgICBjdHguYmVnaW5QYXRoKClcbiBcbiAgICAgIGNvbnN0IHgxID0gMFxuICAgICAgY29uc3QgeTEgPSAwXG4gICAgICBjdHgubGluZVRvKHgxLCB5MSlcblxuICAgICAgY29uc3QgeDIgPSAwXG4gICAgICBjb25zdCB5MiA9IDIwXG4gICAgICBjdHgubGluZVRvKHgyLCB5MilcblxuICAgICAgY29uc3QgeDMgPSAyMFxuICAgICAgY29uc3QgeTMgPSAwXG4gICAgICBjdHgubGluZVRvKHgzLCB5MylcblxuICAgICAgY29uc3QgeDQgPSAyMFxuICAgICAgY29uc3QgeTQgPSAyMFxuICAgICAgY3R4LmxpbmVUbyh4NCwgeTQpICAgICAgXG4gICAgXG4gICAgY3R4LnN0cm9rZSgpXG4gICAgY3R4LmNsb3NlUGF0aCgpXG4gIH19XG4vPlxuICAgICAgKX1cbiAgICA8L2Rpdj5cbiAgKVxufVxuIl0sIm5hbWVzIjpbImNvbm5lY3QiLCJjb25zdW1lck9wdHMiLCJKU09OQ29kZWMiLCJTdHJpbmdDb2RlYyIsIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJkeW5hbWljIiwiUmVhY3RDb25mZXR0aSIsIkNoYXJ0Iiwic3NyIiwic3Vic2NyaWJlIiwibmMiLCJzdWJqZWN0IiwiY2IiLCJvcHRzIiwic3ViIiwibSIsInF1ZXN0aW9ucyIsImxhYmVsIiwiaWQiLCJvcHRpb25zIiwiRGVtbyIsInByb3BzIiwiZXZlbnROYW1lIiwibmFtZSIsInNlcnZlciIsInN1cnZleSIsInNldFN1cnZleSIsInN1cnZleURhdGEiLCJzZXRTdXJ2ZXlEYXRhIiwibG9ncyIsInNldExvZ3MiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwic3VibWl0dGVkIiwic2V0U3VibWl0dGVkIiwid29uTG90dGVyeSIsInNldFdvbkxvdHRlcnkiLCJ1cGRhdGVTdXJ2ZXkiLCJrIiwidiIsInN1Ym1pdFN1cnZleSIsImpjIiwibG9nIiwiSlNPTiIsInN0cmluZ2lmeSIsImN1cnJlbnQiLCJwdWJsaXNoIiwiZW5jb2RlIiwic2V0SXRlbSIsInNlcmllc0RhdGEiLCJxdWVzdGlvbiIsIm1hcCIsIm9wdGlvbiIsIm4iLCJmb3JFYWNoIiwiZGF0YSIsInRleHQiLCJkIiwiRGF0ZSIsInRvTG9jYWxlVGltZVN0cmluZyIsInRpbWVTdHlsZSIsIm5hdHNDb25uZWN0Iiwic2MiLCJzZXJ2ZXJzIiwicmVzcG9uZCIsInF1ZXVlIiwidXJsIiwiZGVjb2RlIiwid2luZG93IiwibG9jYXRpb24iLCJyZXBsYWNlIiwib3JkZXJlZENvbnN1bWVyIiwiamV0c3RyZWFtIiwiZGl2IiwiY2xhc3NOYW1lIiwiaSIsImZpZWxkc2V0IiwiaW5wdXQiLCJ0eXBlIiwib25DaGFuZ2UiLCJodG1sRm9yIiwiYnV0dG9uIiwib25DbGljayIsImgyIiwiaDMiLCJsYWJlbHMiLCJsZWdlbmQiLCJzaG93Iiwic2VyaWVzIiwibnVtYmVyT2ZQaWVjZXMiLCJjb2xvcnMiLCJyZWN5Y2xlIiwiZHJhd1NoYXBlIiwiY3R4IiwiYmVnaW5QYXRoIiwieDEiLCJ5MSIsImxpbmVUbyIsIngyIiwieTIiLCJ4MyIsInkzIiwieDQiLCJ5NCIsInN0cm9rZSIsImNsb3NlUGF0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/demo.tsx\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/dynamic.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/dynamic.js ***!
  \******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _instanceof = (__webpack_require__(/*! @swc/helpers/lib/_instanceof.js */ \"./node_modules/@swc/helpers/lib/_instanceof.js\")[\"default\"]);\n\"client\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = dynamic;\nexports.noSSR = noSSR;\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar _loadable = _interop_require_default(__webpack_require__(/*! ./loadable */ \"./node_modules/next/dist/shared/lib/loadable.js\"));\nfunction dynamic(dynamicOptions, options) {\n    var loadableFn = _loadable.default;\n    var loadableOptions = (options == null ? void 0 : options.suspense) ? {} : {\n        // A loading component is not required, so we default it\n        loading: function(param) {\n            var error = param.error, isLoading = param.isLoading, pastDelay = param.pastDelay;\n            if (!pastDelay) return null;\n            if (true) {\n                if (isLoading) {\n                    return null;\n                }\n                if (error) {\n                    return /*#__PURE__*/ _react.default.createElement(\"p\", null, error.message, /*#__PURE__*/ _react.default.createElement(\"br\", null), error.stack);\n                }\n            }\n            return null;\n        }\n    };\n    // Support for direct import(), eg: dynamic(import('../hello-world'))\n    // Note that this is only kept for the edge case where someone is passing in a promise as first argument\n    // The react-loadable babel plugin will turn dynamic(import('../hello-world')) into dynamic(() => import('../hello-world'))\n    // To make sure we don't execute the import without rendering first\n    if (_instanceof(dynamicOptions, Promise)) {\n        loadableOptions.loader = function() {\n            return dynamicOptions;\n        };\n    // Support for having import as a function, eg: dynamic(() => import('../hello-world'))\n    } else if (typeof dynamicOptions === \"function\") {\n        loadableOptions.loader = dynamicOptions;\n    // Support for having first argument being options, eg: dynamic({loader: import('../hello-world')})\n    } else if (typeof dynamicOptions === \"object\") {\n        loadableOptions = _extends({}, loadableOptions, dynamicOptions);\n    }\n    // Support for passing options, eg: dynamic(import('../hello-world'), {loading: () => <p>Loading something</p>})\n    loadableOptions = _extends({}, loadableOptions, options);\n    // Error if Fizz rendering is not enabled and `suspense` option is set to true\n    if (false) {}\n    if (loadableOptions.suspense) {\n        if (true) {\n            /**\n       * TODO: Currently, next/dynamic will opt-in to React.lazy if { suspense: true } is used\n       * React 18 will always resolve the Suspense boundary on the server-side, effectively ignoring the ssr option\n       *\n       * In the future, when React Suspense with third-party libraries is stable, we can implement a custom version of\n       * React.lazy that can suspense on the server-side while only loading the component on the client-side\n       */ if (loadableOptions.ssr === false) {\n                console.warn('\"ssr: false\" is ignored by next/dynamic because you can not enable \"suspense\" while disabling \"ssr\" at the same time. Read more: https://nextjs.org/docs/messages/invalid-dynamic-suspense');\n            }\n            if (loadableOptions.loading != null) {\n                console.warn('\"loading\" is ignored by next/dynamic because you have enabled \"suspense\". Place your loading element in your suspense boundary\\'s \"fallback\" prop instead. Read more: https://nextjs.org/docs/messages/invalid-dynamic-suspense');\n            }\n        }\n        delete loadableOptions.ssr;\n        delete loadableOptions.loading;\n    }\n    // coming from build/babel/plugins/react-loadable-plugin.js\n    if (loadableOptions.loadableGenerated) {\n        loadableOptions = _extends({}, loadableOptions, loadableOptions.loadableGenerated);\n        delete loadableOptions.loadableGenerated;\n    }\n    // support for disabling server side rendering, eg: dynamic(import('../hello-world'), {ssr: false}).\n    // skip `ssr` for suspense mode and opt-in React.lazy directly\n    if (typeof loadableOptions.ssr === \"boolean\" && !loadableOptions.suspense) {\n        if (!loadableOptions.ssr) {\n            delete loadableOptions.ssr;\n            return noSSR(loadableFn, loadableOptions);\n        }\n        delete loadableOptions.ssr;\n    }\n    return loadableFn(loadableOptions);\n}\n\"client\";\nvar isServerSide = \"object\" === \"undefined\";\nfunction noSSR(LoadableInitializer, loadableOptions) {\n    // Removing webpack and modules means react-loadable won't try preloading\n    delete loadableOptions.webpack;\n    delete loadableOptions.modules;\n    // This check is necessary to prevent react-loadable from initializing on the server\n    if (!isServerSide) {\n        return LoadableInitializer(loadableOptions);\n    }\n    var Loading = loadableOptions.loading;\n    // This will only be rendered on the server side\n    return function() {\n        return /*#__PURE__*/ _react.default.createElement(Loading, {\n            error: null,\n            isLoading: true,\n            pastDelay: false,\n            timedOut: false\n        });\n    };\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=dynamic.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvZHluYW1pYy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFDYTs7Ozs7QUFEYixRQUFRLENBQUM7QUFFVEEsOENBQTZDO0lBQ3pDRyxLQUFLLEVBQUUsSUFBSTtDQUNkLEVBQUMsQ0FBQztBQUNIRCxrQkFBZSxHQUFHRyxPQUFPLENBQUM7QUFDMUJILGFBQWEsR0FBR0ksS0FBSyxDQUFDO0FBQ3RCLElBQUlDLFFBQVEsR0FBR0MsbUhBQStDO0FBQzlELElBQUlDLHdCQUF3QixHQUFHRCxtSkFBK0Q7QUFDOUYsSUFBSUUsTUFBTSxHQUFHRCx3QkFBd0IsQ0FBQ0QsbUJBQU8sQ0FBQyw0Q0FBTyxDQUFDLENBQUM7QUFDdkQsSUFBSUcsU0FBUyxHQUFHRix3QkFBd0IsQ0FBQ0QsbUJBQU8sQ0FBQyxtRUFBWSxDQUFDLENBQUM7QUFDL0QsU0FBU0gsT0FBTyxDQUFDTyxjQUFjLEVBQUVDLE9BQU8sRUFBRTtJQUN0QyxJQUFJQyxVQUFVLEdBQUdILFNBQVMsQ0FBQ1AsT0FBTztJQUNsQyxJQUFJVyxlQUFlLEdBQUcsQ0FBQ0YsT0FBTyxJQUFJLElBQUksR0FBRyxLQUFLLENBQUMsR0FBR0EsT0FBTyxDQUFDRyxRQUFRLElBQUksRUFBRSxHQUFHO1FBQ3ZFLHdEQUF3RDtRQUN4REMsT0FBTyxFQUFFLGdCQUFzQztnQkFBbkNDLEtBQUssU0FBTEEsS0FBSyxFQUFHQyxTQUFTLFNBQVRBLFNBQVMsRUFBR0MsU0FBUyxTQUFUQSxTQUFTO1lBQ3JDLElBQUksQ0FBQ0EsU0FBUyxFQUFFLE9BQU8sSUFBSSxDQUFDO1lBQzVCLElBQUlDLElBQXNDLEVBQUU7Z0JBQ3hDLElBQUlGLFNBQVMsRUFBRTtvQkFDWCxPQUFPLElBQUksQ0FBQztnQkFDaEIsQ0FBQztnQkFDRCxJQUFJRCxLQUFLLEVBQUU7b0JBQ1AsT0FBTyxXQUFXLEdBQUdSLE1BQU0sQ0FBQ04sT0FBTyxDQUFDa0IsYUFBYSxDQUFDLEdBQUcsRUFBRSxJQUFJLEVB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QztJQUNELElBQU11QixPQUFPLEdBQUd2QixlQUFlLENBQUNFLE9BQU87SUFDdkMsZ0RBQWdEO0lBQ2hELE9BQU87ZUFBSSxXQUFXLEdBQUdQLE1BQU0sQ0FBQ04sT0FBTyxDQUFDa0IsYUFBYSxDQUFDZ0IsT0FBTyxFQUFFO1lBQ3ZEcEIsS0FBSyxFQUFFLElBQUk7WUFDWEMsU0FBUyxFQUFFLElBQUk7WUFDZkMsU0FBUyxFQUFFLEtBQUs7WUFDaEJtQixRQUFRLEVBQUUsS0FBSztTQUNsQixDQUFDO0tBQUEsQ0FBQztBQUNYLENBQUM7QUFFRCxJQUFJLENBQUMsT0FBT3JDLE9BQU8sQ0FBQ0UsT0FBTyxLQUFLLFVBQVUsSUFBSyxPQUFPRixPQUFPLENBQUNFLE9BQU8sS0FBSyxRQUFRLElBQUlGLE9BQU8sQ0FBQ0UsT0FBTyxLQUFLLElBQUksQ0FBQyxJQUFLLE9BQU9GLE9BQU8sQ0FBQ0UsT0FBTyxDQUFDb0MsVUFBVSxLQUFLLFdBQVcsRUFBRTtJQUNyS3hDLE1BQU0sQ0FBQ0MsY0FBYyxDQUFDQyxPQUFPLENBQUNFLE9BQU8sRUFBRSxZQUFZLEVBQUU7UUFBRUQsS0FBSyxFQUFFLElBQUk7S0FBRSxDQUFDLENBQUM7SUFDdEVILE1BQU0sQ0FBQ3lDLE1BQU0sQ0FBQ3ZDLE9BQU8sQ0FBQ0UsT0FBTyxFQUFFRixPQUFPLENBQUMsQ0FBQztJQUN4Q3dDLE1BQU0sQ0FBQ3hDLE9BQU8sR0FBR0EsT0FBTyxDQUFDRSxPQUFPLENBQUM7QUFDbkMsQ0FBQyxDQUVELG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvZHluYW1pYy5qcz9lMjVkIl0sInNvdXJjZXNDb250ZW50IjpbIlwiY2xpZW50XCI7XG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGR5bmFtaWM7XG5leHBvcnRzLm5vU1NSID0gbm9TU1I7XG52YXIgX2V4dGVuZHMgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9fZXh0ZW5kcy5qc1wiKS5kZWZhdWx0O1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5qc1wiKS5kZWZhdWx0O1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9sb2FkYWJsZSA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwiLi9sb2FkYWJsZVwiKSk7XG5mdW5jdGlvbiBkeW5hbWljKGR5bmFtaWNPcHRpb25zLCBvcHRpb25zKSB7XG4gICAgbGV0IGxvYWRhYmxlRm4gPSBfbG9hZGFibGUuZGVmYXVsdDtcbiAgICBsZXQgbG9hZGFibGVPcHRpb25zID0gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuc3VzcGVuc2UpID8ge30gOiB7XG4gICAgICAgIC8vIEEgbG9hZGluZyBjb21wb25lbnQgaXMgbm90IHJlcXVpcmVkLCBzbyB3ZSBkZWZhdWx0IGl0XG4gICAgICAgIGxvYWRpbmc6ICh7IGVycm9yICwgaXNMb2FkaW5nICwgcGFzdERlbGF5ICB9KT0+e1xuICAgICAgICAgICAgaWYgKCFwYXN0RGVsYXkpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTG9hZGluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJwXCIsIG51bGwsIGVycm9yLm1lc3NhZ2UsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImJyXCIsIG51bGwpLCBlcnJvci5zdGFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFN1cHBvcnQgZm9yIGRpcmVjdCBpbXBvcnQoKSwgZWc6IGR5bmFtaWMoaW1wb3J0KCcuLi9oZWxsby13b3JsZCcpKVxuICAgIC8vIE5vdGUgdGhhdCB0aGlzIGlzIG9ubHkga2VwdCBmb3IgdGhlIGVkZ2UgY2FzZSB3aGVyZSBzb21lb25lIGlzIHBhc3NpbmcgaW4gYSBwcm9taXNlIGFzIGZpcnN0IGFyZ3VtZW50XG4gICAgLy8gVGhlIHJlYWN0LWxvYWRhYmxlIGJhYmVsIHBsdWdpbiB3aWxsIHR1cm4gZHluYW1pYyhpbXBvcnQoJy4uL2hlbGxvLXdvcmxkJykpIGludG8gZHluYW1pYygoKSA9PiBpbXBvcnQoJy4uL2hlbGxvLXdvcmxkJykpXG4gICAgLy8gVG8gbWFrZSBzdXJlIHdlIGRvbid0IGV4ZWN1dGUgdGhlIGltcG9ydCB3aXRob3V0IHJlbmRlcmluZyBmaXJzdFxuICAgIGlmIChkeW5hbWljT3B0aW9ucyBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgbG9hZGFibGVPcHRpb25zLmxvYWRlciA9ICgpPT5keW5hbWljT3B0aW9ucztcbiAgICAvLyBTdXBwb3J0IGZvciBoYXZpbmcgaW1wb3J0IGFzIGEgZnVuY3Rpb24sIGVnOiBkeW5hbWljKCgpID0+IGltcG9ydCgnLi4vaGVsbG8td29ybGQnKSlcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkeW5hbWljT3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBsb2FkYWJsZU9wdGlvbnMubG9hZGVyID0gZHluYW1pY09wdGlvbnM7XG4gICAgLy8gU3VwcG9ydCBmb3IgaGF2aW5nIGZpcnN0IGFyZ3VtZW50IGJlaW5nIG9wdGlvbnMsIGVnOiBkeW5hbWljKHtsb2FkZXI6IGltcG9ydCgnLi4vaGVsbG8td29ybGQnKX0pXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZHluYW1pY09wdGlvbnMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGxvYWRhYmxlT3B0aW9ucyA9IF9leHRlbmRzKHt9LCBsb2FkYWJsZU9wdGlvbnMsIGR5bmFtaWNPcHRpb25zKTtcbiAgICB9XG4gICAgLy8gU3VwcG9ydCBmb3IgcGFzc2luZyBvcHRpb25zLCBlZzogZHluYW1pYyhpbXBvcnQoJy4uL2hlbGxvLXdvcmxkJyksIHtsb2FkaW5nOiAoKSA9PiA8cD5Mb2FkaW5nIHNvbWV0aGluZzwvcD59KVxuICAgIGxvYWRhYmxlT3B0aW9ucyA9IF9leHRlbmRzKHt9LCBsb2FkYWJsZU9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIC8vIEVycm9yIGlmIEZpenogcmVuZGVyaW5nIGlzIG5vdCBlbmFibGVkIGFuZCBgc3VzcGVuc2VgIG9wdGlvbiBpcyBzZXQgdG8gdHJ1ZVxuICAgIGlmICghcHJvY2Vzcy5lbnYuX19ORVhUX1JFQUNUX1JPT1QgJiYgbG9hZGFibGVPcHRpb25zLnN1c3BlbnNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzdXNwZW5zZSBvcHRpb24gdXNhZ2UgaW4gbmV4dC9keW5hbWljLiBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2ludmFsaWQtZHluYW1pYy1zdXNwZW5zZWApO1xuICAgIH1cbiAgICBpZiAobG9hZGFibGVPcHRpb25zLnN1c3BlbnNlKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAqIFRPRE86IEN1cnJlbnRseSwgbmV4dC9keW5hbWljIHdpbGwgb3B0LWluIHRvIFJlYWN0LmxhenkgaWYgeyBzdXNwZW5zZTogdHJ1ZSB9IGlzIHVzZWRcbiAgICAgICAqIFJlYWN0IDE4IHdpbGwgYWx3YXlzIHJlc29sdmUgdGhlIFN1c3BlbnNlIGJvdW5kYXJ5IG9uIHRoZSBzZXJ2ZXItc2lkZSwgZWZmZWN0aXZlbHkgaWdub3JpbmcgdGhlIHNzciBvcHRpb25cbiAgICAgICAqXG4gICAgICAgKiBJbiB0aGUgZnV0dXJlLCB3aGVuIFJlYWN0IFN1c3BlbnNlIHdpdGggdGhpcmQtcGFydHkgbGlicmFyaWVzIGlzIHN0YWJsZSwgd2UgY2FuIGltcGxlbWVudCBhIGN1c3RvbSB2ZXJzaW9uIG9mXG4gICAgICAgKiBSZWFjdC5sYXp5IHRoYXQgY2FuIHN1c3BlbnNlIG9uIHRoZSBzZXJ2ZXItc2lkZSB3aGlsZSBvbmx5IGxvYWRpbmcgdGhlIGNvbXBvbmVudCBvbiB0aGUgY2xpZW50LXNpZGVcbiAgICAgICAqLyBpZiAobG9hZGFibGVPcHRpb25zLnNzciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFwic3NyOiBmYWxzZVwiIGlzIGlnbm9yZWQgYnkgbmV4dC9keW5hbWljIGJlY2F1c2UgeW91IGNhbiBub3QgZW5hYmxlIFwic3VzcGVuc2VcIiB3aGlsZSBkaXNhYmxpbmcgXCJzc3JcIiBhdCB0aGUgc2FtZSB0aW1lLiBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2ludmFsaWQtZHluYW1pYy1zdXNwZW5zZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxvYWRhYmxlT3B0aW9ucy5sb2FkaW5nICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFwibG9hZGluZ1wiIGlzIGlnbm9yZWQgYnkgbmV4dC9keW5hbWljIGJlY2F1c2UgeW91IGhhdmUgZW5hYmxlZCBcInN1c3BlbnNlXCIuIFBsYWNlIHlvdXIgbG9hZGluZyBlbGVtZW50IGluIHlvdXIgc3VzcGVuc2UgYm91bmRhcnkncyBcImZhbGxiYWNrXCIgcHJvcCBpbnN0ZWFkLiBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2ludmFsaWQtZHluYW1pYy1zdXNwZW5zZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBsb2FkYWJsZU9wdGlvbnMuc3NyO1xuICAgICAgICBkZWxldGUgbG9hZGFibGVPcHRpb25zLmxvYWRpbmc7XG4gICAgfVxuICAgIC8vIGNvbWluZyBmcm9tIGJ1aWxkL2JhYmVsL3BsdWdpbnMvcmVhY3QtbG9hZGFibGUtcGx1Z2luLmpzXG4gICAgaWYgKGxvYWRhYmxlT3B0aW9ucy5sb2FkYWJsZUdlbmVyYXRlZCkge1xuICAgICAgICBsb2FkYWJsZU9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgbG9hZGFibGVPcHRpb25zLCBsb2FkYWJsZU9wdGlvbnMubG9hZGFibGVHZW5lcmF0ZWQpO1xuICAgICAgICBkZWxldGUgbG9hZGFibGVPcHRpb25zLmxvYWRhYmxlR2VuZXJhdGVkO1xuICAgIH1cbiAgICAvLyBzdXBwb3J0IGZvciBkaXNhYmxpbmcgc2VydmVyIHNpZGUgcmVuZGVyaW5nLCBlZzogZHluYW1pYyhpbXBvcnQoJy4uL2hlbGxvLXdvcmxkJyksIHtzc3I6IGZhbHNlfSkuXG4gICAgLy8gc2tpcCBgc3NyYCBmb3Igc3VzcGVuc2UgbW9kZSBhbmQgb3B0LWluIFJlYWN0LmxhenkgZGlyZWN0bHlcbiAgICBpZiAodHlwZW9mIGxvYWRhYmxlT3B0aW9ucy5zc3IgPT09ICdib29sZWFuJyAmJiAhbG9hZGFibGVPcHRpb25zLnN1c3BlbnNlKSB7XG4gICAgICAgIGlmICghbG9hZGFibGVPcHRpb25zLnNzcikge1xuICAgICAgICAgICAgZGVsZXRlIGxvYWRhYmxlT3B0aW9ucy5zc3I7XG4gICAgICAgICAgICByZXR1cm4gbm9TU1IobG9hZGFibGVGbiwgbG9hZGFibGVPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgbG9hZGFibGVPcHRpb25zLnNzcjtcbiAgICB9XG4gICAgcmV0dXJuIGxvYWRhYmxlRm4obG9hZGFibGVPcHRpb25zKTtcbn1cbidjbGllbnQnO1xuY29uc3QgaXNTZXJ2ZXJTaWRlID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCc7XG5mdW5jdGlvbiBub1NTUihMb2FkYWJsZUluaXRpYWxpemVyLCBsb2FkYWJsZU9wdGlvbnMpIHtcbiAgICAvLyBSZW1vdmluZyB3ZWJwYWNrIGFuZCBtb2R1bGVzIG1lYW5zIHJlYWN0LWxvYWRhYmxlIHdvbid0IHRyeSBwcmVsb2FkaW5nXG4gICAgZGVsZXRlIGxvYWRhYmxlT3B0aW9ucy53ZWJwYWNrO1xuICAgIGRlbGV0ZSBsb2FkYWJsZU9wdGlvbnMubW9kdWxlcztcbiAgICAvLyBUaGlzIGNoZWNrIGlzIG5lY2Vzc2FyeSB0byBwcmV2ZW50IHJlYWN0LWxvYWRhYmxlIGZyb20gaW5pdGlhbGl6aW5nIG9uIHRoZSBzZXJ2ZXJcbiAgICBpZiAoIWlzU2VydmVyU2lkZSkge1xuICAgICAgICByZXR1cm4gTG9hZGFibGVJbml0aWFsaXplcihsb2FkYWJsZU9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBMb2FkaW5nID0gbG9hZGFibGVPcHRpb25zLmxvYWRpbmc7XG4gICAgLy8gVGhpcyB3aWxsIG9ubHkgYmUgcmVuZGVyZWQgb24gdGhlIHNlcnZlciBzaWRlXG4gICAgcmV0dXJuICgpPT4vKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoTG9hZGluZywge1xuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICBpc0xvYWRpbmc6IHRydWUsXG4gICAgICAgICAgICBwYXN0RGVsYXk6IGZhbHNlLFxuICAgICAgICAgICAgdGltZWRPdXQ6IGZhbHNlXG4gICAgICAgIH0pO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1keW5hbWljLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHQiLCJkeW5hbWljIiwibm9TU1IiLCJfZXh0ZW5kcyIsInJlcXVpcmUiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJfcmVhY3QiLCJfbG9hZGFibGUiLCJkeW5hbWljT3B0aW9ucyIsIm9wdGlvbnMiLCJsb2FkYWJsZUZuIiwibG9hZGFibGVPcHRpb25zIiwic3VzcGVuc2UiLCJsb2FkaW5nIiwiZXJyb3IiLCJpc0xvYWRpbmciLCJwYXN0RGVsYXkiLCJwcm9jZXNzIiwiY3JlYXRlRWxlbWVudCIsIm1lc3NhZ2UiLCJzdGFjayIsIlByb21pc2UiLCJsb2FkZXIiLCJlbnYiLCJfX05FWFRfUkVBQ1RfUk9PVCIsIkVycm9yIiwic3NyIiwiY29uc29sZSIsIndhcm4iLCJsb2FkYWJsZUdlbmVyYXRlZCIsImlzU2VydmVyU2lkZSIsIkxvYWRhYmxlSW5pdGlhbGl6ZXIiLCJ3ZWJwYWNrIiwibW9kdWxlcyIsIkxvYWRpbmciLCJ0aW1lZE91dCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/dynamic.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/loadable-context.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/loadable-context.js ***!
  \***************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.LoadableContext = void 0;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar LoadableContext = _react.default.createContext(null);\nexports.LoadableContext = LoadableContext;\nif (true) {\n    LoadableContext.displayName = \"LoadableContext\";\n} //# sourceMappingURL=loadable-context.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvbG9hZGFibGUtY29udGV4dC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLEtBQUssRUFBRSxJQUFJO0NBQ2QsRUFBQyxDQUFDO0FBQ0hELHVCQUF1QixHQUFHLEtBQUssQ0FBQyxDQUFDO0FBQ2pDLElBQUlHLHdCQUF3QixHQUFHQyxtSkFBK0Q7QUFDOUYsSUFBSUUsTUFBTSxHQUFHSCx3QkFBd0IsQ0FBQ0MsbUJBQU8sQ0FBQyw0Q0FBTyxDQUFDLENBQUM7QUFDdkQsSUFBTUYsZUFBZSxHQUFHSSxNQUFNLENBQUNELE9BQU8sQ0FBQ0UsYUFBYSxDQUFDLElBQUksQ0FBQztBQUMxRFAsdUJBQXVCLEdBQUdFLGVBQWUsQ0FBQztBQUMxQyxJQUFJTSxJQUFxQyxFQUFFO0lBQ3ZDTixlQUFlLENBQUNPLFdBQVcsR0FBRyxpQkFBaUIsQ0FBQztBQUNwRCxDQUFDLENBRUQsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9sb2FkYWJsZS1jb250ZXh0LmpzP2VjMjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkxvYWRhYmxlQ29udGV4dCA9IHZvaWQgMDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuanNcIikuZGVmYXVsdDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbmNvbnN0IExvYWRhYmxlQ29udGV4dCA9IF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5leHBvcnRzLkxvYWRhYmxlQ29udGV4dCA9IExvYWRhYmxlQ29udGV4dDtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgTG9hZGFibGVDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0xvYWRhYmxlQ29udGV4dCc7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWRhYmxlLWNvbnRleHQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiTG9hZGFibGVDb250ZXh0IiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsImRlZmF1bHQiLCJfcmVhY3QiLCJjcmVhdGVDb250ZXh0IiwicHJvY2VzcyIsImRpc3BsYXlOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/loadable-context.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/loadable.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/loadable.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _classCallCheck = (__webpack_require__(/*! @swc/helpers/lib/_class_call_check.js */ \"./node_modules/@swc/helpers/lib/_class_call_check.js\")[\"default\"]);\nvar _createClass = (__webpack_require__(/*! @swc/helpers/lib/_create_class.js */ \"./node_modules/@swc/helpers/lib/_create_class.js\")[\"default\"]);\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar _loadableContext = __webpack_require__(/*! ./loadable-context */ \"./node_modules/next/dist/shared/lib/loadable-context.js\");\nvar useSyncExternalStore = ( true ? __webpack_require__(/*! react */ \"./node_modules/react/index.js\") : 0).useSyncExternalStore;\nvar ALL_INITIALIZERS = [];\nvar READY_INITIALIZERS = [];\nvar initialized = false;\nfunction load(loader) {\n    var promise = loader();\n    var state = {\n        loading: true,\n        loaded: null,\n        error: null\n    };\n    state.promise = promise.then(function(loaded) {\n        state.loading = false;\n        state.loaded = loaded;\n        return loaded;\n    }).catch(function(err) {\n        state.loading = false;\n        state.error = err;\n        throw err;\n    });\n    return state;\n}\nfunction resolve(obj) {\n    return obj && obj.__esModule ? obj.default : obj;\n}\nfunction createLoadableComponent(loadFn, options) {\n    var init = function init() {\n        if (!subscription) {\n            var sub = new LoadableSubscription(loadFn, opts);\n            subscription = {\n                getCurrentValue: sub.getCurrentValue.bind(sub),\n                subscribe: sub.subscribe.bind(sub),\n                retry: sub.retry.bind(sub),\n                promise: sub.promise.bind(sub)\n            };\n        }\n        return subscription.promise();\n    };\n    var useLoadableModule = function useLoadableModule() {\n        _s();\n        init();\n        var context = _react.default.useContext(_loadableContext.LoadableContext);\n        if (context && Array.isArray(opts.modules)) {\n            opts.modules.forEach(function(moduleName) {\n                context(moduleName);\n            });\n        }\n    };\n    var LoadableImpl = function LoadableImpl(props, ref) {\n        _s1();\n        useLoadableModule();\n        var state = useSyncExternalStore(subscription.subscribe, subscription.getCurrentValue, subscription.getCurrentValue);\n        _react.default.useImperativeHandle(ref, function() {\n            return {\n                retry: subscription.retry\n            };\n        }, []);\n        return _react.default.useMemo(function() {\n            if (state.loading || state.error) {\n                return _react.default.createElement(opts.loading, {\n                    isLoading: state.loading,\n                    pastDelay: state.pastDelay,\n                    timedOut: state.timedOut,\n                    error: state.error,\n                    retry: subscription.retry\n                });\n            } else if (state.loaded) {\n                return _react.default.createElement(resolve(state.loaded), props);\n            } else {\n                return null;\n            }\n        }, [\n            props,\n            state\n        ]);\n    };\n    var LazyImpl = function LazyImpl(props, ref) {\n        _s2();\n        useLoadableModule();\n        return _react.default.createElement(opts.lazy, _extends({}, props, {\n            ref: ref\n        }));\n    };\n    var _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$();\n    var opts = Object.assign({\n        loader: null,\n        loading: null,\n        delay: 200,\n        timeout: null,\n        webpack: null,\n        modules: null,\n        suspense: false\n    }, options);\n    if (opts.suspense) {\n        opts.lazy = _react.default.lazy(opts.loader);\n    }\n    /** @type LoadableSubscription */ var subscription = null;\n    // Server only\n    if (false) {}\n    // Client only\n    if (!initialized && \"object\" !== \"undefined\") {\n        // require.resolveWeak check is needed for environments that don't have it available like Jest\n        var moduleIds = opts.webpack && \"function\" === \"function\" ? opts.webpack() : opts.modules;\n        if (moduleIds) {\n            READY_INITIALIZERS.push(function(ids) {\n                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n                try {\n                    for(var _iterator = moduleIds[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                        var moduleId = _step.value;\n                        if (ids.indexOf(moduleId) !== -1) {\n                            return init();\n                        }\n                    }\n                } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                } finally{\n                    try {\n                        if (!_iteratorNormalCompletion && _iterator.return != null) {\n                            _iterator.return();\n                        }\n                    } finally{\n                        if (_didIteratorError) {\n                            throw _iteratorError;\n                        }\n                    }\n                }\n            });\n        }\n    }\n    _s(useLoadableModule, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n    _s1(LoadableImpl, \"FetqI339RA+IfltT8VNzX8RMZ2Q=\", false, function() {\n        return [\n            useLoadableModule,\n            useSyncExternalStore\n        ];\n    });\n    _s2(LazyImpl, \"XqzK/zLs5iif4pSUu9JgPZdGT3E=\", false, function() {\n        return [\n            useLoadableModule\n        ];\n    });\n    var LoadableComponent = opts.suspense ? LazyImpl : LoadableImpl;\n    LoadableComponent.preload = function() {\n        return init();\n    };\n    LoadableComponent.displayName = \"LoadableComponent\";\n    return _react.default.forwardRef(LoadableComponent);\n}\nvar LoadableSubscription = /*#__PURE__*/ function() {\n    function LoadableSubscription(loadFn, opts) {\n        _classCallCheck(this, LoadableSubscription);\n        this._loadFn = loadFn;\n        this._opts = opts;\n        this._callbacks = new Set();\n        this._delay = null;\n        this._timeout = null;\n        this.retry();\n    }\n    _createClass(LoadableSubscription, [\n        {\n            key: \"promise\",\n            value: function promise() {\n                return this._res.promise;\n            }\n        },\n        {\n            key: \"retry\",\n            value: function retry() {\n                var _this = this;\n                this._clearTimeouts();\n                this._res = this._loadFn(this._opts.loader);\n                this._state = {\n                    pastDelay: false,\n                    timedOut: false\n                };\n                var ref = this, res = ref._res, opts = ref._opts;\n                if (res.loading) {\n                    if (typeof opts.delay === \"number\") {\n                        if (opts.delay === 0) {\n                            this._state.pastDelay = true;\n                        } else {\n                            this._delay = setTimeout(function() {\n                                _this._update({\n                                    pastDelay: true\n                                });\n                            }, opts.delay);\n                        }\n                    }\n                    if (typeof opts.timeout === \"number\") {\n                        this._timeout = setTimeout(function() {\n                            _this._update({\n                                timedOut: true\n                            });\n                        }, opts.timeout);\n                    }\n                }\n                this._res.promise.then(function() {\n                    _this._update({});\n                    _this._clearTimeouts();\n                }).catch(function(_err) {\n                    _this._update({});\n                    _this._clearTimeouts();\n                });\n                this._update({});\n            }\n        },\n        {\n            key: \"_update\",\n            value: function _update(partial) {\n                this._state = _extends({}, this._state, {\n                    error: this._res.error,\n                    loaded: this._res.loaded,\n                    loading: this._res.loading\n                }, partial);\n                this._callbacks.forEach(function(callback) {\n                    return callback();\n                });\n            }\n        },\n        {\n            key: \"_clearTimeouts\",\n            value: function _clearTimeouts() {\n                clearTimeout(this._delay);\n                clearTimeout(this._timeout);\n            }\n        },\n        {\n            key: \"getCurrentValue\",\n            value: function getCurrentValue() {\n                return this._state;\n            }\n        },\n        {\n            key: \"subscribe\",\n            value: function subscribe(callback) {\n                var _this = this;\n                this._callbacks.add(callback);\n                return function() {\n                    _this._callbacks.delete(callback);\n                };\n            }\n        }\n    ]);\n    return LoadableSubscription;\n}();\nfunction Loadable(opts) {\n    return createLoadableComponent(load, opts);\n}\n_c = Loadable;\nfunction flushInitializers(initializers, ids) {\n    var promises = [];\n    while(initializers.length){\n        var init = initializers.pop();\n        promises.push(init(ids));\n    }\n    return Promise.all(promises).then(function() {\n        if (initializers.length) {\n            return flushInitializers(initializers, ids);\n        }\n    });\n}\nLoadable.preloadAll = function() {\n    return new Promise(function(resolveInitializers, reject) {\n        flushInitializers(ALL_INITIALIZERS).then(resolveInitializers, reject);\n    });\n};\nLoadable.preloadReady = function() {\n    var ids = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n    return new Promise(function(resolvePreload) {\n        var res = function() {\n            initialized = true;\n            return resolvePreload();\n        };\n        // We always will resolve, errors should be handled within loading UIs.\n        flushInitializers(READY_INITIALIZERS, ids).then(res, res);\n    });\n};\nif (true) {\n    window.__NEXT_PRELOADREADY = Loadable.preloadReady;\n}\nvar _default = Loadable;\nexports[\"default\"] = _default; //# sourceMappingURL=loadable.js.map\nvar _c;\n$RefreshReg$(_c, \"Loadable\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvbG9hZGFibGUuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7Ozs7OztBQUNiQSw4Q0FBNkM7SUFDekNHLEtBQUssRUFBRSxJQUFJO0NBQ2QsRUFBQyxDQUFDO0FBQ0hELGtCQUFlLEdBQUcsS0FBSyxDQUFDLENBQUM7QUFDekIsSUFBSUcsUUFBUSxHQUFHQyxtSEFBK0M7QUFDOUQsSUFBSUMsd0JBQXdCLEdBQUdELG1KQUErRDtBQUM5RixJQUFJRSxNQUFNLEdBQUdELHdCQUF3QixDQUFDRCxtQkFBTyxDQUFDLDRDQUFPLENBQUMsQ0FBQztBQUN2RCxJQUFJRyxnQkFBZ0IsR0FBR0gsbUJBQU8sQ0FBQyxtRkFBb0IsQ0FBQztBQUNwRCxJQUFNLG9CQUFzQixHQUFNSyxDQUFBQSxLQUE2QixHQUFHTCxtQkFBTyxDQUFDLDRDQUFPLENBQUMsR0FBR0EsQ0FBdUMsRUFBcEhJLG9CQUFvQjtBQUM1QixJQUFNSSxnQkFBZ0IsR0FBRyxFQUFFO0FBQzNCLElBQU1DLGtCQUFrQixHQUFHLEVBQUU7QUFDN0IsSUFBSUMsV0FBVyxHQUFHLEtBQUs7QUFDdkIsU0FBU0MsSUFBSSxDQUFDQyxNQUFNLEVBQUU7SUFDbEIsSUFBSUMsT0FBTyxHQUFHRCxNQUFNLEVBQUU7SUFDdEIsSUFBSUUsS0FBSyxHQUFHO1FBQ1JDLE9BQU8sRUFBRSxJQUFJO1FBQ2JDLE1BQU0sRUFBRSxJQUFJO1FBQ1pDLEtBQUssRUFBRSxJQUFJO0tBQ2Q7SUFDREgsS0FBSyxDQUFDRCxPQUFPLEdBQUdBLE9BQU8sQ0FBQ0ssSUFBSSxDQUFDLFNBQUNGLE1BQU0sRUFBRztRQUNuQ0YsS0FBSyxDQUFDQyxPQUFPLEdBQUcsS0FBSyxDQUFDO1FBQ3RCRCxLQUFLLENBQUNFLE1BQU0sR0FBR0EsTUFBTSxDQUFDO1FBQ3RCLE9BQU9BLE1BQU0sQ0FBQztJQUNsQixDQUFDLENBQUMsQ0FBQ0csS0FBSyxDQUFDLFNBQUNDLEdBQUcsRUFBRztRQUNaTixL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RTtRQUN2RVgsaUJBQWlCLENBQUNqRixrQkFBa0IsRUFBRXVELEdBQUcsQ0FBQyxDQUFDOUMsSUFBSSxDQUFDOEQsR0FBRyxFQUFFQSxHQUFHLENBQUMsQ0FBQztJQUM5RCxDQUFDLENBQUMsQ0FBQztBQUNQLENBQUMsQ0FBQztBQUNGLElBQUksSUFBNkIsRUFBRTtJQUMvQnNCLE1BQU0sQ0FBQ0MsbUJBQW1CLEdBQUdkLFFBQVEsQ0FBQ1csWUFBWSxDQUFDO0FBQ3ZELENBQUM7QUFDRCxJQUFJSSxRQUFRLEdBQUdmLFFBQVE7QUFDdkI3RixrQkFBZSxHQUFHNEcsUUFBUSxDQUFDLENBRTNCLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvbG9hZGFibGUuanM/NTEwNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfZXh0ZW5kcyA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19leHRlbmRzLmpzXCIpLmRlZmF1bHQ7XG52YXIgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0LmpzXCIpLmRlZmF1bHQ7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX2xvYWRhYmxlQ29udGV4dCA9IHJlcXVpcmUoXCIuL2xvYWRhYmxlLWNvbnRleHRcIik7XG5jb25zdCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlICB9ID0gcHJvY2Vzcy5lbnYuX19ORVhUX1JFQUNUX1JPT1QgPyByZXF1aXJlKCdyZWFjdCcpIDogcmVxdWlyZSgndXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbScpO1xuY29uc3QgQUxMX0lOSVRJQUxJWkVSUyA9IFtdO1xuY29uc3QgUkVBRFlfSU5JVElBTElaRVJTID0gW107XG5sZXQgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGxvYWQobG9hZGVyKSB7XG4gICAgbGV0IHByb21pc2UgPSBsb2FkZXIoKTtcbiAgICBsZXQgc3RhdGUgPSB7XG4gICAgICAgIGxvYWRpbmc6IHRydWUsXG4gICAgICAgIGxvYWRlZDogbnVsbCxcbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICB9O1xuICAgIHN0YXRlLnByb21pc2UgPSBwcm9taXNlLnRoZW4oKGxvYWRlZCk9PntcbiAgICAgICAgc3RhdGUubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5sb2FkZWQgPSBsb2FkZWQ7XG4gICAgICAgIHJldHVybiBsb2FkZWQ7XG4gICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgc3RhdGUubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5lcnJvciA9IGVycjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xuICAgIHJldHVybiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIHJlc29sdmUob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iai5kZWZhdWx0IDogb2JqO1xufVxuZnVuY3Rpb24gY3JlYXRlTG9hZGFibGVDb21wb25lbnQobG9hZEZuLCBvcHRpb25zKSB7XG4gICAgbGV0IG9wdHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgbG9hZGVyOiBudWxsLFxuICAgICAgICBsb2FkaW5nOiBudWxsLFxuICAgICAgICBkZWxheTogMjAwLFxuICAgICAgICB0aW1lb3V0OiBudWxsLFxuICAgICAgICB3ZWJwYWNrOiBudWxsLFxuICAgICAgICBtb2R1bGVzOiBudWxsLFxuICAgICAgICBzdXNwZW5zZTogZmFsc2VcbiAgICB9LCBvcHRpb25zKTtcbiAgICBpZiAob3B0cy5zdXNwZW5zZSkge1xuICAgICAgICBvcHRzLmxhenkgPSBfcmVhY3QuZGVmYXVsdC5sYXp5KG9wdHMubG9hZGVyKTtcbiAgICB9XG4gICAgLyoqIEB0eXBlIExvYWRhYmxlU3Vic2NyaXB0aW9uICovIGxldCBzdWJzY3JpcHRpb24gPSBudWxsO1xuICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgIGlmICghc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSBuZXcgTG9hZGFibGVTdWJzY3JpcHRpb24obG9hZEZuLCBvcHRzKTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBnZXRDdXJyZW50VmFsdWU6IHN1Yi5nZXRDdXJyZW50VmFsdWUuYmluZChzdWIpLFxuICAgICAgICAgICAgICAgIHN1YnNjcmliZTogc3ViLnN1YnNjcmliZS5iaW5kKHN1YiksXG4gICAgICAgICAgICAgICAgcmV0cnk6IHN1Yi5yZXRyeS5iaW5kKHN1YiksXG4gICAgICAgICAgICAgICAgcHJvbWlzZTogc3ViLnByb21pc2UuYmluZChzdWIpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb24ucHJvbWlzZSgpO1xuICAgIH1cbiAgICAvLyBTZXJ2ZXIgb25seVxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBBTExfSU5JVElBTElaRVJTLnB1c2goaW5pdCk7XG4gICAgfVxuICAgIC8vIENsaWVudCBvbmx5XG4gICAgaWYgKCFpbml0aWFsaXplZCAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyByZXF1aXJlLnJlc29sdmVXZWFrIGNoZWNrIGlzIG5lZWRlZCBmb3IgZW52aXJvbm1lbnRzIHRoYXQgZG9uJ3QgaGF2ZSBpdCBhdmFpbGFibGUgbGlrZSBKZXN0XG4gICAgICAgIGNvbnN0IG1vZHVsZUlkcyA9IG9wdHMud2VicGFjayAmJiB0eXBlb2YgcmVxdWlyZS5yZXNvbHZlV2VhayA9PT0gJ2Z1bmN0aW9uJyA/IG9wdHMud2VicGFjaygpIDogb3B0cy5tb2R1bGVzO1xuICAgICAgICBpZiAobW9kdWxlSWRzKSB7XG4gICAgICAgICAgICBSRUFEWV9JTklUSUFMSVpFUlMucHVzaCgoaWRzKT0+e1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbW9kdWxlSWQgb2YgbW9kdWxlSWRzKXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkcy5pbmRleE9mKG1vZHVsZUlkKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbml0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VMb2FkYWJsZU1vZHVsZSgpIHtcbiAgICAgICAgaW5pdCgpO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gX3JlYWN0LmRlZmF1bHQudXNlQ29udGV4dChfbG9hZGFibGVDb250ZXh0LkxvYWRhYmxlQ29udGV4dCk7XG4gICAgICAgIGlmIChjb250ZXh0ICYmIEFycmF5LmlzQXJyYXkob3B0cy5tb2R1bGVzKSkge1xuICAgICAgICAgICAgb3B0cy5tb2R1bGVzLmZvckVhY2goKG1vZHVsZU5hbWUpPT57XG4gICAgICAgICAgICAgICAgY29udGV4dChtb2R1bGVOYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIExvYWRhYmxlSW1wbChwcm9wcywgcmVmKSB7XG4gICAgICAgIHVzZUxvYWRhYmxlTW9kdWxlKCk7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaXB0aW9uLnN1YnNjcmliZSwgc3Vic2NyaXB0aW9uLmdldEN1cnJlbnRWYWx1ZSwgc3Vic2NyaXB0aW9uLmdldEN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIF9yZWFjdC5kZWZhdWx0LnVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKT0+KHtcbiAgICAgICAgICAgICAgICByZXRyeTogc3Vic2NyaXB0aW9uLnJldHJ5XG4gICAgICAgICAgICB9KSwgW10pO1xuICAgICAgICByZXR1cm4gX3JlYWN0LmRlZmF1bHQudXNlTWVtbygoKT0+e1xuICAgICAgICAgICAgaWYgKHN0YXRlLmxvYWRpbmcgfHwgc3RhdGUuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChvcHRzLmxvYWRpbmcsIHtcbiAgICAgICAgICAgICAgICAgICAgaXNMb2FkaW5nOiBzdGF0ZS5sb2FkaW5nLFxuICAgICAgICAgICAgICAgICAgICBwYXN0RGVsYXk6IHN0YXRlLnBhc3REZWxheSxcbiAgICAgICAgICAgICAgICAgICAgdGltZWRPdXQ6IHN0YXRlLnRpbWVkT3V0LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogc3RhdGUuZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIHJldHJ5OiBzdWJzY3JpcHRpb24ucmV0cnlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQocmVzb2x2ZShzdGF0ZS5sb2FkZWQpLCBwcm9wcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbXG4gICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBMYXp5SW1wbChwcm9wcywgcmVmKSB7XG4gICAgICAgIHVzZUxvYWRhYmxlTW9kdWxlKCk7XG4gICAgICAgIHJldHVybiBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KG9wdHMubGF6eSwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICAgICAgICByZWZcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBjb25zdCBMb2FkYWJsZUNvbXBvbmVudCA9IG9wdHMuc3VzcGVuc2UgPyBMYXp5SW1wbCA6IExvYWRhYmxlSW1wbDtcbiAgICBMb2FkYWJsZUNvbXBvbmVudC5wcmVsb2FkID0gKCk9PmluaXQoKTtcbiAgICBMb2FkYWJsZUNvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdMb2FkYWJsZUNvbXBvbmVudCc7XG4gICAgcmV0dXJuIF9yZWFjdC5kZWZhdWx0LmZvcndhcmRSZWYoTG9hZGFibGVDb21wb25lbnQpO1xufVxuY2xhc3MgTG9hZGFibGVTdWJzY3JpcHRpb24ge1xuICAgIHByb21pc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXMucHJvbWlzZTtcbiAgICB9XG4gICAgcmV0cnkoKSB7XG4gICAgICAgIHRoaXMuX2NsZWFyVGltZW91dHMoKTtcbiAgICAgICAgdGhpcy5fcmVzID0gdGhpcy5fbG9hZEZuKHRoaXMuX29wdHMubG9hZGVyKTtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSB7XG4gICAgICAgICAgICBwYXN0RGVsYXk6IGZhbHNlLFxuICAgICAgICAgICAgdGltZWRPdXQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHsgX3JlczogcmVzICwgX29wdHM6IG9wdHMgIH0gPSB0aGlzO1xuICAgICAgICBpZiAocmVzLmxvYWRpbmcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0cy5kZWxheSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5kZWxheSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZS5wYXN0RGVsYXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlbGF5ID0gc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXN0RGVsYXk6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LCBvcHRzLmRlbGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdHMudGltZW91dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWRPdXQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgb3B0cy50aW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXMucHJvbWlzZS50aGVuKCgpPT57XG4gICAgICAgICAgICB0aGlzLl91cGRhdGUoe30pO1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0cygpO1xuICAgICAgICB9KS5jYXRjaCgoX2Vycik9PntcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSh7fSk7XG4gICAgICAgICAgICB0aGlzLl9jbGVhclRpbWVvdXRzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl91cGRhdGUoe30pO1xuICAgIH1cbiAgICBfdXBkYXRlKHBhcnRpYWwpIHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBfZXh0ZW5kcyh7fSwgdGhpcy5fc3RhdGUsIHtcbiAgICAgICAgICAgIGVycm9yOiB0aGlzLl9yZXMuZXJyb3IsXG4gICAgICAgICAgICBsb2FkZWQ6IHRoaXMuX3Jlcy5sb2FkZWQsXG4gICAgICAgICAgICBsb2FkaW5nOiB0aGlzLl9yZXMubG9hZGluZ1xuICAgICAgICB9LCBwYXJ0aWFsKTtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzLmZvckVhY2goKGNhbGxiYWNrKT0+Y2FsbGJhY2soKSk7XG4gICAgfVxuICAgIF9jbGVhclRpbWVvdXRzKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fZGVsYXkpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gICAgfVxuICAgIGdldEN1cnJlbnRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgIH1cbiAgICBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGxvYWRGbiwgb3B0cyl7XG4gICAgICAgIHRoaXMuX2xvYWRGbiA9IGxvYWRGbjtcbiAgICAgICAgdGhpcy5fb3B0cyA9IG9wdHM7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5fZGVsYXkgPSBudWxsO1xuICAgICAgICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXRyeSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIExvYWRhYmxlKG9wdHMpIHtcbiAgICByZXR1cm4gY3JlYXRlTG9hZGFibGVDb21wb25lbnQobG9hZCwgb3B0cyk7XG59XG5mdW5jdGlvbiBmbHVzaEluaXRpYWxpemVycyhpbml0aWFsaXplcnMsIGlkcykge1xuICAgIGxldCBwcm9taXNlcyA9IFtdO1xuICAgIHdoaWxlKGluaXRpYWxpemVycy5sZW5ndGgpe1xuICAgICAgICBsZXQgaW5pdCA9IGluaXRpYWxpemVycy5wb3AoKTtcbiAgICAgICAgcHJvbWlzZXMucHVzaChpbml0KGlkcykpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oKCk9PntcbiAgICAgICAgaWYgKGluaXRpYWxpemVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmbHVzaEluaXRpYWxpemVycyhpbml0aWFsaXplcnMsIGlkcyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbkxvYWRhYmxlLnByZWxvYWRBbGwgPSAoKT0+e1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZUluaXRpYWxpemVycywgcmVqZWN0KT0+e1xuICAgICAgICBmbHVzaEluaXRpYWxpemVycyhBTExfSU5JVElBTElaRVJTKS50aGVuKHJlc29sdmVJbml0aWFsaXplcnMsIHJlamVjdCk7XG4gICAgfSk7XG59O1xuTG9hZGFibGUucHJlbG9hZFJlYWR5ID0gKGlkcyA9IFtdKT0+e1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZVByZWxvYWQpPT57XG4gICAgICAgIGNvbnN0IHJlcyA9ICgpPT57XG4gICAgICAgICAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZVByZWxvYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gV2UgYWx3YXlzIHdpbGwgcmVzb2x2ZSwgZXJyb3JzIHNob3VsZCBiZSBoYW5kbGVkIHdpdGhpbiBsb2FkaW5nIFVJcy5cbiAgICAgICAgZmx1c2hJbml0aWFsaXplcnMoUkVBRFlfSU5JVElBTElaRVJTLCBpZHMpLnRoZW4ocmVzLCByZXMpO1xuICAgIH0pO1xufTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHdpbmRvdy5fX05FWFRfUFJFTE9BRFJFQURZID0gTG9hZGFibGUucHJlbG9hZFJlYWR5O1xufVxudmFyIF9kZWZhdWx0ID0gTG9hZGFibGU7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZGFibGUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdCIsIl9leHRlbmRzIiwicmVxdWlyZSIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsIl9yZWFjdCIsIl9sb2FkYWJsZUNvbnRleHQiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfUkVBQ1RfUk9PVCIsIkFMTF9JTklUSUFMSVpFUlMiLCJSRUFEWV9JTklUSUFMSVpFUlMiLCJpbml0aWFsaXplZCIsImxvYWQiLCJsb2FkZXIiLCJwcm9taXNlIiwic3RhdGUiLCJsb2FkaW5nIiwibG9hZGVkIiwiZXJyb3IiLCJ0aGVuIiwiY2F0Y2giLCJlcnIiLCJyZXNvbHZlIiwib2JqIiwiX19lc01vZHVsZSIsImNyZWF0ZUxvYWRhYmxlQ29tcG9uZW50IiwibG9hZEZuIiwib3B0aW9ucyIsImluaXQiLCJzdWJzY3JpcHRpb24iLCJzdWIiLCJMb2FkYWJsZVN1YnNjcmlwdGlvbiIsIm9wdHMiLCJnZXRDdXJyZW50VmFsdWUiLCJiaW5kIiwic3Vic2NyaWJlIiwicmV0cnkiLCJ1c2VMb2FkYWJsZU1vZHVsZSIsImNvbnRleHQiLCJ1c2VDb250ZXh0IiwiTG9hZGFibGVDb250ZXh0IiwiQXJyYXkiLCJpc0FycmF5IiwibW9kdWxlcyIsImZvckVhY2giLCJtb2R1bGVOYW1lIiwiTG9hZGFibGVJbXBsIiwicHJvcHMiLCJyZWYiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwidXNlTWVtbyIsImNyZWF0ZUVsZW1lbnQiLCJpc0xvYWRpbmciLCJwYXN0RGVsYXkiLCJ0aW1lZE91dCIsIkxhenlJbXBsIiwibGF6eSIsImFzc2lnbiIsImRlbGF5IiwidGltZW91dCIsIndlYnBhY2siLCJzdXNwZW5zZSIsInB1c2giLCJtb2R1bGVJZHMiLCJyZXNvbHZlV2VhayIsImlkcyIsIm1vZHVsZUlkIiwiaW5kZXhPZiIsIkxvYWRhYmxlQ29tcG9uZW50IiwicHJlbG9hZCIsImRpc3BsYXlOYW1lIiwiZm9yd2FyZFJlZiIsIl9sb2FkRm4iLCJfb3B0cyIsIl9jYWxsYmFja3MiLCJTZXQiLCJfZGVsYXkiLCJfdGltZW91dCIsIl9yZXMiLCJfY2xlYXJUaW1lb3V0cyIsIl9zdGF0ZSIsInJlcyIsInNldFRpbWVvdXQiLCJfdXBkYXRlIiwiX2VyciIsInBhcnRpYWwiLCJjYWxsYmFjayIsImNsZWFyVGltZW91dCIsImFkZCIsImRlbGV0ZSIsIkxvYWRhYmxlIiwiZmx1c2hJbml0aWFsaXplcnMiLCJpbml0aWFsaXplcnMiLCJwcm9taXNlcyIsImxlbmd0aCIsInBvcCIsIlByb21pc2UiLCJhbGwiLCJwcmVsb2FkQWxsIiwicmVzb2x2ZUluaXRpYWxpemVycyIsInJlamVjdCIsInByZWxvYWRSZWFkeSIsInJlc29sdmVQcmVsb2FkIiwid2luZG93IiwiX19ORVhUX1BSRUxPQURSRUFEWSIsIl9kZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/loadable.js\n"));

/***/ }),

/***/ "./pages/index.tsx":
/*!*************************!*\
  !*** ./pages/index.tsx ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/head */ \"./node_modules/next/head.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _components_demo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/demo */ \"./components/demo.tsx\");\nvar _this = undefined;\n\nvar _s = $RefreshSig$();\n\n\n\nvar server = \"wss://demo.nats.io:8443\" || 0;\nvar eventName = \"kubecon23eu\" || 0;\nvar Home = function() {\n    _s();\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\"), text = ref[0], setText = ref[1];\n    var ref1 = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\"), name = ref1[0], setName = ref1[1];\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(function() {\n        var n = localStorage.getItem(\"name\");\n        if (n != null) {\n            setName(n);\n        }\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"text-center p-2 text-white bg-slate-800 flex justify-between\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex gap-4\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"font-bold\",\n                        children: \"KubeConEU 2023\"\n                    }, void 0, false, {\n                        fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/pages/index.tsx\",\n                        lineNumber: 24,\n                        columnNumber: 9\n                    }, _this)\n                }, void 0, false, {\n                    fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/pages/index.tsx\",\n                    lineNumber: 23,\n                    columnNumber: 7\n                }, _this)\n            }, void 0, false, {\n                fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/pages/index.tsx\",\n                lineNumber: 22,\n                columnNumber: 5\n            }, _this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"container mx-auto flex flex-col w-screen pt-16 justify-center px-4\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_head__WEBPACK_IMPORTED_MODULE_1___default()), {\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                            rel: \"stylesheet\",\n                            href: \"https://rsms.me/inter/inter.css\"\n                        }, void 0, false, {\n                            fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/pages/index.tsx\",\n                            lineNumber: 30,\n                            columnNumber: 9\n                        }, _this)\n                    }, void 0, false, {\n                        fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/pages/index.tsx\",\n                        lineNumber: 29,\n                        columnNumber: 7\n                    }, _this),\n                    name == \"\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"bg-white shadow rounded-lg\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"px-4 py-5 sm:p-6\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                    className: \"text-lg font-medium leading-6 text-gray-900\",\n                                    children: [\n                                        \"NATS \",\n                                        eventName,\n                                        \" Demo\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/pages/index.tsx\",\n                                    lineNumber: 36,\n                                    columnNumber: 13\n                                }, _this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"mt-2 max-w-xl text-sm text-gray-500\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        children: \"\\uD83C\\uDF89 To kick off the demo, let's start with your name\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/pages/index.tsx\",\n                                        lineNumber: 38,\n                                        columnNumber: 15\n                                    }, _this)\n                                }, void 0, false, {\n                                    fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/pages/index.tsx\",\n                                    lineNumber: 37,\n                                    columnNumber: 13\n                                }, _this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"form\", {\n                                    className: \"mt-5 sm:flex sm:items-center\",\n                                    onSubmit: function() {\n                                        return setName(text);\n                                    },\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"w-full sm:max-w-xs\",\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                                    htmlFor: \"email\",\n                                                    className: \"sr-only\",\n                                                    children: \"Name\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/pages/index.tsx\",\n                                                    lineNumber: 42,\n                                                    columnNumber: 17\n                                                }, _this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                    type: \"text\",\n                                                    name: \"name\",\n                                                    id: \"email\",\n                                                    className: \"block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm\",\n                                                    placeholder: \"My Name\",\n                                                    onChange: function(e) {\n                                                        return setText(e.target.value);\n                                                    }\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/pages/index.tsx\",\n                                                    lineNumber: 45,\n                                                    columnNumber: 17\n                                                }, _this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/pages/index.tsx\",\n                                            lineNumber: 41,\n                                            columnNumber: 15\n                                        }, _this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                            type: \"submit\",\n                                            className: \"mt-3 inline-flex w-full items-center justify-center rounded-md border border-transparent bg-indigo-600 px-4 py-2 font-medium text-white shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 sm:mt-0 sm:ml-3 sm:w-auto sm:text-sm\",\n                                            children: \"Save\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/pages/index.tsx\",\n                                            lineNumber: 54,\n                                            columnNumber: 15\n                                        }, _this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/pages/index.tsx\",\n                                    lineNumber: 40,\n                                    columnNumber: 13\n                                }, _this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/pages/index.tsx\",\n                            lineNumber: 35,\n                            columnNumber: 11\n                        }, _this)\n                    }, void 0, false, {\n                        fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/pages/index.tsx\",\n                        lineNumber: 34,\n                        columnNumber: 9\n                    }, _this),\n                    name != \"\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_demo__WEBPACK_IMPORTED_MODULE_3__.Demo, {\n                        name: name,\n                        server: server,\n                        eventName: eventName\n                    }, void 0, false, {\n                        fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/pages/index.tsx\",\n                        lineNumber: 68,\n                        columnNumber: 9\n                    }, _this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/dgee/Documents/Rethink/kubecon22/demo/pages/index.tsx\",\n                lineNumber: 28,\n                columnNumber: 5\n            }, _this)\n        ]\n    }, void 0, true);\n};\n_s(Home, \"mY2RsrqoWTLo+cwG97RGukVGK4Q=\");\n_c = Home;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Home);\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9pbmRleC50c3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7O0FBQzRCO0FBQ2U7QUFDRjtBQUV6QyxJQUFNSSxNQUFNLEdBQUdDLHlCQUF1QyxJQUFJLENBQXVCO0FBQ2pGLElBQU1HLFNBQVMsR0FBR0gsYUFBa0MsSUFBSSxDQUFVO0FBRWxFLElBQU1LLElBQUksR0FBYSxXQUFNOztJQUMzQixJQUF3QlIsR0FBWSxHQUFaQSwrQ0FBUSxDQUFDLEVBQUUsQ0FBQyxFQUE3QlMsSUFBSSxHQUFhVCxHQUFZLEdBQXpCLEVBQUVVLE9BQU8sR0FBSVYsR0FBWSxHQUFoQjtJQUNwQixJQUF3QkEsSUFBWSxHQUFaQSwrQ0FBUSxDQUFDLEVBQUUsQ0FBQyxFQUE3QlcsSUFBSSxHQUFhWCxJQUFZLEdBQXpCLEVBQUVZLE9BQU8sR0FBSVosSUFBWSxHQUFoQjtJQUVwQkQsZ0RBQVMsQ0FBQyxXQUFNO1FBQ2QsSUFBTWMsQ0FBQyxHQUFHQyxZQUFZLENBQUNDLE9BQU8sQ0FBQyxNQUFNLENBQUM7UUFDdEMsSUFBSUYsQ0FBQyxJQUFJLElBQUksRUFBRTtZQUNiRCxPQUFPLENBQUNDLENBQUMsQ0FBQztRQUNaLENBQUM7SUFDSCxDQUFDLEVBQUUsRUFBRSxDQUFDO0lBRU4scUJBQ0U7OzBCQUNBLDhEQUFDRyxLQUFHO2dCQUFDQyxTQUFTLEVBQUMsOERBQThEOzBCQUMzRSw0RUFBQ0QsS0FBRztvQkFBQ0MsU0FBUyxFQUFDLFlBQVk7OEJBQ3pCLDRFQUFDQyxNQUFJO3dCQUFDRCxTQUFTLEVBQUMsV0FBVztrQ0FBQyxnQkFBYzs7Ozs7NkJBQU87Ozs7O3lCQUM3Qzs7Ozs7cUJBQ0Y7MEJBRU4sOERBQUNELEtBQUc7Z0JBQUNDLFNBQVMsRUFBQyxvRUFBb0U7O2tDQUNqRiw4REFBQ25CLGtEQUFJO2tDQUNILDRFQUFDcUIsTUFBSTs0QkFBQ0MsR0FBRyxFQUFDLFlBQVk7NEJBQUNDLElBQUksRUFBQyxpQ0FBaUM7Ozs7O2lDQUFHOzs7Ozs2QkFDM0Q7b0JBRU5WLElBQUksSUFBSSxFQUFFLGtCQUNULDhEQUFDSyxLQUFHO3dCQUFDQyxTQUFTLEVBQUMsNEJBQTRCO2tDQUN6Qyw0RUFBQ0QsS0FBRzs0QkFBQ0MsU0FBUyxFQUFDLGtCQUFrQjs7OENBQy9CLDhEQUFDSyxJQUFFO29DQUFDTCxTQUFTLEVBQUMsNkNBQTZDOzt3Q0FBQyxPQUFLO3dDQUFDWCxTQUFTO3dDQUFDLE9BQUs7Ozs7Ozt5Q0FBSzs4Q0FDdEYsOERBQUNVLEtBQUc7b0NBQUNDLFNBQVMsRUFBQyxxQ0FBcUM7OENBQ2xELDRFQUFDTSxHQUFDO2tEQUFDLCtEQUF1RDs7Ozs7NkNBQUk7Ozs7O3lDQUMxRDs4Q0FDTiw4REFBQ0MsTUFBSTtvQ0FBQ1AsU0FBUyxFQUFDLDhCQUE4QjtvQ0FBQ1EsUUFBUSxFQUFFOytDQUFNYixPQUFPLENBQUNILElBQUksQ0FBQztxQ0FBQTs7c0RBQzFFLDhEQUFDTyxLQUFHOzRDQUFDQyxTQUFTLEVBQUMsb0JBQW9COzs4REFDakMsOERBQUNTLE9BQUs7b0RBQUNDLE9BQU8sRUFBQyxPQUFPO29EQUFDVixTQUFTLEVBQUMsU0FBUzs4REFBQyxNQUUzQzs7Ozs7eURBQVE7OERBQ1IsOERBQUNXLE9BQUs7b0RBQ0pDLElBQUksRUFBQyxNQUFNO29EQUNYbEIsSUFBSSxFQUFDLE1BQU07b0RBQ1htQixFQUFFLEVBQUMsT0FBTztvREFDVmIsU0FBUyxFQUFDLDRHQUE0RztvREFDdEhjLFdBQVcsRUFBQyxTQUFTO29EQUNyQkMsUUFBUSxFQUFFLFNBQUNDLENBQUM7K0RBQUt2QixPQUFPLENBQUN1QixDQUFDLENBQUNDLE1BQU0sQ0FBQ0MsS0FBSyxDQUFDO3FEQUFBOzs7Ozt5REFDeEM7Ozs7OztpREFDRTtzREFDTiw4REFBQ0MsUUFBTTs0Q0FDTFAsSUFBSSxFQUFDLFFBQVE7NENBQ2JaLFNBQVMsRUFBQyxzUkFBc1I7c0RBQ2pTLE1BRUQ7Ozs7O2lEQUFTOzs7Ozs7eUNBQ0o7Ozs7OztpQ0FDSDs7Ozs7NkJBQ0Y7b0JBS1BOLElBQUksSUFBSSxFQUFFLGtCQUNULDhEQUFDVixrREFBSTt3QkFBQ1UsSUFBSSxFQUFFQSxJQUFJO3dCQUFFVCxNQUFNLEVBQUVBLE1BQU07d0JBQUVJLFNBQVMsRUFBRUEsU0FBUzs7Ozs7NkJBQUk7Ozs7OztxQkFFeEQ7O29CQUNILENBQ0o7QUFDSCxDQUFDO0dBaEVLRSxJQUFJO0FBQUpBLEtBQUFBLElBQUk7QUFrRVYsK0RBQWVBLElBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcGFnZXMvaW5kZXgudHN4PzA3ZmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBOZXh0UGFnZSB9IGZyb20gJ25leHQnXG5pbXBvcnQgSGVhZCBmcm9tICduZXh0L2hlYWQnXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBEZW1vIH0gZnJvbSAnLi4vY29tcG9uZW50cy9kZW1vJ1xuXG5jb25zdCBzZXJ2ZXIgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19OQVRTX1NFUlZFUl9VUkwgfHwgXCJuYXRzOi8vbG9jYWxob3N0OjQyMjJcIiBcbmNvbnN0IGV2ZW50TmFtZSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0VWRU5UX05BTUUgfHwgXCJteV9ldmVudFwiXG5cbmNvbnN0IEhvbWU6IE5leHRQYWdlID0gKCkgPT4ge1xuICBjb25zdCBbdGV4dCwgc2V0VGV4dF0gPSB1c2VTdGF0ZShcIlwiKVxuICBjb25zdCBbbmFtZSwgc2V0TmFtZV0gPSB1c2VTdGF0ZShcIlwiKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwibmFtZVwiKVxuICAgIGlmIChuICE9IG51bGwpIHtcbiAgICAgIHNldE5hbWUobilcbiAgICB9XG4gIH0sIFtdKVxuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtY2VudGVyIHAtMiB0ZXh0LXdoaXRlIGJnLXNsYXRlLTgwMCBmbGV4IGp1c3RpZnktYmV0d2VlblwiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGdhcC00XCI+XG4gICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZvbnQtYm9sZFwiPkt1YmVDb25FVSAyMDIzPC9zcGFuPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRhaW5lciBteC1hdXRvIGZsZXggZmxleC1jb2wgdy1zY3JlZW4gcHQtMTYganVzdGlmeS1jZW50ZXIgcHgtNFwiPlxuICAgICAgPEhlYWQ+XG4gICAgICAgIDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiBocmVmPVwiaHR0cHM6Ly9yc21zLm1lL2ludGVyL2ludGVyLmNzc1wiIC8+XG4gICAgICA8L0hlYWQ+XG5cbiAgICAgIHtuYW1lID09IFwiXCIgJiYgKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJnLXdoaXRlIHNoYWRvdyByb3VuZGVkLWxnXCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJweC00IHB5LTUgc206cC02XCI+XG4gICAgICAgICAgICA8aDMgY2xhc3NOYW1lPVwidGV4dC1sZyBmb250LW1lZGl1bSBsZWFkaW5nLTYgdGV4dC1ncmF5LTkwMFwiPk5BVFMge2V2ZW50TmFtZX0gRGVtbzwvaDM+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm10LTIgbWF4LXcteGwgdGV4dC1zbSB0ZXh0LWdyYXktNTAwXCI+XG4gICAgICAgICAgICAgIDxwPvCfjokgVG8ga2ljayBvZmYgdGhlIGRlbW8sIGxldCZhcG9zO3Mgc3RhcnQgd2l0aCB5b3VyIG5hbWU8L3A+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxmb3JtIGNsYXNzTmFtZT1cIm10LTUgc206ZmxleCBzbTppdGVtcy1jZW50ZXJcIiBvblN1Ym1pdD17KCkgPT4gc2V0TmFtZSh0ZXh0KX0+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIHNtOm1heC13LXhzXCI+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGh0bWxGb3I9XCJlbWFpbFwiIGNsYXNzTmFtZT1cInNyLW9ubHlcIj5cbiAgICAgICAgICAgICAgICAgIE5hbWVcbiAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICAgICAgbmFtZT1cIm5hbWVcIlxuICAgICAgICAgICAgICAgICAgaWQ9XCJlbWFpbFwiXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJibG9jayB3LWZ1bGwgcm91bmRlZC1tZCBib3JkZXItZ3JheS0zMDAgc2hhZG93LXNtIGZvY3VzOmJvcmRlci1pbmRpZ28tNTAwIGZvY3VzOnJpbmctaW5kaWdvLTUwMCBzbTp0ZXh0LXNtXCJcbiAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiTXkgTmFtZVwiXG4gICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldFRleHQoZS50YXJnZXQudmFsdWUpfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgdHlwZT1cInN1Ym1pdFwiXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibXQtMyBpbmxpbmUtZmxleCB3LWZ1bGwgaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHJvdW5kZWQtbWQgYm9yZGVyIGJvcmRlci10cmFuc3BhcmVudCBiZy1pbmRpZ28tNjAwIHB4LTQgcHktMiBmb250LW1lZGl1bSB0ZXh0LXdoaXRlIHNoYWRvdy1zbSBob3ZlcjpiZy1pbmRpZ28tNzAwIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTIgZm9jdXM6cmluZy1pbmRpZ28tNTAwIGZvY3VzOnJpbmctb2Zmc2V0LTIgc206bXQtMCBzbTptbC0zIHNtOnctYXV0byBzbTp0ZXh0LXNtXCJcbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIFNhdmVcbiAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8L2Zvcm0+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgIFxuXG4gICAgICApfVxuXG4gICAgICB7bmFtZSAhPSBcIlwiICYmIChcbiAgICAgICAgPERlbW8gbmFtZT17bmFtZX0gc2VydmVyPXtzZXJ2ZXJ9IGV2ZW50TmFtZT17ZXZlbnROYW1lfSAvPlxuICAgICAgKX1cbiAgICA8L2Rpdj5cbiAgICA8Lz5cbiAgKVxufVxuXG5leHBvcnQgZGVmYXVsdCBIb21lXG4iXSwibmFtZXMiOlsiSGVhZCIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwiRGVtbyIsInNlcnZlciIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19OQVRTX1NFUlZFUl9VUkwiLCJldmVudE5hbWUiLCJORVhUX1BVQkxJQ19FVkVOVF9OQU1FIiwiSG9tZSIsInRleHQiLCJzZXRUZXh0IiwibmFtZSIsInNldE5hbWUiLCJuIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImRpdiIsImNsYXNzTmFtZSIsInNwYW4iLCJsaW5rIiwicmVsIiwiaHJlZiIsImgzIiwicCIsImZvcm0iLCJvblN1Ym1pdCIsImxhYmVsIiwiaHRtbEZvciIsImlucHV0IiwidHlwZSIsImlkIiwicGxhY2Vob2xkZXIiLCJvbkNoYW5nZSIsImUiLCJ0YXJnZXQiLCJ2YWx1ZSIsImJ1dHRvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./pages/index.tsx\n"));

/***/ }),

/***/ "./node_modules/next/dynamic.js":
/*!**************************************!*\
  !*** ./node_modules/next/dynamic.js ***!
  \**************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/shared/lib/dynamic */ \"./node_modules/next/dist/shared/lib/dynamic.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9keW5hbWljLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLHVIQUFxRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9keW5hbWljLmpzPzczZDQiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3Qvc2hhcmVkL2xpYi9keW5hbWljJylcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dynamic.js\n"));

/***/ }),

/***/ "./node_modules/next/head.js":
/*!***********************************!*\
  !*** ./node_modules/next/head.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/shared/lib/head */ \"./node_modules/next/dist/shared/lib/head.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlIQUFrRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzPzg4NDkiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3Qvc2hhcmVkL2xpYi9oZWFkJylcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/head.js\n"));

/***/ }),

/***/ "./node_modules/react-confetti/dist/react-confetti.min.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-confetti/dist/react-confetti.min.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("!function(t,e){ true?module.exports=e(__webpack_require__(/*! react */ \"./node_modules/react/index.js\")):0}(\"undefined\"!=typeof self?self:this,(function(t){return function(t){var e={};function n(r){if(e[r])return e[r].exports;var i=e[r]={i:r,l:!1,exports:{}};return t[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=t,n.c=e,n.d=function(t,e,r){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:r})},n.r=function(t){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&\"object\"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,\"default\",{enumerable:!0,value:t}),2&e&&\"string\"!=typeof t)for(var i in t)n.d(r,i,function(e){return t[e]}.bind(null,i));return r},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,\"a\",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p=\"\",n(n.s=2)}([function(e,n){e.exports=t},function(t,e,n){\"use strict\";var r={linear:function(t,e,n,r){return(n-e)*t/r+e},easeInQuad:function(t,e,n,r){return(n-e)*(t/=r)*t+e},easeOutQuad:function(t,e,n,r){return-(n-e)*(t/=r)*(t-2)+e},easeInOutQuad:function(t,e,n,r){var i=n-e;return(t/=r/2)<1?i/2*t*t+e:-i/2*(--t*(t-2)-1)+e},easeInCubic:function(t,e,n,r){return(n-e)*(t/=r)*t*t+e},easeOutCubic:function(t,e,n,r){return(n-e)*((t=t/r-1)*t*t+1)+e},easeInOutCubic:function(t,e,n,r){var i=n-e;return(t/=r/2)<1?i/2*t*t*t+e:i/2*((t-=2)*t*t+2)+e},easeInQuart:function(t,e,n,r){return(n-e)*(t/=r)*t*t*t+e},easeOutQuart:function(t,e,n,r){return-(n-e)*((t=t/r-1)*t*t*t-1)+e},easeInOutQuart:function(t,e,n,r){var i=n-e;return(t/=r/2)<1?i/2*t*t*t*t+e:-i/2*((t-=2)*t*t*t-2)+e},easeInQuint:function(t,e,n,r){return(n-e)*(t/=r)*t*t*t*t+e},easeOutQuint:function(t,e,n,r){return(n-e)*((t=t/r-1)*t*t*t*t+1)+e},easeInOutQuint:function(t,e,n,r){var i=n-e;return(t/=r/2)<1?i/2*t*t*t*t*t+e:i/2*((t-=2)*t*t*t*t+2)+e},easeInSine:function(t,e,n,r){var i=n-e;return-i*Math.cos(t/r*(Math.PI/2))+i+e},easeOutSine:function(t,e,n,r){return(n-e)*Math.sin(t/r*(Math.PI/2))+e},easeInOutSine:function(t,e,n,r){return-(n-e)/2*(Math.cos(Math.PI*t/r)-1)+e},easeInExpo:function(t,e,n,r){return 0==t?e:(n-e)*Math.pow(2,10*(t/r-1))+e},easeOutExpo:function(t,e,n,r){var i=n-e;return t==r?e+i:i*(1-Math.pow(2,-10*t/r))+e},easeInOutExpo:function(t,e,n,r){var i=n-e;return 0===t?e:t===r?e+i:(t/=r/2)<1?i/2*Math.pow(2,10*(t-1))+e:i/2*(2-Math.pow(2,-10*--t))+e},easeInCirc:function(t,e,n,r){return-(n-e)*(Math.sqrt(1-(t/=r)*t)-1)+e},easeOutCirc:function(t,e,n,r){return(n-e)*Math.sqrt(1-(t=t/r-1)*t)+e},easeInOutCirc:function(t,e,n,r){var i=n-e;return(t/=r/2)<1?-i/2*(Math.sqrt(1-t*t)-1)+e:i/2*(Math.sqrt(1-(t-=2)*t)+1)+e},easeInElastic:function(t,e,n,r){var i,o,a,c=n-e;return a=1.70158,0===t?e:1==(t/=r)?e+c:((o=0)||(o=.3*r),(i=c)<Math.abs(c)?(i=c,a=o/4):a=o/(2*Math.PI)*Math.asin(c/i),-i*Math.pow(2,10*(t-=1))*Math.sin((t*r-a)*(2*Math.PI)/o)+e)},easeOutElastic:function(t,e,n,r){var i,o,a,c=n-e;return a=1.70158,0===t?e:1==(t/=r)?e+c:((o=0)||(o=.3*r),(i=c)<Math.abs(c)?(i=c,a=o/4):a=o/(2*Math.PI)*Math.asin(c/i),i*Math.pow(2,-10*t)*Math.sin((t*r-a)*(2*Math.PI)/o)+c+e)},easeInOutElastic:function(t,e,n,r){var i,o,a,c=n-e;return a=1.70158,0===t?e:2==(t/=r/2)?e+c:((o=0)||(o=r*(.3*1.5)),(i=c)<Math.abs(c)?(i=c,a=o/4):a=o/(2*Math.PI)*Math.asin(c/i),t<1?i*Math.pow(2,10*(t-=1))*Math.sin((t*r-a)*(2*Math.PI)/o)*-.5+e:i*Math.pow(2,-10*(t-=1))*Math.sin((t*r-a)*(2*Math.PI)/o)*.5+c+e)},easeInBack:function(t,e,n,r,i){return void 0===i&&(i=1.70158),(n-e)*(t/=r)*t*((i+1)*t-i)+e},easeOutBack:function(t,e,n,r,i){return void 0===i&&(i=1.70158),(n-e)*((t=t/r-1)*t*((i+1)*t+i)+1)+e},easeInOutBack:function(t,e,n,r,i){var o=n-e;return void 0===i&&(i=1.70158),(t/=r/2)<1?o/2*(t*t*((1+(i*=1.525))*t-i))+e:o/2*((t-=2)*t*((1+(i*=1.525))*t+i)+2)+e},easeInBounce:function(t,e,n,i){var o=n-e;return o-r.easeOutBounce(i-t,0,o,i)+e},easeOutBounce:function(t,e,n,r){var i=n-e;return(t/=r)<1/2.75?i*(7.5625*t*t)+e:t<2/2.75?i*(7.5625*(t-=1.5/2.75)*t+.75)+e:t<2.5/2.75?i*(7.5625*(t-=2.25/2.75)*t+.9375)+e:i*(7.5625*(t-=2.625/2.75)*t+.984375)+e},easeInOutBounce:function(t,e,n,i){var o=n-e;return t<i/2?.5*r.easeInBounce(2*t,0,o,i)+e:.5*r.easeOutBounce(2*t-i,0,o,i)+.5*o+e}};t.exports=r},function(t,e,n){t.exports=n(3)},function(t,e,n){\"use strict\";n.r(e),n.d(e,\"ReactConfetti\",(function(){return Q}));var r,i,o=n(0),a=n.n(o),c=n(1),s=n.n(c);function u(t,e){return t+Math.random()*(e-t)}function f(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function h(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}!function(t){t[t.Circle=0]=\"Circle\",t[t.Square=1]=\"Square\",t[t.Strip=2]=\"Strip\"}(r||(r={})),function(t){t[t.Positive=1]=\"Positive\",t[t.Negative=-1]=\"Negative\"}(i||(i={}));var l=function(){function t(e,n,r,o){!function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this,t),h(this,\"context\",void 0),h(this,\"radius\",void 0),h(this,\"x\",void 0),h(this,\"y\",void 0),h(this,\"w\",void 0),h(this,\"h\",void 0),h(this,\"vx\",void 0),h(this,\"vy\",void 0),h(this,\"shape\",void 0),h(this,\"angle\",void 0),h(this,\"angularSpin\",void 0),h(this,\"color\",void 0),h(this,\"rotateY\",void 0),h(this,\"rotationDirection\",void 0),h(this,\"getOptions\",void 0),this.getOptions=n;var a,c,s=this.getOptions(),f=s.colors,l=s.initialVelocityX,p=s.initialVelocityY;this.context=e,this.x=r,this.y=o,this.w=u(5,20),this.h=u(5,20),this.radius=u(5,10),this.vx=\"number\"==typeof l?u(-l,l):u(l.min,l.max),this.vy=\"number\"==typeof p?u(-p,0):u(p.min,p.max),this.shape=(a=0,c=2,Math.floor(a+Math.random()*(c-a+1))),this.angle=u(0,360)*Math.PI/180,this.angularSpin=u(-.2,.2),this.color=f[Math.floor(Math.random()*f.length)],this.rotateY=u(0,1),this.rotationDirection=u(0,1)?i.Positive:i.Negative}var e,n,o;return e=t,(n=[{key:\"update\",value:function(){var t=this.getOptions(),e=t.gravity,n=t.wind,o=t.friction,a=t.opacity,c=t.drawShape;this.x+=this.vx,this.y+=this.vy,this.vy+=e,this.vx+=n,this.vx*=o,this.vy*=o,this.rotateY>=1&&this.rotationDirection===i.Positive?this.rotationDirection=i.Negative:this.rotateY<=-1&&this.rotationDirection===i.Negative&&(this.rotationDirection=i.Positive);var s=.1*this.rotationDirection;if(this.rotateY+=s,this.angle+=this.angularSpin,this.context.save(),this.context.translate(this.x,this.y),this.context.rotate(this.angle),this.context.scale(1,this.rotateY),this.context.rotate(this.angle),this.context.beginPath(),this.context.fillStyle=this.color,this.context.strokeStyle=this.color,this.context.globalAlpha=a,this.context.lineCap=\"round\",this.context.lineWidth=2,c&&\"function\"==typeof c)c.call(this,this.context);else switch(this.shape){case r.Circle:this.context.beginPath(),this.context.arc(0,0,this.radius,0,2*Math.PI),this.context.fill();break;case r.Square:this.context.fillRect(-this.w/2,-this.h/2,this.w,this.h);break;case r.Strip:this.context.fillRect(-this.w/6,-this.h/2,this.w/3,this.h)}this.context.closePath(),this.context.restore()}}])&&f(e.prototype,n),o&&f(e,o),t}();function p(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var v=function t(e,n){var r=this;!function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this,t),p(this,\"canvas\",void 0),p(this,\"context\",void 0),p(this,\"getOptions\",void 0),p(this,\"x\",0),p(this,\"y\",0),p(this,\"w\",0),p(this,\"h\",0),p(this,\"lastNumberOfPieces\",0),p(this,\"tweenInitTime\",Date.now()),p(this,\"particles\",[]),p(this,\"particlesGenerated\",0),p(this,\"removeParticleAt\",(function(t){r.particles.splice(t,1)})),p(this,\"getParticle\",(function(){var t=u(r.x,r.w+r.x),e=u(r.y,r.h+r.y);return new l(r.context,r.getOptions,t,e)})),p(this,\"animate\",(function(){var t=r.canvas,e=r.context,n=r.particlesGenerated,i=r.lastNumberOfPieces,o=r.getOptions(),a=o.run,c=o.recycle,s=o.numberOfPieces,u=o.debug,f=o.tweenFunction,h=o.tweenDuration;if(!a)return!1;var l=r.particles.length,p=c?l:n,v=Date.now();if(p<s){i!==s&&(r.tweenInitTime=v,r.lastNumberOfPieces=s);for(var y=r.tweenInitTime,d=f(v-y>h?h:Math.max(0,v-y),p,s,h),b=Math.round(d-p),g=0;g<b;g++)r.particles.push(r.getParticle());r.particlesGenerated+=b}return u&&(e.font=\"12px sans-serif\",e.fillStyle=\"#333\",e.textAlign=\"right\",e.fillText(\"Particles: \".concat(l),t.width-10,t.height-20)),r.particles.forEach((function(e,n){e.update(),(e.y>t.height||e.y<-100||e.x>t.width+100||e.x<-100)&&(c&&p<=s?r.particles[n]=r.getParticle():r.removeParticleAt(n))})),l>0||p<s})),this.canvas=e;var i=this.canvas.getContext(\"2d\");if(!i)throw new Error(\"Could not get canvas context\");this.context=i,this.getOptions=n};function y(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r)}return n}function d(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?y(Object(n),!0).forEach((function(e){g(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):y(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function b(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function g(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var O={width:\"undefined\"!=typeof window?window.innerWidth:300,height:\"undefined\"!=typeof window?window.innerHeight:200,numberOfPieces:200,friction:.99,wind:0,gravity:.1,initialVelocityX:4,initialVelocityY:10,colors:[\"#f44336\",\"#e91e63\",\"#9c27b0\",\"#673ab7\",\"#3f51b5\",\"#2196f3\",\"#03a9f4\",\"#00bcd4\",\"#009688\",\"#4CAF50\",\"#8BC34A\",\"#CDDC39\",\"#FFEB3B\",\"#FFC107\",\"#FF9800\",\"#FF5722\",\"#795548\"],opacity:1,debug:!1,tweenFunction:s.a.easeInOutQuad,tweenDuration:5e3,recycle:!0,run:!0},w=function(){function t(e,n){var r=this;!function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this,t),g(this,\"canvas\",void 0),g(this,\"context\",void 0),g(this,\"_options\",void 0),g(this,\"generator\",void 0),g(this,\"rafId\",void 0),g(this,\"setOptionsWithDefaults\",(function(t){var e={confettiSource:{x:0,y:0,w:r.canvas.width,h:0}};r._options=d(d(d({},e),O),t),Object.assign(r,t.confettiSource)})),g(this,\"update\",(function(){var t=r.options,e=t.run,n=t.onConfettiComplete,i=r.canvas,o=r.context;e&&(o.fillStyle=\"white\",o.clearRect(0,0,i.width,i.height)),r.generator.animate()?r.rafId=requestAnimationFrame(r.update):(n&&\"function\"==typeof n&&r.generator.particlesGenerated>0&&n.call(r,r),r._options.run=!1)})),g(this,\"reset\",(function(){r.generator&&r.generator.particlesGenerated>0&&(r.generator.particlesGenerated=0,r.generator.particles=[],r.generator.lastNumberOfPieces=0)})),g(this,\"stop\",(function(){r.options={run:!1},r.rafId&&(cancelAnimationFrame(r.rafId),r.rafId=void 0)})),this.canvas=e;var i=this.canvas.getContext(\"2d\");if(!i)throw new Error(\"Could not get canvas context\");this.context=i,this.generator=new v(this.canvas,(function(){return r.options})),this.options=n,this.update()}var e,n,r;return e=t,(n=[{key:\"options\",get:function(){return this._options},set:function(t){var e=this._options&&this._options.run,n=this._options&&this._options.recycle;this.setOptionsWithDefaults(t),this.generator&&(Object.assign(this.generator,this.options.confettiSource),\"boolean\"==typeof t.recycle&&t.recycle&&!1===n&&(this.generator.lastNumberOfPieces=this.generator.particles.length)),\"boolean\"==typeof t.run&&t.run&&!1===e&&this.update()}}])&&b(e.prototype,n),r&&b(e,r),t}();function m(t){return function(t){if(Array.isArray(t))return C(t)}(t)||function(t){if(\"undefined\"!=typeof Symbol&&Symbol.iterator in Object(t))return Array.from(t)}(t)||S(t)||function(){throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}()}function x(t){return(x=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function P(){return(P=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t}).apply(this,arguments)}function j(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r)}return n}function M(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?j(Object(n),!0).forEach((function(e){T(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):j(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function I(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){if(\"undefined\"==typeof Symbol||!(Symbol.iterator in Object(t)))return;var n=[],r=!0,i=!1,o=void 0;try{for(var a,c=t[Symbol.iterator]();!(r=(a=c.next()).done)&&(n.push(a.value),!e||n.length!==e);r=!0);}catch(t){i=!0,o=t}finally{try{r||null==c.return||c.return()}finally{if(i)throw o}}return n}(t,e)||S(t,e)||function(){throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}()}function S(t,e){if(t){if(\"string\"==typeof t)return C(t,e);var n=Object.prototype.toString.call(t).slice(8,-1);return\"Object\"===n&&t.constructor&&(n=t.constructor.name),\"Map\"===n||\"Set\"===n?Array.from(t):\"Arguments\"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?C(t,e):void 0}}function C(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,r=new Array(e);n<e;n++)r[n]=t[n];return r}function D(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function E(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function _(t,e){return(_=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function R(t){var e=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,r=F(t);if(e){var i=F(this).constructor;n=Reflect.construct(r,arguments,i)}else n=r.apply(this,arguments);return k(this,n)}}function k(t,e){return!e||\"object\"!==x(e)&&\"function\"!=typeof e?A(t):e}function A(t){if(void 0===t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return t}function F(t){return(F=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function T(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var B=a.a.createRef(),N=function(t){!function(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&_(t,e)}(o,t);var e,n,r,i=R(o);function o(t){var e;D(this,o);for(var n=arguments.length,r=new Array(n>1?n-1:0),c=1;c<n;c++)r[c-1]=arguments[c];return T(A(e=i.call.apply(i,[this,t].concat(r))),\"canvas\",a.a.createRef()),T(A(e),\"confetti\",void 0),e.canvas=t.canvasRef||B,e}return e=o,(n=[{key:\"componentDidMount\",value:function(){if(this.canvas.current){var t=q(this.props)[0];this.confetti=new w(this.canvas.current,t)}}},{key:\"componentDidUpdate\",value:function(){var t=q(this.props)[0];this.confetti&&(this.confetti.options=t)}},{key:\"componentWillUnmount\",value:function(){this.confetti&&this.confetti.stop(),this.confetti=void 0}},{key:\"render\",value:function(){var t=I(q(this.props),2),e=t[0],n=t[1],r=M({zIndex:2,position:\"absolute\",pointerEvents:\"none\",top:0,left:0,bottom:0,right:0},n.style);return a.a.createElement(\"canvas\",P({width:e.width,height:e.height,ref:this.canvas},n,{style:r}))}}])&&E(e.prototype,n),r&&E(e,r),o}(o.Component);function q(t){var e={},n={},r=[].concat(m(Object.keys(O)),[\"confettiSource\",\"drawShape\",\"onConfettiComplete\"]),i=[\"canvasRef\"];for(var o in t){var a=t[o];r.includes(o)?e[o]=a:i.includes(o)?i[o]=a:n[o]=a}return[e,n,{}]}T(N,\"defaultProps\",M({},O)),T(N,\"displayName\",\"ReactConfetti\");var Q=a.a.forwardRef((function(t,e){return a.a.createElement(N,P({canvasRef:e},t))}));e.default=Q}]).default}));\n//# sourceMappingURL=react-confetti.min.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtY29uZmV0dGkvZGlzdC9yZWFjdC1jb25mZXR0aS5taW4uanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsZUFBZSxLQUFpRCxrQkFBa0IsbUJBQU8sQ0FBQyw0Q0FBTyxHQUFHLENBQXVKLENBQUMsaURBQWlELG1CQUFtQixTQUFTLGNBQWMsNEJBQTRCLFlBQVkscUJBQXFCLDJEQUEyRCx1Q0FBdUMscUNBQXFDLG9CQUFvQixFQUFFLGlCQUFpQiw0RkFBNEYsZUFBZSx3Q0FBd0MsU0FBUyxFQUFFLG1CQUFtQiw4QkFBOEIscURBQXFELDBCQUEwQiw2Q0FBNkMsc0JBQXNCLDZEQUE2RCxZQUFZLGVBQWUsU0FBUyxpQkFBaUIsaUNBQWlDLGlCQUFpQixZQUFZLFVBQVUsc0JBQXNCLG1CQUFtQixpREFBaUQsaUJBQWlCLGdCQUFnQixZQUFZLGlCQUFpQixhQUFhLE9BQU8seUJBQXlCLGtCQUFrQiw4QkFBOEIsdUJBQXVCLCtCQUErQiw0QkFBNEIsaUNBQWlDLFVBQVUsZ0RBQWdELCtCQUErQix5QkFBeUIsZ0NBQWdDLGdDQUFnQyxrQ0FBa0MsVUFBVSxrREFBa0QsK0JBQStCLDJCQUEyQixnQ0FBZ0MsbUNBQW1DLGtDQUFrQyxVQUFVLHVEQUF1RCwrQkFBK0IsNkJBQTZCLGdDQUFnQyxvQ0FBb0Msa0NBQWtDLFVBQVUsMERBQTBELDhCQUE4QixVQUFVLHVDQUF1QywrQkFBK0Isd0NBQXdDLGlDQUFpQywyQ0FBMkMsOEJBQThCLDZDQUE2QywrQkFBK0IsVUFBVSw0Q0FBNEMsaUNBQWlDLFVBQVUsNkZBQTZGLDhCQUE4Qix5Q0FBeUMsK0JBQStCLHVDQUF1QyxpQ0FBaUMsVUFBVSw2RUFBNkUsaUNBQWlDLGdCQUFnQixpTEFBaUwsa0NBQWtDLGdCQUFnQiw4S0FBOEssb0NBQW9DLGdCQUFnQixnUUFBZ1EsZ0NBQWdDLDREQUE0RCxpQ0FBaUMsbUVBQW1FLG1DQUFtQyxVQUFVLG1IQUFtSCxnQ0FBZ0MsVUFBVSxzQ0FBc0MsaUNBQWlDLFVB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Qix1QkFBdUIsNkNBQTZDLEVBQUUsMENBQTBDLHVCQUF1QiwwQ0FBMEMsRUFBRSw0Q0FBNEMsMERBQTBELEVBQUUsOEJBQThCLDRDQUE0QyxnRkFBZ0YsVUFBVSxxQ0FBcUMsOENBQThDLElBQUksUUFBUSxJQUFJLGlDQUFpQyxjQUFjLGNBQWMsUUFBUSxLQUFLLG9HQUFvRyxnQkFBZ0IsV0FBVyxpREFBaUQsYUFBYSxFQUFFLHVCQUF1Qix3Q0FBd0Msb0NBQW9DLDhCQUE4QixZQUFZLEtBQUssR0FBRyxZQUFZLFdBQVc7QUFDMXloQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtY29uZmV0dGkvZGlzdC9yZWFjdC1jb25mZXR0aS5taW4uanM/MjVjZCJdLCJzb3VyY2VzQ29udGVudCI6WyIhZnVuY3Rpb24odCxlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1lKHJlcXVpcmUoXCJyZWFjdFwiKSk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJyZWFjdFwiXSxlKTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLlJlYWN0Q29uZmV0dGk9ZShyZXF1aXJlKFwicmVhY3RcIikpOnQuUmVhY3RDb25mZXR0aT1lKHQuUmVhY3QpfShcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOnRoaXMsKGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbih0KXt2YXIgZT17fTtmdW5jdGlvbiBuKHIpe2lmKGVbcl0pcmV0dXJuIGVbcl0uZXhwb3J0czt2YXIgaT1lW3JdPXtpOnIsbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gdFtyXS5jYWxsKGkuZXhwb3J0cyxpLGkuZXhwb3J0cyxuKSxpLmw9ITAsaS5leHBvcnRzfXJldHVybiBuLm09dCxuLmM9ZSxuLmQ9ZnVuY3Rpb24odCxlLHIpe24ubyh0LGUpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHtlbnVtZXJhYmxlOiEwLGdldDpyfSl9LG4ucj1mdW5jdGlvbih0KXtcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSxuLnQ9ZnVuY3Rpb24odCxlKXtpZigxJmUmJih0PW4odCkpLDgmZSlyZXR1cm4gdDtpZig0JmUmJlwib2JqZWN0XCI9PXR5cGVvZiB0JiZ0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7dmFyIHI9T2JqZWN0LmNyZWF0ZShudWxsKTtpZihuLnIociksT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6dH0pLDImZSYmXCJzdHJpbmdcIiE9dHlwZW9mIHQpZm9yKHZhciBpIGluIHQpbi5kKHIsaSxmdW5jdGlvbihlKXtyZXR1cm4gdFtlXX0uYmluZChudWxsLGkpKTtyZXR1cm4gcn0sbi5uPWZ1bmN0aW9uKHQpe3ZhciBlPXQmJnQuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiB0LmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIHR9O3JldHVybiBuLmQoZSxcImFcIixlKSxlfSxuLm89ZnVuY3Rpb24odCxlKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZSl9LG4ucD1cIlwiLG4obi5zPTIpfShbZnVuY3Rpb24oZSxuKXtlLmV4cG9ydHM9dH0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPXtsaW5lYXI6ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuKG4tZSkqdC9yK2V9LGVhc2VJblF1YWQ6ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuKG4tZSkqKHQvPXIpKnQrZX0sZWFzZU91dFF1YWQ6ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuLShuLWUpKih0Lz1yKSoodC0yKStlfSxlYXNlSW5PdXRRdWFkOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBpPW4tZTtyZXR1cm4odC89ci8yKTwxP2kvMip0KnQrZTotaS8yKigtLXQqKHQtMiktMSkrZX0sZWFzZUluQ3ViaWM6ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuKG4tZSkqKHQvPXIpKnQqdCtlfSxlYXNlT3V0Q3ViaWM6ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuKG4tZSkqKCh0PXQvci0xKSp0KnQrMSkrZX0sZWFzZUluT3V0Q3ViaWM6ZnVuY3Rpb24odCxlLG4scil7dmFyIGk9bi1lO3JldHVybih0Lz1yLzIpPDE/aS8yKnQqdCp0K2U6aS8yKigodC09MikqdCp0KzIpK2V9LGVhc2VJblF1YXJ0OmZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybihuLWUpKih0Lz1yKSp0KnQqdCtlfSxlYXNlT3V0UXVhcnQ6ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuLShuLWUpKigodD10L3ItMSkqdCp0KnQtMSkrZX0sZWFzZUluT3V0UXVhcnQ6ZnVuY3Rpb24odCxlLG4scil7dmFyIGk9bi1lO3JldHVybih0Lz1yLzIpPDE/aS8yKnQqdCp0KnQrZTotaS8yKigodC09MikqdCp0KnQtMikrZX0sZWFzZUluUXVpbnQ6ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuKG4tZSkqKHQvPXIpKnQqdCp0KnQrZX0sZWFzZU91dFF1aW50OmZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybihuLWUpKigodD10L3ItMSkqdCp0KnQqdCsxKStlfSxlYXNlSW5PdXRRdWludDpmdW5jdGlvbih0LGUsbixyKXt2YXIgaT1uLWU7cmV0dXJuKHQvPXIvMik8MT9pLzIqdCp0KnQqdCp0K2U6aS8yKigodC09MikqdCp0KnQqdCsyKStlfSxlYXNlSW5TaW5lOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBpPW4tZTtyZXR1cm4taSpNYXRoLmNvcyh0L3IqKE1hdGguUEkvMikpK2krZX0sZWFzZU91dFNpbmU6ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuKG4tZSkqTWF0aC5zaW4odC9yKihNYXRoLlBJLzIpKStlfSxlYXNlSW5PdXRTaW5lOmZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybi0obi1lKS8yKihNYXRoLmNvcyhNYXRoLlBJKnQvciktMSkrZX0sZWFzZUluRXhwbzpmdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gMD09dD9lOihuLWUpKk1hdGgucG93KDIsMTAqKHQvci0xKSkrZX0sZWFzZU91dEV4cG86ZnVuY3Rpb24odCxlLG4scil7dmFyIGk9bi1lO3JldHVybiB0PT1yP2UraTppKigxLU1hdGgucG93KDIsLTEwKnQvcikpK2V9LGVhc2VJbk91dEV4cG86ZnVuY3Rpb24odCxlLG4scil7dmFyIGk9bi1lO3JldHVybiAwPT09dD9lOnQ9PT1yP2UraToodC89ci8yKTwxP2kvMipNYXRoLnBvdygyLDEwKih0LTEpKStlOmkvMiooMi1NYXRoLnBvdygyLC0xMCotLXQpKStlfSxlYXNlSW5DaXJjOmZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybi0obi1lKSooTWF0aC5zcXJ0KDEtKHQvPXIpKnQpLTEpK2V9LGVhc2VPdXRDaXJjOmZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybihuLWUpKk1hdGguc3FydCgxLSh0PXQvci0xKSp0KStlfSxlYXNlSW5PdXRDaXJjOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBpPW4tZTtyZXR1cm4odC89ci8yKTwxPy1pLzIqKE1hdGguc3FydCgxLXQqdCktMSkrZTppLzIqKE1hdGguc3FydCgxLSh0LT0yKSp0KSsxKStlfSxlYXNlSW5FbGFzdGljOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBpLG8sYSxjPW4tZTtyZXR1cm4gYT0xLjcwMTU4LDA9PT10P2U6MT09KHQvPXIpP2UrYzooKG89MCl8fChvPS4zKnIpLChpPWMpPE1hdGguYWJzKGMpPyhpPWMsYT1vLzQpOmE9by8oMipNYXRoLlBJKSpNYXRoLmFzaW4oYy9pKSwtaSpNYXRoLnBvdygyLDEwKih0LT0xKSkqTWF0aC5zaW4oKHQqci1hKSooMipNYXRoLlBJKS9vKStlKX0sZWFzZU91dEVsYXN0aWM6ZnVuY3Rpb24odCxlLG4scil7dmFyIGksbyxhLGM9bi1lO3JldHVybiBhPTEuNzAxNTgsMD09PXQ/ZToxPT0odC89cik/ZStjOigobz0wKXx8KG89LjMqciksKGk9Yyk8TWF0aC5hYnMoYyk/KGk9YyxhPW8vNCk6YT1vLygyKk1hdGguUEkpKk1hdGguYXNpbihjL2kpLGkqTWF0aC5wb3coMiwtMTAqdCkqTWF0aC5zaW4oKHQqci1hKSooMipNYXRoLlBJKS9vKStjK2UpfSxlYXNlSW5PdXRFbGFzdGljOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBpLG8sYSxjPW4tZTtyZXR1cm4gYT0xLjcwMTU4LDA9PT10P2U6Mj09KHQvPXIvMik/ZStjOigobz0wKXx8KG89ciooLjMqMS41KSksKGk9Yyk8TWF0aC5hYnMoYyk/KGk9YyxhPW8vNCk6YT1vLygyKk1hdGguUEkpKk1hdGguYXNpbihjL2kpLHQ8MT9pKk1hdGgucG93KDIsMTAqKHQtPTEpKSpNYXRoLnNpbigodCpyLWEpKigyKk1hdGguUEkpL28pKi0uNStlOmkqTWF0aC5wb3coMiwtMTAqKHQtPTEpKSpNYXRoLnNpbigodCpyLWEpKigyKk1hdGguUEkpL28pKi41K2MrZSl9LGVhc2VJbkJhY2s6ZnVuY3Rpb24odCxlLG4scixpKXtyZXR1cm4gdm9pZCAwPT09aSYmKGk9MS43MDE1OCksKG4tZSkqKHQvPXIpKnQqKChpKzEpKnQtaSkrZX0sZWFzZU91dEJhY2s6ZnVuY3Rpb24odCxlLG4scixpKXtyZXR1cm4gdm9pZCAwPT09aSYmKGk9MS43MDE1OCksKG4tZSkqKCh0PXQvci0xKSp0KigoaSsxKSp0K2kpKzEpK2V9LGVhc2VJbk91dEJhY2s6ZnVuY3Rpb24odCxlLG4scixpKXt2YXIgbz1uLWU7cmV0dXJuIHZvaWQgMD09PWkmJihpPTEuNzAxNTgpLCh0Lz1yLzIpPDE/by8yKih0KnQqKCgxKyhpKj0xLjUyNSkpKnQtaSkpK2U6by8yKigodC09MikqdCooKDErKGkqPTEuNTI1KSkqdCtpKSsyKStlfSxlYXNlSW5Cb3VuY2U6ZnVuY3Rpb24odCxlLG4saSl7dmFyIG89bi1lO3JldHVybiBvLXIuZWFzZU91dEJvdW5jZShpLXQsMCxvLGkpK2V9LGVhc2VPdXRCb3VuY2U6ZnVuY3Rpb24odCxlLG4scil7dmFyIGk9bi1lO3JldHVybih0Lz1yKTwxLzIuNzU/aSooNy41NjI1KnQqdCkrZTp0PDIvMi43NT9pKig3LjU2MjUqKHQtPTEuNS8yLjc1KSp0Ky43NSkrZTp0PDIuNS8yLjc1P2kqKDcuNTYyNSoodC09Mi4yNS8yLjc1KSp0Ky45Mzc1KStlOmkqKDcuNTYyNSoodC09Mi42MjUvMi43NSkqdCsuOTg0Mzc1KStlfSxlYXNlSW5PdXRCb3VuY2U6ZnVuY3Rpb24odCxlLG4saSl7dmFyIG89bi1lO3JldHVybiB0PGkvMj8uNSpyLmVhc2VJbkJvdW5jZSgyKnQsMCxvLGkpK2U6LjUqci5lYXNlT3V0Qm91bmNlKDIqdC1pLDAsbyxpKSsuNSpvK2V9fTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe3QuZXhwb3J0cz1uKDMpfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7bi5yKGUpLG4uZChlLFwiUmVhY3RDb25mZXR0aVwiLChmdW5jdGlvbigpe3JldHVybiBRfSkpO3ZhciByLGksbz1uKDApLGE9bi5uKG8pLGM9bigxKSxzPW4ubihjKTtmdW5jdGlvbiB1KHQsZSl7cmV0dXJuIHQrTWF0aC5yYW5kb20oKSooZS10KX1mdW5jdGlvbiBmKHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1mdW5jdGlvbiBoKHQsZSxuKXtyZXR1cm4gZSBpbiB0P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse3ZhbHVlOm4sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp0W2VdPW4sdH0hZnVuY3Rpb24odCl7dFt0LkNpcmNsZT0wXT1cIkNpcmNsZVwiLHRbdC5TcXVhcmU9MV09XCJTcXVhcmVcIix0W3QuU3RyaXA9Ml09XCJTdHJpcFwifShyfHwocj17fSkpLGZ1bmN0aW9uKHQpe3RbdC5Qb3NpdGl2ZT0xXT1cIlBvc2l0aXZlXCIsdFt0Lk5lZ2F0aXZlPS0xXT1cIk5lZ2F0aXZlXCJ9KGl8fChpPXt9KSk7dmFyIGw9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUsbixyLG8peyFmdW5jdGlvbih0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsdCksaCh0aGlzLFwiY29udGV4dFwiLHZvaWQgMCksaCh0aGlzLFwicmFkaXVzXCIsdm9pZCAwKSxoKHRoaXMsXCJ4XCIsdm9pZCAwKSxoKHRoaXMsXCJ5XCIsdm9pZCAwKSxoKHRoaXMsXCJ3XCIsdm9pZCAwKSxoKHRoaXMsXCJoXCIsdm9pZCAwKSxoKHRoaXMsXCJ2eFwiLHZvaWQgMCksaCh0aGlzLFwidnlcIix2b2lkIDApLGgodGhpcyxcInNoYXBlXCIsdm9pZCAwKSxoKHRoaXMsXCJhbmdsZVwiLHZvaWQgMCksaCh0aGlzLFwiYW5ndWxhclNwaW5cIix2b2lkIDApLGgodGhpcyxcImNvbG9yXCIsdm9pZCAwKSxoKHRoaXMsXCJyb3RhdGVZXCIsdm9pZCAwKSxoKHRoaXMsXCJyb3RhdGlvbkRpcmVjdGlvblwiLHZvaWQgMCksaCh0aGlzLFwiZ2V0T3B0aW9uc1wiLHZvaWQgMCksdGhpcy5nZXRPcHRpb25zPW47dmFyIGEsYyxzPXRoaXMuZ2V0T3B0aW9ucygpLGY9cy5jb2xvcnMsbD1zLmluaXRpYWxWZWxvY2l0eVgscD1zLmluaXRpYWxWZWxvY2l0eVk7dGhpcy5jb250ZXh0PWUsdGhpcy54PXIsdGhpcy55PW8sdGhpcy53PXUoNSwyMCksdGhpcy5oPXUoNSwyMCksdGhpcy5yYWRpdXM9dSg1LDEwKSx0aGlzLnZ4PVwibnVtYmVyXCI9PXR5cGVvZiBsP3UoLWwsbCk6dShsLm1pbixsLm1heCksdGhpcy52eT1cIm51bWJlclwiPT10eXBlb2YgcD91KC1wLDApOnUocC5taW4scC5tYXgpLHRoaXMuc2hhcGU9KGE9MCxjPTIsTWF0aC5mbG9vcihhK01hdGgucmFuZG9tKCkqKGMtYSsxKSkpLHRoaXMuYW5nbGU9dSgwLDM2MCkqTWF0aC5QSS8xODAsdGhpcy5hbmd1bGFyU3Bpbj11KC0uMiwuMiksdGhpcy5jb2xvcj1mW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSpmLmxlbmd0aCldLHRoaXMucm90YXRlWT11KDAsMSksdGhpcy5yb3RhdGlvbkRpcmVjdGlvbj11KDAsMSk/aS5Qb3NpdGl2ZTppLk5lZ2F0aXZlfXZhciBlLG4sbztyZXR1cm4gZT10LChuPVt7a2V5OlwidXBkYXRlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmdldE9wdGlvbnMoKSxlPXQuZ3Jhdml0eSxuPXQud2luZCxvPXQuZnJpY3Rpb24sYT10Lm9wYWNpdHksYz10LmRyYXdTaGFwZTt0aGlzLngrPXRoaXMudngsdGhpcy55Kz10aGlzLnZ5LHRoaXMudnkrPWUsdGhpcy52eCs9bix0aGlzLnZ4Kj1vLHRoaXMudnkqPW8sdGhpcy5yb3RhdGVZPj0xJiZ0aGlzLnJvdGF0aW9uRGlyZWN0aW9uPT09aS5Qb3NpdGl2ZT90aGlzLnJvdGF0aW9uRGlyZWN0aW9uPWkuTmVnYXRpdmU6dGhpcy5yb3RhdGVZPD0tMSYmdGhpcy5yb3RhdGlvbkRpcmVjdGlvbj09PWkuTmVnYXRpdmUmJih0aGlzLnJvdGF0aW9uRGlyZWN0aW9uPWkuUG9zaXRpdmUpO3ZhciBzPS4xKnRoaXMucm90YXRpb25EaXJlY3Rpb247aWYodGhpcy5yb3RhdGVZKz1zLHRoaXMuYW5nbGUrPXRoaXMuYW5ndWxhclNwaW4sdGhpcy5jb250ZXh0LnNhdmUoKSx0aGlzLmNvbnRleHQudHJhbnNsYXRlKHRoaXMueCx0aGlzLnkpLHRoaXMuY29udGV4dC5yb3RhdGUodGhpcy5hbmdsZSksdGhpcy5jb250ZXh0LnNjYWxlKDEsdGhpcy5yb3RhdGVZKSx0aGlzLmNvbnRleHQucm90YXRlKHRoaXMuYW5nbGUpLHRoaXMuY29udGV4dC5iZWdpblBhdGgoKSx0aGlzLmNvbnRleHQuZmlsbFN0eWxlPXRoaXMuY29sb3IsdGhpcy5jb250ZXh0LnN0cm9rZVN0eWxlPXRoaXMuY29sb3IsdGhpcy5jb250ZXh0Lmdsb2JhbEFscGhhPWEsdGhpcy5jb250ZXh0LmxpbmVDYXA9XCJyb3VuZFwiLHRoaXMuY29udGV4dC5saW5lV2lkdGg9MixjJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBjKWMuY2FsbCh0aGlzLHRoaXMuY29udGV4dCk7ZWxzZSBzd2l0Y2godGhpcy5zaGFwZSl7Y2FzZSByLkNpcmNsZTp0aGlzLmNvbnRleHQuYmVnaW5QYXRoKCksdGhpcy5jb250ZXh0LmFyYygwLDAsdGhpcy5yYWRpdXMsMCwyKk1hdGguUEkpLHRoaXMuY29udGV4dC5maWxsKCk7YnJlYWs7Y2FzZSByLlNxdWFyZTp0aGlzLmNvbnRleHQuZmlsbFJlY3QoLXRoaXMudy8yLC10aGlzLmgvMix0aGlzLncsdGhpcy5oKTticmVhaztjYXNlIHIuU3RyaXA6dGhpcy5jb250ZXh0LmZpbGxSZWN0KC10aGlzLncvNiwtdGhpcy5oLzIsdGhpcy53LzMsdGhpcy5oKX10aGlzLmNvbnRleHQuY2xvc2VQYXRoKCksdGhpcy5jb250ZXh0LnJlc3RvcmUoKX19XSkmJmYoZS5wcm90b3R5cGUsbiksbyYmZihlLG8pLHR9KCk7ZnVuY3Rpb24gcCh0LGUsbil7cmV0dXJuIGUgaW4gdD9PYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6dFtlXT1uLHR9dmFyIHY9ZnVuY3Rpb24gdChlLG4pe3ZhciByPXRoaXM7IWZ1bmN0aW9uKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyx0KSxwKHRoaXMsXCJjYW52YXNcIix2b2lkIDApLHAodGhpcyxcImNvbnRleHRcIix2b2lkIDApLHAodGhpcyxcImdldE9wdGlvbnNcIix2b2lkIDApLHAodGhpcyxcInhcIiwwKSxwKHRoaXMsXCJ5XCIsMCkscCh0aGlzLFwid1wiLDApLHAodGhpcyxcImhcIiwwKSxwKHRoaXMsXCJsYXN0TnVtYmVyT2ZQaWVjZXNcIiwwKSxwKHRoaXMsXCJ0d2VlbkluaXRUaW1lXCIsRGF0ZS5ub3coKSkscCh0aGlzLFwicGFydGljbGVzXCIsW10pLHAodGhpcyxcInBhcnRpY2xlc0dlbmVyYXRlZFwiLDApLHAodGhpcyxcInJlbW92ZVBhcnRpY2xlQXRcIiwoZnVuY3Rpb24odCl7ci5wYXJ0aWNsZXMuc3BsaWNlKHQsMSl9KSkscCh0aGlzLFwiZ2V0UGFydGljbGVcIiwoZnVuY3Rpb24oKXt2YXIgdD11KHIueCxyLncrci54KSxlPXUoci55LHIuaCtyLnkpO3JldHVybiBuZXcgbChyLmNvbnRleHQsci5nZXRPcHRpb25zLHQsZSl9KSkscCh0aGlzLFwiYW5pbWF0ZVwiLChmdW5jdGlvbigpe3ZhciB0PXIuY2FudmFzLGU9ci5jb250ZXh0LG49ci5wYXJ0aWNsZXNHZW5lcmF0ZWQsaT1yLmxhc3ROdW1iZXJPZlBpZWNlcyxvPXIuZ2V0T3B0aW9ucygpLGE9by5ydW4sYz1vLnJlY3ljbGUscz1vLm51bWJlck9mUGllY2VzLHU9by5kZWJ1ZyxmPW8udHdlZW5GdW5jdGlvbixoPW8udHdlZW5EdXJhdGlvbjtpZighYSlyZXR1cm4hMTt2YXIgbD1yLnBhcnRpY2xlcy5sZW5ndGgscD1jP2w6bix2PURhdGUubm93KCk7aWYocDxzKXtpIT09cyYmKHIudHdlZW5Jbml0VGltZT12LHIubGFzdE51bWJlck9mUGllY2VzPXMpO2Zvcih2YXIgeT1yLnR3ZWVuSW5pdFRpbWUsZD1mKHYteT5oP2g6TWF0aC5tYXgoMCx2LXkpLHAscyxoKSxiPU1hdGgucm91bmQoZC1wKSxnPTA7ZzxiO2crKylyLnBhcnRpY2xlcy5wdXNoKHIuZ2V0UGFydGljbGUoKSk7ci5wYXJ0aWNsZXNHZW5lcmF0ZWQrPWJ9cmV0dXJuIHUmJihlLmZvbnQ9XCIxMnB4IHNhbnMtc2VyaWZcIixlLmZpbGxTdHlsZT1cIiMzMzNcIixlLnRleHRBbGlnbj1cInJpZ2h0XCIsZS5maWxsVGV4dChcIlBhcnRpY2xlczogXCIuY29uY2F0KGwpLHQud2lkdGgtMTAsdC5oZWlnaHQtMjApKSxyLnBhcnRpY2xlcy5mb3JFYWNoKChmdW5jdGlvbihlLG4pe2UudXBkYXRlKCksKGUueT50LmhlaWdodHx8ZS55PC0xMDB8fGUueD50LndpZHRoKzEwMHx8ZS54PC0xMDApJiYoYyYmcDw9cz9yLnBhcnRpY2xlc1tuXT1yLmdldFBhcnRpY2xlKCk6ci5yZW1vdmVQYXJ0aWNsZUF0KG4pKX0pKSxsPjB8fHA8c30pKSx0aGlzLmNhbnZhcz1lO3ZhciBpPXRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtpZighaSl0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZ2V0IGNhbnZhcyBjb250ZXh0XCIpO3RoaXMuY29udGV4dD1pLHRoaXMuZ2V0T3B0aW9ucz1ufTtmdW5jdGlvbiB5KHQsZSl7dmFyIG49T2JqZWN0LmtleXModCk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIHI9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0KTtlJiYocj1yLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxlKS5lbnVtZXJhYmxlfSkpKSxuLnB1c2guYXBwbHkobixyKX1yZXR1cm4gbn1mdW5jdGlvbiBkKHQpe2Zvcih2YXIgZT0xO2U8YXJndW1lbnRzLmxlbmd0aDtlKyspe3ZhciBuPW51bGwhPWFyZ3VtZW50c1tlXT9hcmd1bWVudHNbZV06e307ZSUyP3koT2JqZWN0KG4pLCEwKS5mb3JFYWNoKChmdW5jdGlvbihlKXtnKHQsZSxuW2VdKX0pKTpPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycz9PYmplY3QuZGVmaW5lUHJvcGVydGllcyh0LE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG4pKTp5KE9iamVjdChuKSkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sZSkpfSkpfXJldHVybiB0fWZ1bmN0aW9uIGIodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fWZ1bmN0aW9uIGcodCxlLG4pe3JldHVybiBlIGluIHQ/T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSx7dmFsdWU6bixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnRbZV09bix0fXZhciBPPXt3aWR0aDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdy5pbm5lcldpZHRoOjMwMCxoZWlnaHQ6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3cuaW5uZXJIZWlnaHQ6MjAwLG51bWJlck9mUGllY2VzOjIwMCxmcmljdGlvbjouOTksd2luZDowLGdyYXZpdHk6LjEsaW5pdGlhbFZlbG9jaXR5WDo0LGluaXRpYWxWZWxvY2l0eVk6MTAsY29sb3JzOltcIiNmNDQzMzZcIixcIiNlOTFlNjNcIixcIiM5YzI3YjBcIixcIiM2NzNhYjdcIixcIiMzZjUxYjVcIixcIiMyMTk2ZjNcIixcIiMwM2E5ZjRcIixcIiMwMGJjZDRcIixcIiMwMDk2ODhcIixcIiM0Q0FGNTBcIixcIiM4QkMzNEFcIixcIiNDRERDMzlcIixcIiNGRkVCM0JcIixcIiNGRkMxMDdcIixcIiNGRjk4MDBcIixcIiNGRjU3MjJcIixcIiM3OTU1NDhcIl0sb3BhY2l0eToxLGRlYnVnOiExLHR3ZWVuRnVuY3Rpb246cy5hLmVhc2VJbk91dFF1YWQsdHdlZW5EdXJhdGlvbjo1ZTMscmVjeWNsZTohMCxydW46ITB9LHc9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUsbil7dmFyIHI9dGhpczshZnVuY3Rpb24odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLHQpLGcodGhpcyxcImNhbnZhc1wiLHZvaWQgMCksZyh0aGlzLFwiY29udGV4dFwiLHZvaWQgMCksZyh0aGlzLFwiX29wdGlvbnNcIix2b2lkIDApLGcodGhpcyxcImdlbmVyYXRvclwiLHZvaWQgMCksZyh0aGlzLFwicmFmSWRcIix2b2lkIDApLGcodGhpcyxcInNldE9wdGlvbnNXaXRoRGVmYXVsdHNcIiwoZnVuY3Rpb24odCl7dmFyIGU9e2NvbmZldHRpU291cmNlOnt4OjAseTowLHc6ci5jYW52YXMud2lkdGgsaDowfX07ci5fb3B0aW9ucz1kKGQoZCh7fSxlKSxPKSx0KSxPYmplY3QuYXNzaWduKHIsdC5jb25mZXR0aVNvdXJjZSl9KSksZyh0aGlzLFwidXBkYXRlXCIsKGZ1bmN0aW9uKCl7dmFyIHQ9ci5vcHRpb25zLGU9dC5ydW4sbj10Lm9uQ29uZmV0dGlDb21wbGV0ZSxpPXIuY2FudmFzLG89ci5jb250ZXh0O2UmJihvLmZpbGxTdHlsZT1cIndoaXRlXCIsby5jbGVhclJlY3QoMCwwLGkud2lkdGgsaS5oZWlnaHQpKSxyLmdlbmVyYXRvci5hbmltYXRlKCk/ci5yYWZJZD1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoci51cGRhdGUpOihuJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBuJiZyLmdlbmVyYXRvci5wYXJ0aWNsZXNHZW5lcmF0ZWQ+MCYmbi5jYWxsKHIsciksci5fb3B0aW9ucy5ydW49ITEpfSkpLGcodGhpcyxcInJlc2V0XCIsKGZ1bmN0aW9uKCl7ci5nZW5lcmF0b3ImJnIuZ2VuZXJhdG9yLnBhcnRpY2xlc0dlbmVyYXRlZD4wJiYoci5nZW5lcmF0b3IucGFydGljbGVzR2VuZXJhdGVkPTAsci5nZW5lcmF0b3IucGFydGljbGVzPVtdLHIuZ2VuZXJhdG9yLmxhc3ROdW1iZXJPZlBpZWNlcz0wKX0pKSxnKHRoaXMsXCJzdG9wXCIsKGZ1bmN0aW9uKCl7ci5vcHRpb25zPXtydW46ITF9LHIucmFmSWQmJihjYW5jZWxBbmltYXRpb25GcmFtZShyLnJhZklkKSxyLnJhZklkPXZvaWQgMCl9KSksdGhpcy5jYW52YXM9ZTt2YXIgaT10aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7aWYoIWkpdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGdldCBjYW52YXMgY29udGV4dFwiKTt0aGlzLmNvbnRleHQ9aSx0aGlzLmdlbmVyYXRvcj1uZXcgdih0aGlzLmNhbnZhcywoZnVuY3Rpb24oKXtyZXR1cm4gci5vcHRpb25zfSkpLHRoaXMub3B0aW9ucz1uLHRoaXMudXBkYXRlKCl9dmFyIGUsbixyO3JldHVybiBlPXQsKG49W3trZXk6XCJvcHRpb25zXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX29wdGlvbnN9LHNldDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLl9vcHRpb25zJiZ0aGlzLl9vcHRpb25zLnJ1bixuPXRoaXMuX29wdGlvbnMmJnRoaXMuX29wdGlvbnMucmVjeWNsZTt0aGlzLnNldE9wdGlvbnNXaXRoRGVmYXVsdHModCksdGhpcy5nZW5lcmF0b3ImJihPYmplY3QuYXNzaWduKHRoaXMuZ2VuZXJhdG9yLHRoaXMub3B0aW9ucy5jb25mZXR0aVNvdXJjZSksXCJib29sZWFuXCI9PXR5cGVvZiB0LnJlY3ljbGUmJnQucmVjeWNsZSYmITE9PT1uJiYodGhpcy5nZW5lcmF0b3IubGFzdE51bWJlck9mUGllY2VzPXRoaXMuZ2VuZXJhdG9yLnBhcnRpY2xlcy5sZW5ndGgpKSxcImJvb2xlYW5cIj09dHlwZW9mIHQucnVuJiZ0LnJ1biYmITE9PT1lJiZ0aGlzLnVwZGF0ZSgpfX1dKSYmYihlLnByb3RvdHlwZSxuKSxyJiZiKGUsciksdH0oKTtmdW5jdGlvbiBtKHQpe3JldHVybiBmdW5jdGlvbih0KXtpZihBcnJheS5pc0FycmF5KHQpKXJldHVybiBDKHQpfSh0KXx8ZnVuY3Rpb24odCl7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdCh0KSlyZXR1cm4gQXJyYXkuZnJvbSh0KX0odCl8fFModCl8fGZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIil9KCl9ZnVuY3Rpb24geCh0KXtyZXR1cm4oeD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9ZnVuY3Rpb24gUCgpe3JldHVybihQPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0xO2U8YXJndW1lbnRzLmxlbmd0aDtlKyspe3ZhciBuPWFyZ3VtZW50c1tlXTtmb3IodmFyIHIgaW4gbilPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobixyKSYmKHRbcl09bltyXSl9cmV0dXJuIHR9KS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZnVuY3Rpb24gaih0LGUpe3ZhciBuPU9iamVjdC5rZXlzKHQpO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciByPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModCk7ZSYmKHI9ci5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsZSkuZW51bWVyYWJsZX0pKSksbi5wdXNoLmFwcGx5KG4scil9cmV0dXJuIG59ZnVuY3Rpb24gTSh0KXtmb3IodmFyIGU9MTtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXt2YXIgbj1udWxsIT1hcmd1bWVudHNbZV0/YXJndW1lbnRzW2VdOnt9O2UlMj9qKE9iamVjdChuKSwhMCkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7VCh0LGUsbltlXSl9KSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXModCxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhuKSk6aihPYmplY3QobikpLmZvckVhY2goKGZ1bmN0aW9uKGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLGUpKX0pKX1yZXR1cm4gdH1mdW5jdGlvbiBJKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKHQpe2lmKEFycmF5LmlzQXJyYXkodCkpcmV0dXJuIHR9KHQpfHxmdW5jdGlvbih0LGUpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBTeW1ib2x8fCEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdCh0KSkpcmV0dXJuO3ZhciBuPVtdLHI9ITAsaT0hMSxvPXZvaWQgMDt0cnl7Zm9yKHZhciBhLGM9dFtTeW1ib2wuaXRlcmF0b3JdKCk7IShyPShhPWMubmV4dCgpKS5kb25lKSYmKG4ucHVzaChhLnZhbHVlKSwhZXx8bi5sZW5ndGghPT1lKTtyPSEwKTt9Y2F0Y2godCl7aT0hMCxvPXR9ZmluYWxseXt0cnl7cnx8bnVsbD09Yy5yZXR1cm58fGMucmV0dXJuKCl9ZmluYWxseXtpZihpKXRocm93IG99fXJldHVybiBufSh0LGUpfHxTKHQsZSl8fGZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKX0oKX1mdW5jdGlvbiBTKHQsZSl7aWYodCl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpcmV0dXJuIEModCxlKTt2YXIgbj1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkuc2xpY2UoOCwtMSk7cmV0dXJuXCJPYmplY3RcIj09PW4mJnQuY29uc3RydWN0b3ImJihuPXQuY29uc3RydWN0b3IubmFtZSksXCJNYXBcIj09PW58fFwiU2V0XCI9PT1uP0FycmF5LmZyb20odCk6XCJBcmd1bWVudHNcIj09PW58fC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pP0ModCxlKTp2b2lkIDB9fWZ1bmN0aW9uIEModCxlKXsobnVsbD09ZXx8ZT50Lmxlbmd0aCkmJihlPXQubGVuZ3RoKTtmb3IodmFyIG49MCxyPW5ldyBBcnJheShlKTtuPGU7bisrKXJbbl09dFtuXTtyZXR1cm4gcn1mdW5jdGlvbiBEKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBFKHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1mdW5jdGlvbiBfKHQsZSl7cmV0dXJuKF89T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbih0LGUpe3JldHVybiB0Ll9fcHJvdG9fXz1lLHR9KSh0LGUpfWZ1bmN0aW9uIFIodCl7dmFyIGU9ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgUmVmbGVjdHx8IVJlZmxlY3QuY29uc3RydWN0KXJldHVybiExO2lmKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgUHJveHkpcmV0dXJuITA7dHJ5e3JldHVybiBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaCh0KXtyZXR1cm4hMX19KCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIG4scj1GKHQpO2lmKGUpe3ZhciBpPUYodGhpcykuY29uc3RydWN0b3I7bj1SZWZsZWN0LmNvbnN0cnVjdChyLGFyZ3VtZW50cyxpKX1lbHNlIG49ci5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIGsodGhpcyxuKX19ZnVuY3Rpb24gayh0LGUpe3JldHVybiFlfHxcIm9iamVjdFwiIT09eChlKSYmXCJmdW5jdGlvblwiIT10eXBlb2YgZT9BKHQpOmV9ZnVuY3Rpb24gQSh0KXtpZih2b2lkIDA9PT10KXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4gdH1mdW5jdGlvbiBGKHQpe3JldHVybihGPU9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3QuZ2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24odCl7cmV0dXJuIHQuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCl9KSh0KX1mdW5jdGlvbiBUKHQsZSxuKXtyZXR1cm4gZSBpbiB0P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse3ZhbHVlOm4sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp0W2VdPW4sdH12YXIgQj1hLmEuY3JlYXRlUmVmKCksTj1mdW5jdGlvbih0KXshZnVuY3Rpb24odCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGUmJl8odCxlKX0obyx0KTt2YXIgZSxuLHIsaT1SKG8pO2Z1bmN0aW9uIG8odCl7dmFyIGU7RCh0aGlzLG8pO2Zvcih2YXIgbj1hcmd1bWVudHMubGVuZ3RoLHI9bmV3IEFycmF5KG4+MT9uLTE6MCksYz0xO2M8bjtjKyspcltjLTFdPWFyZ3VtZW50c1tjXTtyZXR1cm4gVChBKGU9aS5jYWxsLmFwcGx5KGksW3RoaXMsdF0uY29uY2F0KHIpKSksXCJjYW52YXNcIixhLmEuY3JlYXRlUmVmKCkpLFQoQShlKSxcImNvbmZldHRpXCIsdm9pZCAwKSxlLmNhbnZhcz10LmNhbnZhc1JlZnx8QixlfXJldHVybiBlPW8sKG49W3trZXk6XCJjb21wb25lbnREaWRNb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYodGhpcy5jYW52YXMuY3VycmVudCl7dmFyIHQ9cSh0aGlzLnByb3BzKVswXTt0aGlzLmNvbmZldHRpPW5ldyB3KHRoaXMuY2FudmFzLmN1cnJlbnQsdCl9fX0se2tleTpcImNvbXBvbmVudERpZFVwZGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9cSh0aGlzLnByb3BzKVswXTt0aGlzLmNvbmZldHRpJiYodGhpcy5jb25mZXR0aS5vcHRpb25zPXQpfX0se2tleTpcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmNvbmZldHRpJiZ0aGlzLmNvbmZldHRpLnN0b3AoKSx0aGlzLmNvbmZldHRpPXZvaWQgMH19LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PUkocSh0aGlzLnByb3BzKSwyKSxlPXRbMF0sbj10WzFdLHI9TSh7ekluZGV4OjIscG9zaXRpb246XCJhYnNvbHV0ZVwiLHBvaW50ZXJFdmVudHM6XCJub25lXCIsdG9wOjAsbGVmdDowLGJvdHRvbTowLHJpZ2h0OjB9LG4uc3R5bGUpO3JldHVybiBhLmEuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiLFAoe3dpZHRoOmUud2lkdGgsaGVpZ2h0OmUuaGVpZ2h0LHJlZjp0aGlzLmNhbnZhc30sbix7c3R5bGU6cn0pKX19XSkmJkUoZS5wcm90b3R5cGUsbiksciYmRShlLHIpLG99KG8uQ29tcG9uZW50KTtmdW5jdGlvbiBxKHQpe3ZhciBlPXt9LG49e30scj1bXS5jb25jYXQobShPYmplY3Qua2V5cyhPKSksW1wiY29uZmV0dGlTb3VyY2VcIixcImRyYXdTaGFwZVwiLFwib25Db25mZXR0aUNvbXBsZXRlXCJdKSxpPVtcImNhbnZhc1JlZlwiXTtmb3IodmFyIG8gaW4gdCl7dmFyIGE9dFtvXTtyLmluY2x1ZGVzKG8pP2Vbb109YTppLmluY2x1ZGVzKG8pP2lbb109YTpuW29dPWF9cmV0dXJuW2Usbix7fV19VChOLFwiZGVmYXVsdFByb3BzXCIsTSh7fSxPKSksVChOLFwiZGlzcGxheU5hbWVcIixcIlJlYWN0Q29uZmV0dGlcIik7dmFyIFE9YS5hLmZvcndhcmRSZWYoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGEuYS5jcmVhdGVFbGVtZW50KE4sUCh7Y2FudmFzUmVmOmV9LHQpKX0pKTtlLmRlZmF1bHQ9UX1dKS5kZWZhdWx0fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3QtY29uZmV0dGkubWluLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-confetti/dist/react-confetti.min.js\n"));

/***/ }),

/***/ "./node_modules/@swc/helpers/src/_array_like_to_array.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@swc/helpers/src/_array_like_to_array.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _arrayLikeToArray; }\n/* harmony export */ });\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL3NyYy9fYXJyYXlfbGlrZV90b19hcnJheS5tanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlO0FBQ2Y7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac3djL2hlbHBlcnMvc3JjL19hcnJheV9saWtlX3RvX2FycmF5Lm1qcz9kMWExIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG4gIHJldHVybiBhcnIyO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@swc/helpers/src/_array_like_to_array.mjs\n"));

/***/ }),

/***/ "./node_modules/@swc/helpers/src/_array_without_holes.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@swc/helpers/src/_array_without_holes.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _arrayWithoutHoles; }\n/* harmony export */ });\n/* harmony import */ var _array_like_to_array_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_array_like_to_array.mjs */ \"./node_modules/@swc/helpers/src/_array_like_to_array.mjs\");\n\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return (0,_array_like_to_array_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(arr);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL3NyYy9fYXJyYXlfd2l0aG91dF9ob2xlcy5tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBMkQ7O0FBRTVDO0FBQ2YsaUNBQWlDLG9FQUFpQjtBQUNsRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL3NyYy9fYXJyYXlfd2l0aG91dF9ob2xlcy5tanM/Njc0YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2FycmF5TGlrZVRvQXJyYXkgZnJvbSAnLi9fYXJyYXlfbGlrZV90b19hcnJheS5tanMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@swc/helpers/src/_array_without_holes.mjs\n"));

/***/ }),

/***/ "./node_modules/@swc/helpers/src/_async_iterator.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@swc/helpers/src/_async_iterator.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _asyncIterator; }\n/* harmony export */ });\nfunction _asyncIterator(iterable) {\n  var method, async, sync, retry = 2;\n  for (\"undefined\" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) {\n    if (async && null != (method = iterable[async])) return method.call(iterable);\n    if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable));\n    async = \"@@asyncIterator\", sync = \"@@iterator\";\n  }\n  throw new TypeError(\"Object is not async iterable\");\n}\n\n\n\nfunction AsyncFromSyncIterator(s) {\n  function AsyncFromSyncIteratorContinuation(r) {\n    if (Object(r) !== r) return Promise.reject(new TypeError(r + \" is not an object.\"));\n    var done = r.done;\n    return Promise.resolve(r.value).then(function (value) {\n      return {\n        value: value,\n        done: done\n      };\n    });\n  }\n  return AsyncFromSyncIterator = function (s) {\n    this.s = s, this.n = s.next;\n  }, AsyncFromSyncIterator.prototype = {\n    s: null,\n    n: null,\n    next: function () {\n      return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));\n    },\n    return: function (value) {\n      var ret = this.s.return;\n      return void 0 === ret ? Promise.resolve({\n        value: value,\n        done: !0\n      }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments));\n    },\n    throw: function (value) {\n      var thr = this.s.return;\n      return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments));\n    }\n  }, new AsyncFromSyncIterator(s);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL3NyYy9fYXN5bmNfaXRlcmF0b3IubWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZTtBQUNmO0FBQ0EsK0ZBQStGLFFBQVE7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL3NyYy9fYXN5bmNfaXRlcmF0b3IubWpzP2E5YzYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2FzeW5jSXRlcmF0b3IoaXRlcmFibGUpIHtcbiAgdmFyIG1ldGhvZCwgYXN5bmMsIHN5bmMsIHJldHJ5ID0gMjtcbiAgZm9yIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgKGFzeW5jID0gU3ltYm9sLmFzeW5jSXRlcmF0b3IsIHN5bmMgPSBTeW1ib2wuaXRlcmF0b3IpOyByZXRyeS0tOykge1xuICAgIGlmIChhc3luYyAmJiBudWxsICE9IChtZXRob2QgPSBpdGVyYWJsZVthc3luY10pKSByZXR1cm4gbWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgIGlmIChzeW5jICYmIG51bGwgIT0gKG1ldGhvZCA9IGl0ZXJhYmxlW3N5bmNdKSkgcmV0dXJuIG5ldyBBc3luY0Zyb21TeW5jSXRlcmF0b3IobWV0aG9kLmNhbGwoaXRlcmFibGUpKTtcbiAgICBhc3luYyA9IFwiQEBhc3luY0l0ZXJhdG9yXCIsIHN5bmMgPSBcIkBAaXRlcmF0b3JcIjtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGlzIG5vdCBhc3luYyBpdGVyYWJsZVwiKTtcbn1cblxuXG5cbmZ1bmN0aW9uIEFzeW5jRnJvbVN5bmNJdGVyYXRvcihzKSB7XG4gIGZ1bmN0aW9uIEFzeW5jRnJvbVN5bmNJdGVyYXRvckNvbnRpbnVhdGlvbihyKSB7XG4gICAgaWYgKE9iamVjdChyKSAhPT0gcikgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IociArIFwiIGlzIG5vdCBhbiBvYmplY3QuXCIpKTtcbiAgICB2YXIgZG9uZSA9IHIuZG9uZTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGRvbmU6IGRvbmVcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIEFzeW5jRnJvbVN5bmNJdGVyYXRvciA9IGZ1bmN0aW9uIChzKSB7XG4gICAgdGhpcy5zID0gcywgdGhpcy5uID0gcy5uZXh0O1xuICB9LCBBc3luY0Zyb21TeW5jSXRlcmF0b3IucHJvdG90eXBlID0ge1xuICAgIHM6IG51bGwsXG4gICAgbjogbnVsbCxcbiAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gQXN5bmNGcm9tU3luY0l0ZXJhdG9yQ29udGludWF0aW9uKHRoaXMubi5hcHBseSh0aGlzLnMsIGFyZ3VtZW50cykpO1xuICAgIH0sXG4gICAgcmV0dXJuOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHZhciByZXQgPSB0aGlzLnMucmV0dXJuO1xuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gcmV0ID8gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBkb25lOiAhMFxuICAgICAgfSkgOiBBc3luY0Zyb21TeW5jSXRlcmF0b3JDb250aW51YXRpb24ocmV0LmFwcGx5KHRoaXMucywgYXJndW1lbnRzKSk7XG4gICAgfSxcbiAgICB0aHJvdzogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB2YXIgdGhyID0gdGhpcy5zLnJldHVybjtcbiAgICAgIHJldHVybiB2b2lkIDAgPT09IHRociA/IFByb21pc2UucmVqZWN0KHZhbHVlKSA6IEFzeW5jRnJvbVN5bmNJdGVyYXRvckNvbnRpbnVhdGlvbih0aHIuYXBwbHkodGhpcy5zLCBhcmd1bWVudHMpKTtcbiAgICB9XG4gIH0sIG5ldyBBc3luY0Zyb21TeW5jSXRlcmF0b3Iocyk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@swc/helpers/src/_async_iterator.mjs\n"));

/***/ }),

/***/ "./node_modules/@swc/helpers/src/_async_to_generator.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@swc/helpers/src/_async_to_generator.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _asyncToGenerator; }\n/* harmony export */ });\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL3NyYy9fYXN5bmNfdG9fZ2VuZXJhdG9yLm1qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzd2MvaGVscGVycy9zcmMvX2FzeW5jX3RvX2dlbmVyYXRvci5tanM/ZGNhZCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaW5mby5kb25lKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICB9XG5cbiAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gIH07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@swc/helpers/src/_async_to_generator.mjs\n"));

/***/ }),

/***/ "./node_modules/@swc/helpers/src/_iterable_to_array.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@swc/helpers/src/_iterable_to_array.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _iterableToArray; }\n/* harmony export */ });\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL3NyYy9faXRlcmFibGVfdG9fYXJyYXkubWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZTtBQUNmO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzd2MvaGVscGVycy9zcmMvX2l0ZXJhYmxlX3RvX2FycmF5Lm1qcz9kMDUxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@swc/helpers/src/_iterable_to_array.mjs\n"));

/***/ }),

/***/ "./node_modules/@swc/helpers/src/_non_iterable_spread.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@swc/helpers/src/_non_iterable_spread.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _nonIterableSpread; }\n/* harmony export */ });\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL3NyYy9fbm9uX2l0ZXJhYmxlX3NwcmVhZC5tanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlO0FBQ2Y7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL3NyYy9fbm9uX2l0ZXJhYmxlX3NwcmVhZC5tanM/ZGEzYyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXFxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@swc/helpers/src/_non_iterable_spread.mjs\n"));

/***/ }),

/***/ "./node_modules/@swc/helpers/src/_to_consumable_array.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@swc/helpers/src/_to_consumable_array.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _toConsumableArray; }\n/* harmony export */ });\n/* harmony import */ var _array_without_holes_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_array_without_holes.mjs */ \"./node_modules/@swc/helpers/src/_array_without_holes.mjs\");\n/* harmony import */ var _iterable_to_array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_iterable_to_array.mjs */ \"./node_modules/@swc/helpers/src/_iterable_to_array.mjs\");\n/* harmony import */ var _non_iterable_spread_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_non_iterable_spread.mjs */ \"./node_modules/@swc/helpers/src/_non_iterable_spread.mjs\");\n/* harmony import */ var _unsupported_iterable_to_array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_unsupported_iterable_to_array.mjs */ \"./node_modules/@swc/helpers/src/_unsupported_iterable_to_array.mjs\");\n\n\n\n\n\nfunction _toConsumableArray(arr) {\n  return (0,_array_without_holes_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(arr) || (0,_iterable_to_array_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(arr) || (0,_unsupported_iterable_to_array_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(arr) || (0,_non_iterable_spread_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"])();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL3NyYy9fdG9fY29uc3VtYWJsZV9hcnJheS5tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMkQ7QUFDSjtBQUNJO0FBQ21COztBQUUvRDtBQUNmLFNBQVMsb0VBQWlCLFNBQVMsa0VBQWUsU0FBUyw4RUFBMEIsU0FBUyxvRUFBaUI7QUFDL0ciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzd2MvaGVscGVycy9zcmMvX3RvX2NvbnN1bWFibGVfYXJyYXkubWpzPzBmYzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFycmF5V2l0aG91dEhvbGVzIGZyb20gJy4vX2FycmF5X3dpdGhvdXRfaG9sZXMubWpzJztcbmltcG9ydCBpdGVyYWJsZVRvQXJyYXkgZnJvbSAnLi9faXRlcmFibGVfdG9fYXJyYXkubWpzJztcbmltcG9ydCBub25JdGVyYWJsZVNwcmVhZCBmcm9tICcuL19ub25faXRlcmFibGVfc3ByZWFkLm1qcyc7XG5pbXBvcnQgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgZnJvbSAnLi9fdW5zdXBwb3J0ZWRfaXRlcmFibGVfdG9fYXJyYXkubWpzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@swc/helpers/src/_to_consumable_array.mjs\n"));

/***/ }),

/***/ "./node_modules/@swc/helpers/src/_ts_generator.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@swc/helpers/src/_ts_generator.mjs ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* reexport safe */ tslib__WEBPACK_IMPORTED_MODULE_0__.__generator; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL3NyYy9fdHNfZ2VuZXJhdG9yLm1qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL3NyYy9fdHNfZ2VuZXJhdG9yLm1qcz9jZmUzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IF9fZ2VuZXJhdG9yIGFzIGRlZmF1bHQgfSBmcm9tICd0c2xpYidcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@swc/helpers/src/_ts_generator.mjs\n"));

/***/ }),

/***/ "./node_modules/@swc/helpers/src/_unsupported_iterable_to_array.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@swc/helpers/src/_unsupported_iterable_to_array.mjs ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _unsupportedIterableToArray; }\n/* harmony export */ });\n/* harmony import */ var _array_like_to_array_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_array_like_to_array.mjs */ \"./node_modules/@swc/helpers/src/_array_like_to_array.mjs\");\n\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return (0,_array_like_to_array_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n    return (0,_array_like_to_array_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(o, minLen);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL3NyYy9fdW5zdXBwb3J0ZWRfaXRlcmFibGVfdG9fYXJyYXkubWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTJEOztBQUU1QztBQUNmO0FBQ0Esb0NBQW9DLG9FQUFpQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0VBQWlCO0FBQzVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac3djL2hlbHBlcnMvc3JjL191bnN1cHBvcnRlZF9pdGVyYWJsZV90b19hcnJheS5tanM/NzJhZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2FycmF5TGlrZVRvQXJyYXkgZnJvbSAnLi9fYXJyYXlfbGlrZV90b19hcnJheS5tanMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG4pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSlcbiAgICByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@swc/helpers/src/_unsupported_iterable_to_array.mjs\n"));

/***/ }),

/***/ "./node_modules/nats.ws/esm/nats.js":
/*!******************************************!*\
  !*** ./node_modules/nats.ws/esm/nats.js ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AckPolicy\": function() { return /* binding */ AckPolicy; },\n/* harmony export */   \"AdvisoryKind\": function() { return /* binding */ AdvisoryKind; },\n/* harmony export */   \"Bench\": function() { return /* binding */ Bench; },\n/* harmony export */   \"DebugEvents\": function() { return /* binding */ DebugEvents; },\n/* harmony export */   \"DeliverPolicy\": function() { return /* binding */ DeliverPolicy; },\n/* harmony export */   \"DiscardPolicy\": function() { return /* binding */ DiscardPolicy; },\n/* harmony export */   \"Empty\": function() { return /* binding */ Empty; },\n/* harmony export */   \"ErrorCode\": function() { return /* binding */ ErrorCode; },\n/* harmony export */   \"Events\": function() { return /* binding */ Events; },\n/* harmony export */   \"JSONCodec\": function() { return /* binding */ JSONCodec; },\n/* harmony export */   \"JsHeaders\": function() { return /* binding */ JsHeaders; },\n/* harmony export */   \"Match\": function() { return /* binding */ Match; },\n/* harmony export */   \"Metric\": function() { return /* binding */ Metric; },\n/* harmony export */   \"MsgHdrsImpl\": function() { return /* binding */ MsgHdrsImpl; },\n/* harmony export */   \"NatsError\": function() { return /* binding */ NatsError; },\n/* harmony export */   \"Nuid\": function() { return /* binding */ Nuid; },\n/* harmony export */   \"ReplayPolicy\": function() { return /* binding */ ReplayPolicy; },\n/* harmony export */   \"RetentionPolicy\": function() { return /* binding */ RetentionPolicy; },\n/* harmony export */   \"StorageType\": function() { return /* binding */ StorageType; },\n/* harmony export */   \"StringCodec\": function() { return /* binding */ StringCodec; },\n/* harmony export */   \"canonicalMIMEHeaderKey\": function() { return /* binding */ canonicalMIMEHeaderKey; },\n/* harmony export */   \"checkJsError\": function() { return /* binding */ checkJsError; },\n/* harmony export */   \"connect\": function() { return /* binding */ connect; },\n/* harmony export */   \"consumerOpts\": function() { return /* binding */ consumerOpts; },\n/* harmony export */   \"createInbox\": function() { return /* binding */ createInbox; },\n/* harmony export */   \"credsAuthenticator\": function() { return /* binding */ credsAuthenticator; },\n/* harmony export */   \"deferred\": function() { return /* binding */ deferred; },\n/* harmony export */   \"headers\": function() { return /* binding */ headers; },\n/* harmony export */   \"isFlowControlMsg\": function() { return /* binding */ isFlowControlMsg; },\n/* harmony export */   \"isHeartbeatMsg\": function() { return /* binding */ isHeartbeatMsg; },\n/* harmony export */   \"jwtAuthenticator\": function() { return /* binding */ jwtAuthenticator; },\n/* harmony export */   \"millis\": function() { return /* binding */ millis; },\n/* harmony export */   \"nanos\": function() { return /* binding */ nanos; },\n/* harmony export */   \"nkeyAuthenticator\": function() { return /* binding */ nkeyAuthenticator; },\n/* harmony export */   \"nuid\": function() { return /* binding */ nuid; },\n/* harmony export */   \"toJsMsg\": function() { return /* binding */ toJsMsg; },\n/* harmony export */   \"tokenAuthenticator\": function() { return /* binding */ tokenAuthenticator; },\n/* harmony export */   \"usernamePasswordAuthenticator\": function() { return /* binding */ usernamePasswordAuthenticator; }\n/* harmony export */ });\n// deno-fmt-ignore-file\n// deno-lint-ignore-file\n// This code was bundled using `deno bundle` and it's not recommended to edit it manually\n\nconst Empty = new Uint8Array(0);\nvar Events;\n(function(Events) {\n    Events[\"Disconnect\"] = \"disconnect\";\n    Events[\"Reconnect\"] = \"reconnect\";\n    Events[\"Update\"] = \"update\";\n    Events[\"LDM\"] = \"ldm\";\n    Events[\"Error\"] = \"error\";\n})(Events || (Events = {}));\nvar DebugEvents;\n(function(DebugEvents) {\n    DebugEvents[\"Reconnecting\"] = \"reconnecting\";\n    DebugEvents[\"PingTimer\"] = \"pingTimer\";\n    DebugEvents[\"StaleConnection\"] = \"staleConnection\";\n})(DebugEvents || (DebugEvents = {}));\nconst DEFAULT_HOST = \"127.0.0.1\";\nconst DEFAULT_RECONNECT_TIME_WAIT = 2 * 1000;\nconst DEFAULT_PING_INTERVAL = 2 * 60 * 1000;\nconst DEFAULT_MAX_PING_OUT = 2;\nvar RequestStrategy;\n(function(RequestStrategy) {\n    RequestStrategy[\"Timer\"] = \"timer\";\n    RequestStrategy[\"Count\"] = \"count\";\n    RequestStrategy[\"JitterTimer\"] = \"jitterTimer\";\n    RequestStrategy[\"SentinelMsg\"] = \"sentinelMsg\";\n})(RequestStrategy || (RequestStrategy = {}));\nvar AdvisoryKind;\n(function(AdvisoryKind) {\n    AdvisoryKind[\"API\"] = \"api_audit\";\n    AdvisoryKind[\"StreamAction\"] = \"stream_action\";\n    AdvisoryKind[\"ConsumerAction\"] = \"consumer_action\";\n    AdvisoryKind[\"SnapshotCreate\"] = \"snapshot_create\";\n    AdvisoryKind[\"SnapshotComplete\"] = \"snapshot_complete\";\n    AdvisoryKind[\"RestoreCreate\"] = \"restore_create\";\n    AdvisoryKind[\"RestoreComplete\"] = \"restore_complete\";\n    AdvisoryKind[\"MaxDeliver\"] = \"max_deliver\";\n    AdvisoryKind[\"Terminated\"] = \"terminated\";\n    AdvisoryKind[\"Ack\"] = \"consumer_ack\";\n    AdvisoryKind[\"StreamLeaderElected\"] = \"stream_leader_elected\";\n    AdvisoryKind[\"StreamQuorumLost\"] = \"stream_quorum_lost\";\n    AdvisoryKind[\"ConsumerLeaderElected\"] = \"consumer_leader_elected\";\n    AdvisoryKind[\"ConsumerQuorumLost\"] = \"consumer_quorum_lost\";\n})(AdvisoryKind || (AdvisoryKind = {}));\nvar RetentionPolicy;\n(function(RetentionPolicy) {\n    RetentionPolicy[\"Limits\"] = \"limits\";\n    RetentionPolicy[\"Interest\"] = \"interest\";\n    RetentionPolicy[\"Workqueue\"] = \"workqueue\";\n})(RetentionPolicy || (RetentionPolicy = {}));\nvar DiscardPolicy;\n(function(DiscardPolicy) {\n    DiscardPolicy[\"Old\"] = \"old\";\n    DiscardPolicy[\"New\"] = \"new\";\n})(DiscardPolicy || (DiscardPolicy = {}));\nvar StorageType;\n(function(StorageType) {\n    StorageType[\"File\"] = \"file\";\n    StorageType[\"Memory\"] = \"memory\";\n})(StorageType || (StorageType = {}));\nvar DeliverPolicy;\n(function(DeliverPolicy) {\n    DeliverPolicy[\"All\"] = \"all\";\n    DeliverPolicy[\"Last\"] = \"last\";\n    DeliverPolicy[\"New\"] = \"new\";\n    DeliverPolicy[\"StartSequence\"] = \"by_start_sequence\";\n    DeliverPolicy[\"StartTime\"] = \"by_start_time\";\n    DeliverPolicy[\"LastPerSubject\"] = \"last_per_subject\";\n})(DeliverPolicy || (DeliverPolicy = {}));\nvar AckPolicy;\n(function(AckPolicy) {\n    AckPolicy[\"None\"] = \"none\";\n    AckPolicy[\"All\"] = \"all\";\n    AckPolicy[\"Explicit\"] = \"explicit\";\n    AckPolicy[\"NotSet\"] = \"\";\n})(AckPolicy || (AckPolicy = {}));\nvar ReplayPolicy;\n(function(ReplayPolicy) {\n    ReplayPolicy[\"Instant\"] = \"instant\";\n    ReplayPolicy[\"Original\"] = \"original\";\n})(ReplayPolicy || (ReplayPolicy = {}));\nvar JsHeaders;\n(function(JsHeaders) {\n    JsHeaders[\"StreamSourceHdr\"] = \"Nats-Stream-Source\";\n    JsHeaders[\"LastConsumerSeqHdr\"] = \"Nats-Last-Consumer\";\n    JsHeaders[\"LastStreamSeqHdr\"] = \"Nats-Last-Stream\";\n    JsHeaders[\"ConsumerStalledHdr\"] = \"Nats-Consumer-Stalled\";\n    JsHeaders[\"MessageSizeHdr\"] = \"Nats-Msg-Size\";\n    JsHeaders[\"RollupHdr\"] = \"Nats-Rollup\";\n    JsHeaders[\"RollupValueSubject\"] = \"sub\";\n    JsHeaders[\"RollupValueAll\"] = \"all\";\n})(JsHeaders || (JsHeaders = {}));\nvar DirectMsgHeaders;\n(function(DirectMsgHeaders) {\n    DirectMsgHeaders[\"Stream\"] = \"Nats-Stream\";\n    DirectMsgHeaders[\"Sequence\"] = \"Nats-Sequence\";\n    DirectMsgHeaders[\"TimeStamp\"] = \"Nats-Time-Stamp\";\n    DirectMsgHeaders[\"Subject\"] = \"Nats-Subject\";\n})(DirectMsgHeaders || (DirectMsgHeaders = {}));\nvar RepublishHeaders;\n(function(RepublishHeaders) {\n    RepublishHeaders[\"Stream\"] = \"Nats-Stream\";\n    RepublishHeaders[\"Subject\"] = \"Nats-Subject\";\n    RepublishHeaders[\"Sequence\"] = \"Nats-Sequence\";\n    RepublishHeaders[\"LastSequence\"] = \"Nats-Last-Sequence\";\n    RepublishHeaders[\"Size\"] = \"Nats-Msg-Size\";\n})(RepublishHeaders || (RepublishHeaders = {}));\nvar ErrorCode;\n(function(ErrorCode) {\n    ErrorCode[\"ApiError\"] = \"BAD API\";\n    ErrorCode[\"BadAuthentication\"] = \"BAD_AUTHENTICATION\";\n    ErrorCode[\"BadCreds\"] = \"BAD_CREDS\";\n    ErrorCode[\"BadHeader\"] = \"BAD_HEADER\";\n    ErrorCode[\"BadJson\"] = \"BAD_JSON\";\n    ErrorCode[\"BadPayload\"] = \"BAD_PAYLOAD\";\n    ErrorCode[\"BadSubject\"] = \"BAD_SUBJECT\";\n    ErrorCode[\"Cancelled\"] = \"CANCELLED\";\n    ErrorCode[\"ConnectionClosed\"] = \"CONNECTION_CLOSED\";\n    ErrorCode[\"ConnectionDraining\"] = \"CONNECTION_DRAINING\";\n    ErrorCode[\"ConnectionRefused\"] = \"CONNECTION_REFUSED\";\n    ErrorCode[\"ConnectionTimeout\"] = \"CONNECTION_TIMEOUT\";\n    ErrorCode[\"Disconnect\"] = \"DISCONNECT\";\n    ErrorCode[\"InvalidOption\"] = \"INVALID_OPTION\";\n    ErrorCode[\"InvalidPayload\"] = \"INVALID_PAYLOAD\";\n    ErrorCode[\"MaxPayloadExceeded\"] = \"MAX_PAYLOAD_EXCEEDED\";\n    ErrorCode[\"NoResponders\"] = \"503\";\n    ErrorCode[\"NotFunction\"] = \"NOT_FUNC\";\n    ErrorCode[\"RequestError\"] = \"REQUEST_ERROR\";\n    ErrorCode[\"ServerOptionNotAvailable\"] = \"SERVER_OPT_NA\";\n    ErrorCode[\"SubClosed\"] = \"SUB_CLOSED\";\n    ErrorCode[\"SubDraining\"] = \"SUB_DRAINING\";\n    ErrorCode[\"Timeout\"] = \"TIMEOUT\";\n    ErrorCode[\"Tls\"] = \"TLS\";\n    ErrorCode[\"Unknown\"] = \"UNKNOWN_ERROR\";\n    ErrorCode[\"WssRequired\"] = \"WSS_REQUIRED\";\n    ErrorCode[\"JetStreamInvalidAck\"] = \"JESTREAM_INVALID_ACK\";\n    ErrorCode[\"JetStream404NoMessages\"] = \"404\";\n    ErrorCode[\"JetStream408RequestTimeout\"] = \"408\";\n    ErrorCode[\"JetStream409MaxAckPendingExceeded\"] = \"409\";\n    ErrorCode[\"JetStream409\"] = \"409\";\n    ErrorCode[\"JetStreamNotEnabled\"] = \"503\";\n    ErrorCode[\"AuthorizationViolation\"] = \"AUTHORIZATION_VIOLATION\";\n    ErrorCode[\"AuthenticationExpired\"] = \"AUTHENTICATION_EXPIRED\";\n    ErrorCode[\"ProtocolError\"] = \"NATS_PROTOCOL_ERR\";\n    ErrorCode[\"PermissionsViolation\"] = \"PERMISSIONS_VIOLATION\";\n})(ErrorCode || (ErrorCode = {}));\nclass Messages {\n    messages;\n    constructor(){\n        this.messages = new Map();\n        this.messages.set(ErrorCode.InvalidPayload, \"Invalid payload type - payloads can be 'binary', 'string', or 'json'\");\n        this.messages.set(ErrorCode.BadJson, \"Bad JSON\");\n        this.messages.set(ErrorCode.WssRequired, \"TLS is required, therefore a secure websocket connection is also required\");\n    }\n    static getMessage(s) {\n        return messages.getMessage(s);\n    }\n    getMessage(s) {\n        return this.messages.get(s) || s;\n    }\n}\nconst messages = new Messages();\nfunction isNatsError(err) {\n    return typeof err.code === \"string\";\n}\nclass NatsError extends Error {\n    name;\n    message;\n    code;\n    permissionContext;\n    chainedError;\n    api_error;\n    constructor(message, code, chainedError){\n        super(message);\n        this.name = \"NatsError\";\n        this.message = message;\n        this.code = code;\n        this.chainedError = chainedError;\n    }\n    static errorForCode(code, chainedError) {\n        const m = Messages.getMessage(code);\n        return new NatsError(m, code, chainedError);\n    }\n    isAuthError() {\n        return this.code === ErrorCode.AuthenticationExpired || this.code === ErrorCode.AuthorizationViolation;\n    }\n    isPermissionError() {\n        return this.code === ErrorCode.PermissionsViolation;\n    }\n    isProtocolError() {\n        return this.code === ErrorCode.ProtocolError;\n    }\n    isJetStreamError() {\n        return this.api_error !== undefined;\n    }\n    jsError() {\n        return this.api_error ? this.api_error : null;\n    }\n}\nconst TE = new TextEncoder();\nconst TD = new TextDecoder();\nfunction concat(...bufs) {\n    let max = 0;\n    for(let i = 0; i < bufs.length; i++){\n        max += bufs[i].length;\n    }\n    const out = new Uint8Array(max);\n    let index = 0;\n    for(let i1 = 0; i1 < bufs.length; i1++){\n        out.set(bufs[i1], index);\n        index += bufs[i1].length;\n    }\n    return out;\n}\nfunction encode(...a) {\n    const bufs = [];\n    for(let i = 0; i < a.length; i++){\n        bufs.push(TE.encode(a[i]));\n    }\n    if (bufs.length === 0) {\n        return Empty;\n    }\n    if (bufs.length === 1) {\n        return bufs[0];\n    }\n    return concat(...bufs);\n}\nfunction decode(a) {\n    if (!a || a.length === 0) {\n        return \"\";\n    }\n    return TD.decode(a);\n}\nfunction StringCodec() {\n    return {\n        encode (d) {\n            return TE.encode(d);\n        },\n        decode (a) {\n            return TD.decode(a);\n        }\n    };\n}\nfunction JSONCodec(reviver) {\n    return {\n        encode (d) {\n            try {\n                if (d === undefined) {\n                    d = null;\n                }\n                return TE.encode(JSON.stringify(d));\n            } catch (err) {\n                throw NatsError.errorForCode(ErrorCode.BadJson, err);\n            }\n        },\n        decode (a) {\n            try {\n                return JSON.parse(TD.decode(a), reviver);\n            } catch (err) {\n                throw NatsError.errorForCode(ErrorCode.BadJson, err);\n            }\n        }\n    };\n}\n\"use strict\";\nconst digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nconst base = 36;\nconst maxSeq = 3656158440062976;\nconst minInc = 33;\nconst maxInc = 333;\nconst totalLen = 12 + 10;\nfunction _getRandomValues(a) {\n    for(let i = 0; i < a.length; i++){\n        a[i] = Math.floor(Math.random() * 255);\n    }\n}\nfunction fillRandom(a) {\n    if (globalThis?.crypto?.getRandomValues) {\n        globalThis.crypto.getRandomValues(a);\n    } else {\n        _getRandomValues(a);\n    }\n}\nclass Nuid {\n    buf;\n    seq;\n    inc;\n    constructor(){\n        this.buf = new Uint8Array(totalLen);\n        this.init();\n    }\n    init() {\n        this.setPre();\n        this.initSeqAndInc();\n        this.fillSeq();\n    }\n    initSeqAndInc() {\n        this.seq = Math.floor(Math.random() * maxSeq);\n        this.inc = Math.floor(Math.random() * (maxInc - minInc) + minInc);\n    }\n    setPre() {\n        const cbuf = new Uint8Array(12);\n        fillRandom(cbuf);\n        for(let i = 0; i < 12; i++){\n            const di = cbuf[i] % 36;\n            this.buf[i] = digits.charCodeAt(di);\n        }\n    }\n    fillSeq() {\n        let n = this.seq;\n        for(let i = totalLen - 1; i >= 12; i--){\n            this.buf[i] = digits.charCodeAt(n % base);\n            n = Math.floor(n / base);\n        }\n    }\n    next() {\n        this.seq += this.inc;\n        if (this.seq > 3656158440062976) {\n            this.setPre();\n            this.initSeqAndInc();\n        }\n        this.fillSeq();\n        return String.fromCharCode.apply(String, this.buf);\n    }\n    reset() {\n        this.init();\n    }\n}\nconst nuid = new Nuid();\nclass DataBuffer {\n    buffers;\n    byteLength;\n    constructor(){\n        this.buffers = [];\n        this.byteLength = 0;\n    }\n    static concat(...bufs) {\n        let max = 0;\n        for(let i = 0; i < bufs.length; i++){\n            max += bufs[i].length;\n        }\n        const out = new Uint8Array(max);\n        let index = 0;\n        for(let i1 = 0; i1 < bufs.length; i1++){\n            out.set(bufs[i1], index);\n            index += bufs[i1].length;\n        }\n        return out;\n    }\n    static fromAscii(m) {\n        if (!m) {\n            m = \"\";\n        }\n        return TE.encode(m);\n    }\n    static toAscii(a) {\n        return TD.decode(a);\n    }\n    reset() {\n        this.buffers.length = 0;\n        this.byteLength = 0;\n    }\n    pack() {\n        if (this.buffers.length > 1) {\n            const v = new Uint8Array(this.byteLength);\n            let index = 0;\n            for(let i = 0; i < this.buffers.length; i++){\n                v.set(this.buffers[i], index);\n                index += this.buffers[i].length;\n            }\n            this.buffers.length = 0;\n            this.buffers.push(v);\n        }\n    }\n    shift() {\n        if (this.buffers.length) {\n            const a = this.buffers.shift();\n            if (a) {\n                this.byteLength -= a.length;\n                return a;\n            }\n        }\n        return new Uint8Array(0);\n    }\n    drain(n) {\n        if (this.buffers.length) {\n            this.pack();\n            const v = this.buffers.pop();\n            if (v) {\n                const max = this.byteLength;\n                if (n === undefined || n > max) {\n                    n = max;\n                }\n                const d = v.subarray(0, n);\n                if (max > n) {\n                    this.buffers.push(v.subarray(n));\n                }\n                this.byteLength = max - n;\n                return d;\n            }\n        }\n        return new Uint8Array(0);\n    }\n    fill(a, ...bufs) {\n        if (a) {\n            this.buffers.push(a);\n            this.byteLength += a.length;\n        }\n        for(let i = 0; i < bufs.length; i++){\n            if (bufs[i] && bufs[i].length) {\n                this.buffers.push(bufs[i]);\n                this.byteLength += bufs[i].length;\n            }\n        }\n    }\n    peek() {\n        if (this.buffers.length) {\n            this.pack();\n            return this.buffers[0];\n        }\n        return new Uint8Array(0);\n    }\n    size() {\n        return this.byteLength;\n    }\n    length() {\n        return this.buffers.length;\n    }\n}\nconst CR_LF = \"\\r\\n\";\nCR_LF.length;\nconst CRLF = DataBuffer.fromAscii(CR_LF);\nconst CR = new Uint8Array(CRLF)[0];\nconst LF = new Uint8Array(CRLF)[1];\nfunction isUint8Array(a) {\n    return a instanceof Uint8Array;\n}\nfunction protoLen(ba) {\n    for(let i = 0; i < ba.length; i++){\n        const n = i + 1;\n        if (ba.byteLength > n && ba[i] === CR && ba[n] === LF) {\n            return n + 1;\n        }\n    }\n    return 0;\n}\nfunction extractProtocolMessage(a) {\n    const len = protoLen(a);\n    if (len > 0) {\n        const ba = new Uint8Array(a);\n        const out = ba.slice(0, len);\n        return TD.decode(out);\n    }\n    return \"\";\n}\nfunction extend(a, ...b) {\n    for(let i = 0; i < b.length; i++){\n        const o = b[i];\n        Object.keys(o).forEach(function(k) {\n            a[k] = o[k];\n        });\n    }\n    return a;\n}\nfunction render(frame) {\n    const cr = \"␍\";\n    const lf = \"␊\";\n    return TD.decode(frame).replace(/\\n/g, lf).replace(/\\r/g, cr);\n}\nfunction timeout(ms) {\n    const err = NatsError.errorForCode(ErrorCode.Timeout);\n    let methods;\n    let timer;\n    const p = new Promise((_resolve, reject)=>{\n        const cancel = ()=>{\n            if (timer) {\n                clearTimeout(timer);\n            }\n        };\n        methods = {\n            cancel\n        };\n        timer = setTimeout(()=>{\n            reject(err);\n        }, ms);\n    });\n    return Object.assign(p, methods);\n}\nfunction delay(ms = 0) {\n    return new Promise((resolve)=>{\n        setTimeout(()=>{\n            resolve();\n        }, ms);\n    });\n}\nfunction deferred() {\n    let methods = {};\n    const p = new Promise((resolve, reject)=>{\n        methods = {\n            resolve,\n            reject\n        };\n    });\n    return Object.assign(p, methods);\n}\nfunction shuffle(a) {\n    for(let i = a.length - 1; i > 0; i--){\n        const j = Math.floor(Math.random() * (i + 1));\n        [a[i], a[j]] = [\n            a[j],\n            a[i]\n        ];\n    }\n    return a;\n}\nclass Perf {\n    timers;\n    measures;\n    constructor(){\n        this.timers = new Map();\n        this.measures = new Map();\n    }\n    mark(key) {\n        this.timers.set(key, Date.now());\n    }\n    measure(key, startKey, endKey) {\n        const s = this.timers.get(startKey);\n        if (s === undefined) {\n            throw new Error(`${startKey} is not defined`);\n        }\n        const e = this.timers.get(endKey);\n        if (e === undefined) {\n            throw new Error(`${endKey} is not defined`);\n        }\n        this.measures.set(key, e - s);\n    }\n    getEntries() {\n        const values = [];\n        this.measures.forEach((v, k)=>{\n            values.push({\n                name: k,\n                duration: v\n            });\n        });\n        return values;\n    }\n}\nfunction canonicalMIMEHeaderKey(k) {\n    const dash = 45;\n    const toLower = 97 - 65;\n    let upper = true;\n    const buf = new Array(k.length);\n    for(let i = 0; i < k.length; i++){\n        let c = k.charCodeAt(i);\n        if (c === 58 || c < 33 || c > 126) {\n            throw new NatsError(`'${k[i]}' is not a valid character for a header key`, ErrorCode.BadHeader);\n        }\n        if (upper && 97 <= c && c <= 122) {\n            c -= toLower;\n        } else if (!upper && 65 <= c && c <= 90) {\n            c += toLower;\n        }\n        buf[i] = c;\n        upper = c == dash;\n    }\n    return String.fromCharCode(...buf);\n}\nfunction headers() {\n    return new MsgHdrsImpl();\n}\nconst HEADER = \"NATS/1.0\";\nvar Match;\n(function(Match) {\n    Match[Match[\"Exact\"] = 0] = \"Exact\";\n    Match[Match[\"CanonicalMIME\"] = 1] = \"CanonicalMIME\";\n    Match[Match[\"IgnoreCase\"] = 2] = \"IgnoreCase\";\n})(Match || (Match = {}));\nclass MsgHdrsImpl {\n    code;\n    headers;\n    description;\n    constructor(){\n        this.code = 0;\n        this.headers = new Map();\n        this.description = \"\";\n    }\n    [Symbol.iterator]() {\n        return this.headers.entries();\n    }\n    size() {\n        return this.headers.size;\n    }\n    equals(mh) {\n        if (mh && this.headers.size === mh.headers.size && this.code === mh.code) {\n            for (const [k, v] of this.headers){\n                const a = mh.values(k);\n                if (v.length !== a.length) {\n                    return false;\n                }\n                const vv = [\n                    ...v\n                ].sort();\n                const aa = [\n                    ...a\n                ].sort();\n                for(let i = 0; i < vv.length; i++){\n                    if (vv[i] !== aa[i]) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    static decode(a) {\n        const mh = new MsgHdrsImpl();\n        const s = TD.decode(a);\n        const lines = s.split(\"\\r\\n\");\n        const h = lines[0];\n        if (h !== HEADER) {\n            let str = h.replace(HEADER, \"\");\n            mh.code = parseInt(str, 10);\n            const scode = mh.code.toString();\n            str = str.replace(scode, \"\");\n            mh.description = str.trim();\n        }\n        if (lines.length >= 1) {\n            lines.slice(1).map((s)=>{\n                if (s) {\n                    const idx = s.indexOf(\":\");\n                    if (idx > -1) {\n                        const k = s.slice(0, idx);\n                        const v = s.slice(idx + 1).trim();\n                        mh.append(k, v);\n                    }\n                }\n            });\n        }\n        return mh;\n    }\n    toString() {\n        if (this.headers.size === 0) {\n            return \"\";\n        }\n        let s = HEADER;\n        for (const [k, v] of this.headers){\n            for(let i = 0; i < v.length; i++){\n                s = `${s}\\r\\n${k}: ${v[i]}`;\n            }\n        }\n        return `${s}\\r\\n\\r\\n`;\n    }\n    encode() {\n        return TE.encode(this.toString());\n    }\n    static validHeaderValue(k) {\n        const inv = /[\\r\\n]/;\n        if (inv.test(k)) {\n            throw new NatsError(\"invalid header value - \\\\r and \\\\n are not allowed.\", ErrorCode.BadHeader);\n        }\n        return k.trim();\n    }\n    keys() {\n        const keys = [];\n        for (const sk of this.headers.keys()){\n            keys.push(sk);\n        }\n        return keys;\n    }\n    findKeys(k, match = Match.Exact) {\n        const keys = this.keys();\n        switch(match){\n            case Match.Exact:\n                return keys.filter((v)=>{\n                    return v === k;\n                });\n            case Match.CanonicalMIME:\n                k = canonicalMIMEHeaderKey(k);\n                return keys.filter((v)=>{\n                    return v === k;\n                });\n            default:\n                {\n                    const lci = k.toLowerCase();\n                    return keys.filter((v)=>{\n                        return lci === v.toLowerCase();\n                    });\n                }\n        }\n    }\n    get(k, match = Match.Exact) {\n        const keys = this.findKeys(k, match);\n        if (keys.length) {\n            const v = this.headers.get(keys[0]);\n            if (v) {\n                return Array.isArray(v) ? v[0] : v;\n            }\n        }\n        return \"\";\n    }\n    has(k, match = Match.Exact) {\n        return this.findKeys(k, match).length > 0;\n    }\n    set(k, v, match = Match.Exact) {\n        this.delete(k, match);\n        this.append(k, v, match);\n    }\n    append(k, v, match = Match.Exact) {\n        const ck = canonicalMIMEHeaderKey(k);\n        if (match === Match.CanonicalMIME) {\n            k = ck;\n        }\n        const keys = this.findKeys(k, match);\n        k = keys.length > 0 ? keys[0] : k;\n        const value = MsgHdrsImpl.validHeaderValue(v);\n        let a = this.headers.get(k);\n        if (!a) {\n            a = [];\n            this.headers.set(k, a);\n        }\n        a.push(value);\n    }\n    values(k, match = Match.Exact) {\n        const buf = [];\n        const keys = this.findKeys(k, match);\n        keys.forEach((v)=>{\n            const values = this.headers.get(v);\n            if (values) {\n                buf.push(...values);\n            }\n        });\n        return buf;\n    }\n    delete(k, match = Match.Exact) {\n        const keys = this.findKeys(k, match);\n        keys.forEach((v)=>{\n            this.headers.delete(v);\n        });\n    }\n    get hasError() {\n        return this.code >= 300;\n    }\n    get status() {\n        return `${this.code} ${this.description}`.trim();\n    }\n    toRecord() {\n        const data = {};\n        this.keys().forEach((v)=>{\n            data[v] = this.values(v);\n        });\n        return data;\n    }\n    static fromRecord(r) {\n        const h = new MsgHdrsImpl();\n        for(const k in r){\n            h.headers.set(k, r[k]);\n        }\n        return h;\n    }\n}\nfunction validateDurableName(name) {\n    return validateName(\"durable\", name);\n}\nfunction validateStreamName(name) {\n    return validateName(\"stream\", name);\n}\nfunction validateName(context, name = \"\") {\n    if (name === \"\") {\n        throw Error(`${context} name required`);\n    }\n    const bad = [\n        \".\",\n        \"*\",\n        \">\"\n    ];\n    bad.forEach((v)=>{\n        if (name.indexOf(v) !== -1) {\n            throw Error(`invalid ${context} name - ${context} name cannot contain '${v}'`);\n        }\n    });\n}\nfunction defaultConsumer(name, opts = {}) {\n    return Object.assign({\n        name: name,\n        deliver_policy: DeliverPolicy.All,\n        ack_policy: AckPolicy.Explicit,\n        ack_wait: nanos(30 * 1000),\n        replay_policy: ReplayPolicy.Instant\n    }, opts);\n}\nfunction nanos(millis) {\n    return millis * 1000000;\n}\nfunction millis(ns) {\n    return Math.floor(ns / 1000000);\n}\nfunction isFlowControlMsg(msg) {\n    if (msg.data.length > 0) {\n        return false;\n    }\n    const h = msg.headers;\n    if (!h) {\n        return false;\n    }\n    return h.code >= 100 && h.code < 200;\n}\nfunction isHeartbeatMsg(msg) {\n    return isFlowControlMsg(msg) && msg.headers?.description === \"Idle Heartbeat\";\n}\nfunction checkJsError(msg) {\n    if (msg.data.length !== 0) {\n        return null;\n    }\n    const h = msg.headers;\n    if (!h) {\n        return null;\n    }\n    return checkJsErrorCode(h.code, h.description);\n}\nvar Js409Errors;\n(function(Js409Errors) {\n    Js409Errors[\"MaxBatchExceeded\"] = \"exceeded maxrequestbatch of\";\n    Js409Errors[\"MaxExpiresExceeded\"] = \"exceeded maxrequestexpires of\";\n    Js409Errors[\"MaxBytesExceeded\"] = \"exceeded maxrequestmaxbytes of\";\n    Js409Errors[\"MaxMessageSizeExceeded\"] = \"message size exceeds maxbytes\";\n    Js409Errors[\"PushConsumer\"] = \"consumer is push based\";\n    Js409Errors[\"MaxWaitingExceeded\"] = \"exceeded maxwaiting\";\n})(Js409Errors || (Js409Errors = {}));\nlet MAX_WAITING_FAIL = false;\nfunction isTerminal409(err) {\n    if (err.code !== ErrorCode.JetStream409) {\n        return false;\n    }\n    const fatal = [\n        Js409Errors.MaxBatchExceeded,\n        Js409Errors.MaxExpiresExceeded,\n        Js409Errors.MaxBytesExceeded,\n        Js409Errors.MaxMessageSizeExceeded,\n        Js409Errors.PushConsumer, \n    ];\n    if (MAX_WAITING_FAIL) {\n        fatal.push(Js409Errors.MaxWaitingExceeded);\n    }\n    return fatal.find((s)=>{\n        return err.message.indexOf(s) !== -1;\n    }) !== undefined;\n}\nfunction checkJsErrorCode(code, description = \"\") {\n    if (code < 300) {\n        return null;\n    }\n    description = description.toLowerCase();\n    switch(code){\n        case 404:\n            return new NatsError(description, ErrorCode.JetStream404NoMessages);\n        case 408:\n            return new NatsError(description, ErrorCode.JetStream408RequestTimeout);\n        case 409:\n            return new NatsError(description, ErrorCode.JetStream409);\n        case 503:\n            return NatsError.errorForCode(ErrorCode.JetStreamNotEnabled, new Error(description));\n        default:\n            if (description === \"\") {\n                description = ErrorCode.Unknown;\n            }\n            return new NatsError(description, `${code}`);\n    }\n}\nfunction consumerOpts(opts) {\n    return new ConsumerOptsBuilderImpl(opts);\n}\nclass ConsumerOptsBuilderImpl {\n    config;\n    ordered;\n    mack;\n    stream;\n    callbackFn;\n    max;\n    qname;\n    isBind;\n    constructor(opts){\n        this.stream = \"\";\n        this.mack = false;\n        this.ordered = false;\n        this.config = defaultConsumer(\"\", opts || {});\n    }\n    getOpts() {\n        const o = {};\n        o.config = this.config;\n        o.mack = this.mack;\n        o.stream = this.stream;\n        o.callbackFn = this.callbackFn;\n        o.max = this.max;\n        o.queue = this.qname;\n        o.ordered = this.ordered;\n        o.config.ack_policy = o.ordered ? AckPolicy.None : o.config.ack_policy;\n        o.isBind = o.isBind || false;\n        return o;\n    }\n    description(description) {\n        this.config.description = description;\n        return this;\n    }\n    deliverTo(subject) {\n        this.config.deliver_subject = subject;\n        return this;\n    }\n    durable(name) {\n        validateDurableName(name);\n        this.config.durable_name = name;\n        return this;\n    }\n    startSequence(seq) {\n        if (seq <= 0) {\n            throw new Error(\"sequence must be greater than 0\");\n        }\n        this.config.deliver_policy = DeliverPolicy.StartSequence;\n        this.config.opt_start_seq = seq;\n        return this;\n    }\n    startTime(time) {\n        this.config.deliver_policy = DeliverPolicy.StartTime;\n        this.config.opt_start_time = time.toISOString();\n        return this;\n    }\n    deliverAll() {\n        this.config.deliver_policy = DeliverPolicy.All;\n        return this;\n    }\n    deliverLastPerSubject() {\n        this.config.deliver_policy = DeliverPolicy.LastPerSubject;\n        return this;\n    }\n    deliverLast() {\n        this.config.deliver_policy = DeliverPolicy.Last;\n        return this;\n    }\n    deliverNew() {\n        this.config.deliver_policy = DeliverPolicy.New;\n        return this;\n    }\n    startAtTimeDelta(millis) {\n        this.startTime(new Date(Date.now() - millis));\n        return this;\n    }\n    headersOnly() {\n        this.config.headers_only = true;\n        return this;\n    }\n    ackNone() {\n        this.config.ack_policy = AckPolicy.None;\n        return this;\n    }\n    ackAll() {\n        this.config.ack_policy = AckPolicy.All;\n        return this;\n    }\n    ackExplicit() {\n        this.config.ack_policy = AckPolicy.Explicit;\n        return this;\n    }\n    ackWait(millis) {\n        this.config.ack_wait = nanos(millis);\n        return this;\n    }\n    maxDeliver(max) {\n        this.config.max_deliver = max;\n        return this;\n    }\n    filterSubject(s) {\n        this.config.filter_subject = s;\n        return this;\n    }\n    replayInstantly() {\n        this.config.replay_policy = ReplayPolicy.Instant;\n        return this;\n    }\n    replayOriginal() {\n        this.config.replay_policy = ReplayPolicy.Original;\n        return this;\n    }\n    sample(n) {\n        n = Math.trunc(n);\n        if (n < 0 || n > 100) {\n            throw new Error(`value must be between 0-100`);\n        }\n        this.config.sample_freq = `${n}%`;\n        return this;\n    }\n    limit(n) {\n        this.config.rate_limit_bps = n;\n        return this;\n    }\n    maxWaiting(max) {\n        this.config.max_waiting = max;\n        return this;\n    }\n    maxAckPending(max) {\n        this.config.max_ack_pending = max;\n        return this;\n    }\n    idleHeartbeat(millis) {\n        this.config.idle_heartbeat = nanos(millis);\n        return this;\n    }\n    flowControl() {\n        this.config.flow_control = true;\n        return this;\n    }\n    deliverGroup(name) {\n        this.queue(name);\n        return this;\n    }\n    manualAck() {\n        this.mack = true;\n        return this;\n    }\n    maxMessages(max) {\n        this.max = max;\n        return this;\n    }\n    callback(fn) {\n        this.callbackFn = fn;\n        return this;\n    }\n    queue(n) {\n        this.qname = n;\n        this.config.deliver_group = n;\n        return this;\n    }\n    orderedConsumer() {\n        this.ordered = true;\n        return this;\n    }\n    bind(stream, durable) {\n        this.stream = stream;\n        this.config.durable_name = durable;\n        this.isBind = true;\n        return this;\n    }\n    inactiveEphemeralThreshold(millis) {\n        this.config.inactive_threshold = nanos(millis);\n        return this;\n    }\n    maxPullBatch(n) {\n        this.config.max_batch = n;\n        return this;\n    }\n    maxPullRequestExpires(millis) {\n        this.config.max_expires = nanos(millis);\n        return this;\n    }\n    memory() {\n        this.config.mem_storage = true;\n        return this;\n    }\n    numReplicas(n) {\n        this.config.num_replicas = n;\n        return this;\n    }\n}\nfunction isConsumerOptsBuilder(o) {\n    return typeof o.getOpts === \"function\";\n}\nclass QueuedIteratorImpl {\n    inflight;\n    processed;\n    received;\n    noIterator;\n    iterClosed;\n    done;\n    signal;\n    yields;\n    filtered;\n    pendingFiltered;\n    ingestionFilterFn;\n    protocolFilterFn;\n    dispatchedFn;\n    ctx;\n    _data;\n    err;\n    constructor(){\n        this.inflight = 0;\n        this.filtered = 0;\n        this.pendingFiltered = 0;\n        this.processed = 0;\n        this.received = 0;\n        this.noIterator = false;\n        this.done = false;\n        this.signal = deferred();\n        this.yields = [];\n        this.iterClosed = deferred();\n    }\n    [Symbol.asyncIterator]() {\n        return this.iterate();\n    }\n    push(v) {\n        if (this.done) {\n            return;\n        }\n        if (typeof v === \"function\") {\n            this.yields.push(v);\n            this.signal.resolve();\n            return;\n        }\n        const { ingest , protocol  } = this.ingestionFilterFn ? this.ingestionFilterFn(v, this.ctx || this) : {\n            ingest: true,\n            protocol: false\n        };\n        if (ingest) {\n            if (protocol) {\n                this.filtered++;\n                this.pendingFiltered++;\n            }\n            this.yields.push(v);\n            this.signal.resolve();\n        }\n    }\n    async *iterate() {\n        if (this.noIterator) {\n            throw new NatsError(\"unsupported iterator\", ErrorCode.ApiError);\n        }\n        try {\n            while(true){\n                if (this.yields.length === 0) {\n                    await this.signal;\n                }\n                if (this.err) {\n                    throw this.err;\n                }\n                const yields = this.yields;\n                this.inflight = yields.length;\n                this.yields = [];\n                for(let i = 0; i < yields.length; i++){\n                    if (typeof yields[i] === \"function\") {\n                        const fn = yields[i];\n                        try {\n                            fn();\n                        } catch (err) {\n                            throw err;\n                        }\n                        continue;\n                    }\n                    const ok = this.protocolFilterFn ? this.protocolFilterFn(yields[i]) : true;\n                    if (ok) {\n                        this.processed++;\n                        yield yields[i];\n                        if (this.dispatchedFn && yields[i]) {\n                            this.dispatchedFn(yields[i]);\n                        }\n                    } else {\n                        this.pendingFiltered--;\n                    }\n                    this.inflight--;\n                }\n                if (this.done) {\n                    break;\n                } else if (this.yields.length === 0) {\n                    yields.length = 0;\n                    this.yields = yields;\n                    this.signal = deferred();\n                }\n            }\n        } finally{\n            this.stop();\n        }\n    }\n    stop(err) {\n        if (this.done) {\n            return;\n        }\n        this.err = err;\n        this.done = true;\n        this.signal.resolve();\n        this.iterClosed.resolve();\n    }\n    getProcessed() {\n        return this.noIterator ? this.received : this.processed;\n    }\n    getPending() {\n        return this.yields.length + this.inflight - this.pendingFiltered;\n    }\n    getReceived() {\n        return this.received - this.filtered;\n    }\n}\nfunction getLengths(b64) {\n    const len = b64.length;\n    let validLen = b64.indexOf(\"=\");\n    if (validLen === -1) {\n        validLen = len;\n    }\n    const placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n    return [\n        validLen,\n        placeHoldersLen\n    ];\n}\nfunction init(lookup, revLookup, urlsafe = false) {\n    function _byteLength(validLen, placeHoldersLen) {\n        return Math.floor((validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen);\n    }\n    function tripletToBase64(num) {\n        return lookup[num >> 18 & 0x3f] + lookup[num >> 12 & 0x3f] + lookup[num >> 6 & 0x3f] + lookup[num & 0x3f];\n    }\n    function encodeChunk(buf, start, end) {\n        const out = new Array((end - start) / 3);\n        for(let i = start, curTriplet = 0; i < end; i += 3){\n            out[curTriplet++] = tripletToBase64((buf[i] << 16) + (buf[i + 1] << 8) + buf[i + 2]);\n        }\n        return out.join(\"\");\n    }\n    return {\n        byteLength (b64) {\n            return _byteLength.apply(null, getLengths(b64));\n        },\n        toUint8Array (b64) {\n            const [validLen, placeHoldersLen] = getLengths(b64);\n            const buf = new Uint8Array(_byteLength(validLen, placeHoldersLen));\n            const len = placeHoldersLen ? validLen - 4 : validLen;\n            let tmp;\n            let curByte = 0;\n            let i;\n            for(i = 0; i < len; i += 4){\n                tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n                buf[curByte++] = tmp >> 16 & 0xff;\n                buf[curByte++] = tmp >> 8 & 0xff;\n                buf[curByte++] = tmp & 0xff;\n            }\n            if (placeHoldersLen === 2) {\n                tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n                buf[curByte++] = tmp & 0xff;\n            } else if (placeHoldersLen === 1) {\n                tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n                buf[curByte++] = tmp >> 8 & 0xff;\n                buf[curByte++] = tmp & 0xff;\n            }\n            return buf;\n        },\n        fromUint8Array (buf) {\n            const maxChunkLength = 16383;\n            const len = buf.length;\n            const extraBytes = len % 3;\n            const len2 = len - extraBytes;\n            const parts = new Array(Math.ceil(len2 / 16383) + (extraBytes ? 1 : 0));\n            let curChunk = 0;\n            let chunkEnd;\n            for(let i = 0; i < len2; i += maxChunkLength){\n                chunkEnd = i + maxChunkLength;\n                parts[curChunk++] = encodeChunk(buf, i, chunkEnd > len2 ? len2 : chunkEnd);\n            }\n            let tmp;\n            if (extraBytes === 1) {\n                tmp = buf[len2];\n                parts[curChunk] = lookup[tmp >> 2] + lookup[tmp << 4 & 0x3f];\n                if (!urlsafe) parts[curChunk] += \"==\";\n            } else if (extraBytes === 2) {\n                tmp = buf[len2] << 8 | buf[len2 + 1] & 0xff;\n                parts[curChunk] = lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3f] + lookup[tmp << 2 & 0x3f];\n                if (!urlsafe) parts[curChunk] += \"=\";\n            }\n            return parts.join(\"\");\n        }\n    };\n}\nconst lookup = [];\nconst revLookup = [];\nconst code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\";\nfor(let i = 0, l = code.length; i < l; ++i){\n    lookup[i] = code[i];\n    revLookup[code.charCodeAt(i)] = i;\n}\nconst { byteLength , toUint8Array , fromUint8Array  } = init(lookup, revLookup, true);\nconst decoder = new TextDecoder();\nconst encoder = new TextEncoder();\nfunction toHexString(buf) {\n    return buf.reduce((hex, __byte)=>`${hex}${__byte < 16 ? \"0\" : \"\"}${__byte.toString(16)}`, \"\");\n}\nfunction fromHexString(hex) {\n    const len = hex.length;\n    if (len % 2 || !/^[0-9a-fA-F]+$/.test(hex)) {\n        throw new TypeError(\"Invalid hex string.\");\n    }\n    hex = hex.toLowerCase();\n    const buf = new Uint8Array(Math.floor(len / 2));\n    const end = len / 2;\n    for(let i = 0; i < end; ++i){\n        buf[i] = parseInt(hex.substr(i * 2, 2), 16);\n    }\n    return buf;\n}\nfunction decode1(buf, encoding = \"utf8\") {\n    if (/^utf-?8$/i.test(encoding)) {\n        return decoder.decode(buf);\n    } else if (/^base64$/i.test(encoding)) {\n        return fromUint8Array(buf);\n    } else if (/^hex(?:adecimal)?$/i.test(encoding)) {\n        return toHexString(buf);\n    } else {\n        throw new TypeError(\"Unsupported string encoding.\");\n    }\n}\nfunction encode1(str, encoding = \"utf8\") {\n    if (/^utf-?8$/i.test(encoding)) {\n        return encoder.encode(str);\n    } else if (/^base64$/i.test(encoding)) {\n        return toUint8Array(str);\n    } else if (/^hex(?:adecimal)?$/i.test(encoding)) {\n        return fromHexString(str);\n    } else {\n        throw new TypeError(\"Unsupported string encoding.\");\n    }\n}\nclass SHA256 {\n    hashSize = 32;\n    _buf;\n    _bufIdx;\n    _count;\n    _K;\n    _H;\n    _finalized;\n    constructor(){\n        this._buf = new Uint8Array(64);\n        this._K = new Uint32Array([\n            0x428a2f98,\n            0x71374491,\n            0xb5c0fbcf,\n            0xe9b5dba5,\n            0x3956c25b,\n            0x59f111f1,\n            0x923f82a4,\n            0xab1c5ed5,\n            0xd807aa98,\n            0x12835b01,\n            0x243185be,\n            0x550c7dc3,\n            0x72be5d74,\n            0x80deb1fe,\n            0x9bdc06a7,\n            0xc19bf174,\n            0xe49b69c1,\n            0xefbe4786,\n            0x0fc19dc6,\n            0x240ca1cc,\n            0x2de92c6f,\n            0x4a7484aa,\n            0x5cb0a9dc,\n            0x76f988da,\n            0x983e5152,\n            0xa831c66d,\n            0xb00327c8,\n            0xbf597fc7,\n            0xc6e00bf3,\n            0xd5a79147,\n            0x06ca6351,\n            0x14292967,\n            0x27b70a85,\n            0x2e1b2138,\n            0x4d2c6dfc,\n            0x53380d13,\n            0x650a7354,\n            0x766a0abb,\n            0x81c2c92e,\n            0x92722c85,\n            0xa2bfe8a1,\n            0xa81a664b,\n            0xc24b8b70,\n            0xc76c51a3,\n            0xd192e819,\n            0xd6990624,\n            0xf40e3585,\n            0x106aa070,\n            0x19a4c116,\n            0x1e376c08,\n            0x2748774c,\n            0x34b0bcb5,\n            0x391c0cb3,\n            0x4ed8aa4a,\n            0x5b9cca4f,\n            0x682e6ff3,\n            0x748f82ee,\n            0x78a5636f,\n            0x84c87814,\n            0x8cc70208,\n            0x90befffa,\n            0xa4506ceb,\n            0xbef9a3f7,\n            0xc67178f2\n        ]);\n        this.init();\n    }\n    init() {\n        this._H = new Uint32Array([\n            0x6a09e667,\n            0xbb67ae85,\n            0x3c6ef372,\n            0xa54ff53a,\n            0x510e527f,\n            0x9b05688c,\n            0x1f83d9ab,\n            0x5be0cd19\n        ]);\n        this._bufIdx = 0;\n        this._count = new Uint32Array(2);\n        this._buf.fill(0);\n        this._finalized = false;\n        return this;\n    }\n    update(msg, inputEncoding) {\n        if (msg === null) {\n            throw new TypeError(\"msg must be a string or Uint8Array.\");\n        } else if (typeof msg === \"string\") {\n            msg = encode1(msg, inputEncoding);\n        }\n        for(let i = 0, len = msg.length; i < len; i++){\n            this._buf[this._bufIdx++] = msg[i];\n            if (this._bufIdx === 64) {\n                this._transform();\n                this._bufIdx = 0;\n            }\n        }\n        const c = this._count;\n        if ((c[0] += msg.length << 3) < msg.length << 3) {\n            c[1]++;\n        }\n        c[1] += msg.length >>> 29;\n        return this;\n    }\n    digest(outputEncoding) {\n        if (this._finalized) {\n            throw new Error(\"digest has already been called.\");\n        }\n        this._finalized = true;\n        const b = this._buf;\n        let idx = this._bufIdx;\n        b[idx++] = 0x80;\n        while(idx !== 56){\n            if (idx === 64) {\n                this._transform();\n                idx = 0;\n            }\n            b[idx++] = 0;\n        }\n        const c = this._count;\n        b[56] = c[1] >>> 24 & 0xff;\n        b[57] = c[1] >>> 16 & 0xff;\n        b[58] = c[1] >>> 8 & 0xff;\n        b[59] = c[1] >>> 0 & 0xff;\n        b[60] = c[0] >>> 24 & 0xff;\n        b[61] = c[0] >>> 16 & 0xff;\n        b[62] = c[0] >>> 8 & 0xff;\n        b[63] = c[0] >>> 0 & 0xff;\n        this._transform();\n        const hash = new Uint8Array(32);\n        for(let i = 0; i < 8; i++){\n            hash[(i << 2) + 0] = this._H[i] >>> 24 & 0xff;\n            hash[(i << 2) + 1] = this._H[i] >>> 16 & 0xff;\n            hash[(i << 2) + 2] = this._H[i] >>> 8 & 0xff;\n            hash[(i << 2) + 3] = this._H[i] >>> 0 & 0xff;\n        }\n        this.init();\n        return outputEncoding ? decode1(hash, outputEncoding) : hash;\n    }\n    _transform() {\n        const h = this._H;\n        let h0 = h[0];\n        let h1 = h[1];\n        let h2 = h[2];\n        let h3 = h[3];\n        let h4 = h[4];\n        let h5 = h[5];\n        let h6 = h[6];\n        let h7 = h[7];\n        const w = new Uint32Array(16);\n        let i;\n        for(i = 0; i < 16; i++){\n            w[i] = this._buf[(i << 2) + 3] | this._buf[(i << 2) + 2] << 8 | this._buf[(i << 2) + 1] << 16 | this._buf[i << 2] << 24;\n        }\n        for(i = 0; i < 64; i++){\n            let tmp;\n            if (i < 16) {\n                tmp = w[i];\n            } else {\n                let a = w[i + 1 & 15];\n                let b = w[i + 14 & 15];\n                tmp = w[i & 15] = (a >>> 7 ^ a >>> 18 ^ a >>> 3 ^ a << 25 ^ a << 14) + (b >>> 17 ^ b >>> 19 ^ b >>> 10 ^ b << 15 ^ b << 13) + w[i & 15] + w[i + 9 & 15] | 0;\n            }\n            tmp = tmp + h7 + (h4 >>> 6 ^ h4 >>> 11 ^ h4 >>> 25 ^ h4 << 26 ^ h4 << 21 ^ h4 << 7) + (h6 ^ h4 & (h5 ^ h6)) + this._K[i] | 0;\n            h7 = h6;\n            h6 = h5;\n            h5 = h4;\n            h4 = h3 + tmp;\n            h3 = h2;\n            h2 = h1;\n            h1 = h0;\n            h0 = tmp + (h1 & h2 ^ h3 & (h1 ^ h2)) + (h1 >>> 2 ^ h1 >>> 13 ^ h1 >>> 22 ^ h1 << 30 ^ h1 << 19 ^ h1 << 10) | 0;\n        }\n        h[0] = h[0] + h0 | 0;\n        h[1] = h[1] + h1 | 0;\n        h[2] = h[2] + h2 | 0;\n        h[3] = h[3] + h3 | 0;\n        h[4] = h[4] + h4 | 0;\n        h[5] = h[5] + h5 | 0;\n        h[6] = h[6] + h6 | 0;\n        h[7] = h[7] + h7 | 0;\n    }\n}\nfunction parseSemVer(s) {\n    const m = s.match(/(\\d+).(\\d+).(\\d+)/);\n    if (m) {\n        return {\n            major: parseInt(m[1]),\n            minor: parseInt(m[2]),\n            micro: parseInt(m[3])\n        };\n    }\n    throw new Error(`${s} is not a semver value`);\n}\nfunction compare(a, b) {\n    if (a.major < b.major) return -1;\n    if (a.major > b.major) return 1;\n    if (a.minor < b.minor) return -1;\n    if (a.minor > b.minor) return 1;\n    if (a.micro < b.micro) return -1;\n    if (a.micro > b.micro) return 1;\n    return 0;\n}\nvar Feature;\n(function(Feature) {\n    Feature[\"JS_PULL_MAX_BYTES\"] = \"js_pull_max_bytes\";\n})(Feature || (Feature = {}));\nclass Features {\n    server;\n    features;\n    constructor(v){\n        this.features = new Map();\n        this.server = v;\n        this.set(Feature.JS_PULL_MAX_BYTES, \"2.8.3\");\n    }\n    set(f, requires) {\n        this.features.set(f, {\n            min: requires,\n            ok: compare(this.server, parseSemVer(requires)) >= 0\n        });\n    }\n    get(f) {\n        return this.features.get(f) || {\n            min: \"unknown\",\n            ok: false\n        };\n    }\n    supports(f) {\n        return this.get(f).ok;\n    }\n    require(v) {\n        if (typeof v === \"string\") {\n            v = parseSemVer(v);\n        }\n        return compare(this.server, v) >= 0;\n    }\n}\nconst defaultPrefix = \"$JS.API\";\nfunction defaultJsOptions(opts) {\n    opts = opts || {};\n    if (opts.domain) {\n        opts.apiPrefix = `$JS.${opts.domain}.API`;\n        delete opts.domain;\n    }\n    return extend({\n        apiPrefix: defaultPrefix,\n        timeout: 5000\n    }, opts);\n}\nclass BaseApiClient {\n    nc;\n    opts;\n    prefix;\n    timeout;\n    jc;\n    constructor(nc, opts){\n        this.nc = nc;\n        this.opts = defaultJsOptions(opts);\n        this._parseOpts();\n        this.prefix = this.opts.apiPrefix;\n        this.timeout = this.opts.timeout;\n        this.jc = JSONCodec();\n    }\n    _parseOpts() {\n        let prefix = this.opts.apiPrefix;\n        if (!prefix || prefix.length === 0) {\n            throw new Error(\"invalid empty prefix\");\n        }\n        const c = prefix[prefix.length - 1];\n        if (c === \".\") {\n            prefix = prefix.substr(0, prefix.length - 1);\n        }\n        this.opts.apiPrefix = prefix;\n    }\n    async _request(subj, data = null, opts) {\n        opts = opts || {};\n        opts.timeout = this.timeout;\n        let a = Empty;\n        if (data) {\n            a = this.jc.encode(data);\n        }\n        const m = await this.nc.request(subj, a, opts);\n        return this.parseJsResponse(m);\n    }\n    async findStream(subject) {\n        const q = {\n            subject\n        };\n        const r = await this._request(`${this.prefix}.STREAM.NAMES`, q);\n        const names = r;\n        if (!names.streams || names.streams.length !== 1) {\n            throw new Error(\"no stream matches subject\");\n        }\n        return names.streams[0];\n    }\n    parseJsResponse(m) {\n        const v = this.jc.decode(m.data);\n        const r = v;\n        if (r.error) {\n            const err = checkJsErrorCode(r.error.code, r.error.description);\n            if (err !== null) {\n                err.api_error = r.error;\n                throw err;\n            }\n        }\n        return v;\n    }\n}\nclass ListerImpl {\n    err;\n    offset;\n    pageInfo;\n    subject;\n    jsm;\n    filter;\n    constructor(subject, filter, jsm){\n        if (!subject) {\n            throw new Error(\"subject is required\");\n        }\n        this.subject = subject;\n        this.jsm = jsm;\n        this.offset = 0;\n        this.pageInfo = {};\n        this.filter = filter;\n    }\n    async next() {\n        if (this.err) {\n            return [];\n        }\n        if (this.pageInfo && this.offset >= this.pageInfo.total) {\n            return [];\n        }\n        const offset = {\n            offset: this.offset\n        };\n        try {\n            const r = await this.jsm._request(this.subject, offset, {\n                timeout: this.jsm.timeout\n            });\n            this.pageInfo = r;\n            const a = this.filter(r);\n            this.offset += a.length;\n            return a;\n        } catch (err) {\n            this.err = err;\n            throw err;\n        }\n    }\n    async *[Symbol.asyncIterator]() {\n        let page = await this.next();\n        while(page.length > 0){\n            for (const item of page){\n                yield item;\n            }\n            page = await this.next();\n        }\n    }\n}\nclass ConsumerAPIImpl extends BaseApiClient {\n    constructor(nc, opts){\n        super(nc, opts);\n    }\n    async add(stream, cfg) {\n        validateStreamName(stream);\n        if (cfg.deliver_group && cfg.flow_control) {\n            throw new Error(\"jetstream flow control is not supported with queue groups\");\n        }\n        if (cfg.deliver_group && cfg.idle_heartbeat) {\n            throw new Error(\"jetstream idle heartbeat is not supported with queue groups\");\n        }\n        const cr = {};\n        cr.config = cfg;\n        cr.stream_name = stream;\n        if (cr.config.durable_name) {\n            validateDurableName(cr.config.durable_name);\n        }\n        const subj = cfg.durable_name ? `${this.prefix}.CONSUMER.DURABLE.CREATE.${stream}.${cfg.durable_name}` : `${this.prefix}.CONSUMER.CREATE.${stream}`;\n        const r = await this._request(subj, cr);\n        return r;\n    }\n    async update(stream, durable, cfg) {\n        const ci = await this.info(stream, durable);\n        const changable = cfg;\n        return this.add(stream, Object.assign(ci.config, changable));\n    }\n    async info(stream, name) {\n        validateStreamName(stream);\n        validateDurableName(name);\n        const r = await this._request(`${this.prefix}.CONSUMER.INFO.${stream}.${name}`);\n        return r;\n    }\n    async delete(stream, name) {\n        validateStreamName(stream);\n        validateDurableName(name);\n        const r = await this._request(`${this.prefix}.CONSUMER.DELETE.${stream}.${name}`);\n        const cr = r;\n        return cr.success;\n    }\n    list(stream) {\n        validateStreamName(stream);\n        const filter = (v)=>{\n            const clr = v;\n            return clr.consumers;\n        };\n        const subj = `${this.prefix}.CONSUMER.LIST.${stream}`;\n        return new ListerImpl(subj, filter, this);\n    }\n}\nclass BaseRequest {\n    token;\n    received;\n    ctx;\n    requestSubject;\n    mux;\n    constructor(mux, requestSubject){\n        this.mux = mux;\n        this.requestSubject = requestSubject;\n        this.received = 0;\n        this.token = nuid.next();\n        this.ctx = new Error();\n    }\n}\nclass RequestMany extends BaseRequest {\n    callback;\n    done;\n    timer;\n    max;\n    opts;\n    constructor(mux, requestSubject, opts = {\n        maxWait: 1000\n    }){\n        super(mux, requestSubject);\n        this.opts = opts;\n        if (typeof this.opts.callback !== \"function\") {\n            throw new Error(\"callback is required\");\n        }\n        this.callback = this.opts.callback;\n        this.max = typeof opts.maxMessages === \"number\" && opts.maxMessages > 0 ? opts.maxMessages : -1;\n        this.done = deferred();\n        this.done.then(()=>{\n            this.callback(null, null);\n        });\n        this.timer = setTimeout(()=>{\n            this.cancel();\n        }, opts.maxWait);\n    }\n    cancel(err) {\n        if (err) {\n            this.callback(err, null);\n        }\n        clearTimeout(this.timer);\n        this.mux.cancel(this);\n        this.done.resolve();\n    }\n    resolver(err, msg) {\n        if (err) {\n            err.stack += `\\n\\n${this.ctx.stack}`;\n            this.cancel(err);\n        } else {\n            this.callback(null, msg);\n            if (this.opts.strategy === RequestStrategy.Count) {\n                this.max--;\n                if (this.max === 0) {\n                    this.cancel();\n                }\n            }\n            if (this.opts.strategy === RequestStrategy.JitterTimer) {\n                clearTimeout(this.timer);\n                this.timer = setTimeout(()=>{\n                    this.cancel();\n                }, 300);\n            }\n            if (this.opts.strategy === RequestStrategy.SentinelMsg) {\n                if (msg && msg.data.length === 0) {\n                    this.cancel();\n                }\n            }\n        }\n    }\n}\nclass RequestOne extends BaseRequest {\n    deferred;\n    timer;\n    constructor(mux, requestSubject, opts = {\n        timeout: 1000\n    }){\n        super(mux, requestSubject);\n        this.deferred = deferred();\n        this.timer = timeout(opts.timeout);\n    }\n    resolver(err, msg) {\n        if (this.timer) {\n            this.timer.cancel();\n        }\n        if (err) {\n            err.stack += `\\n\\n${this.ctx.stack}`;\n            this.deferred.reject(err);\n        } else {\n            this.deferred.resolve(msg);\n        }\n        this.cancel();\n    }\n    cancel(err) {\n        if (this.timer) {\n            this.timer.cancel();\n        }\n        this.mux.cancel(this);\n        this.deferred.reject(err ? err : NatsError.errorForCode(ErrorCode.Cancelled));\n    }\n}\nconst ACK = Uint8Array.of(43, 65, 67, 75);\nconst NAK = Uint8Array.of(45, 78, 65, 75);\nconst WPI = Uint8Array.of(43, 87, 80, 73);\nconst NXT = Uint8Array.of(43, 78, 88, 84);\nconst TERM = Uint8Array.of(43, 84, 69, 82, 77);\nconst SPACE = Uint8Array.of(32);\nfunction toJsMsg(m) {\n    return new JsMsgImpl(m);\n}\nfunction parseInfo(s) {\n    const tokens = s.split(\".\");\n    if (tokens.length === 9) {\n        tokens.splice(2, 0, \"_\", \"\");\n    }\n    if (tokens.length < 11 || tokens[0] !== \"$JS\" || tokens[1] !== \"ACK\") {\n        throw new Error(`not js message`);\n    }\n    const di = {};\n    di.domain = tokens[2] === \"_\" ? \"\" : tokens[2];\n    di.account_hash = tokens[3];\n    di.stream = tokens[4];\n    di.consumer = tokens[5];\n    di.redeliveryCount = parseInt(tokens[6], 10);\n    di.redelivered = di.redeliveryCount > 1;\n    di.streamSequence = parseInt(tokens[7], 10);\n    di.deliverySequence = parseInt(tokens[8], 10);\n    di.timestampNanos = parseInt(tokens[9], 10);\n    di.pending = parseInt(tokens[10], 10);\n    return di;\n}\nclass JsMsgImpl {\n    msg;\n    di;\n    didAck;\n    constructor(msg){\n        this.msg = msg;\n        this.didAck = false;\n    }\n    get subject() {\n        return this.msg.subject;\n    }\n    get sid() {\n        return this.msg.sid;\n    }\n    get data() {\n        return this.msg.data;\n    }\n    get headers() {\n        return this.msg.headers;\n    }\n    get info() {\n        if (!this.di) {\n            this.di = parseInfo(this.reply);\n        }\n        return this.di;\n    }\n    get redelivered() {\n        return this.info.redeliveryCount > 1;\n    }\n    get reply() {\n        return this.msg.reply || \"\";\n    }\n    get seq() {\n        return this.info.streamSequence;\n    }\n    doAck(payload) {\n        if (!this.didAck) {\n            this.didAck = !this.isWIP(payload);\n            this.msg.respond(payload);\n        }\n    }\n    isWIP(p) {\n        return p.length === 4 && p[0] === WPI[0] && p[1] === WPI[1] && p[2] === WPI[2] && p[3] === WPI[3];\n    }\n    async ackAck() {\n        if (!this.didAck) {\n            this.didAck = true;\n            if (this.msg.reply) {\n                const mi = this.msg;\n                const proto = mi.publisher;\n                const r = new RequestOne(proto.muxSubscriptions, this.msg.reply);\n                proto.request(r);\n                try {\n                    proto.publish(this.msg.reply, ACK, {\n                        reply: `${proto.muxSubscriptions.baseInbox}${r.token}`\n                    });\n                } catch (err) {\n                    r.cancel(err);\n                }\n                try {\n                    await Promise.race([\n                        r.timer,\n                        r.deferred\n                    ]);\n                    return true;\n                } catch (err1) {\n                    r.cancel(err1);\n                }\n            }\n        }\n        return false;\n    }\n    ack() {\n        this.doAck(ACK);\n    }\n    nak(millis) {\n        let payload = NAK;\n        if (millis) {\n            payload = StringCodec().encode(`-NAK ${JSON.stringify({\n                delay: nanos(millis)\n            })}`);\n        }\n        this.doAck(payload);\n    }\n    working() {\n        this.doAck(WPI);\n    }\n    next(subj, opts = {\n        batch: 1\n    }) {\n        const args = {};\n        args.batch = opts.batch || 1;\n        args.no_wait = opts.no_wait || false;\n        if (opts.expires && opts.expires > 0) {\n            args.expires = nanos(opts.expires);\n        }\n        const data = JSONCodec().encode(args);\n        const payload = DataBuffer.concat(NXT, SPACE, data);\n        const reqOpts = subj ? {\n            reply: subj\n        } : undefined;\n        this.msg.respond(payload, reqOpts);\n    }\n    term() {\n        this.doAck(TERM);\n    }\n}\nfunction checkFn(fn, name, required = false) {\n    if (required === true && !fn) {\n        throw NatsError.errorForCode(ErrorCode.ApiError, new Error(`${name} is not a function`));\n    }\n    if (fn && typeof fn !== \"function\") {\n        throw NatsError.errorForCode(ErrorCode.ApiError, new Error(`${name} is not a function`));\n    }\n}\nclass TypedSubscription extends QueuedIteratorImpl {\n    sub;\n    adapter;\n    subIterDone;\n    constructor(nc, subject, opts){\n        super();\n        checkFn(opts.adapter, \"adapter\", true);\n        this.adapter = opts.adapter;\n        if (opts.callback) {\n            checkFn(opts.callback, \"callback\");\n        }\n        this.noIterator = typeof opts.callback === \"function\";\n        if (opts.ingestionFilterFn) {\n            checkFn(opts.ingestionFilterFn, \"ingestionFilterFn\");\n            this.ingestionFilterFn = opts.ingestionFilterFn;\n        }\n        if (opts.protocolFilterFn) {\n            checkFn(opts.protocolFilterFn, \"protocolFilterFn\");\n            this.protocolFilterFn = opts.protocolFilterFn;\n        }\n        if (opts.dispatchedFn) {\n            checkFn(opts.dispatchedFn, \"dispatchedFn\");\n            this.dispatchedFn = opts.dispatchedFn;\n        }\n        if (opts.cleanupFn) {\n            checkFn(opts.cleanupFn, \"cleanupFn\");\n        }\n        let callback = (err, msg)=>{\n            this.callback(err, msg);\n        };\n        if (opts.callback) {\n            const uh = opts.callback;\n            callback = (err, msg)=>{\n                const [jer, tm] = this.adapter(err, msg);\n                if (jer) {\n                    uh(jer, null);\n                    return;\n                }\n                const { ingest  } = this.ingestionFilterFn ? this.ingestionFilterFn(tm, this) : {\n                    ingest: true\n                };\n                if (ingest) {\n                    const ok = this.protocolFilterFn ? this.protocolFilterFn(tm) : true;\n                    if (ok) {\n                        uh(jer, tm);\n                        if (this.dispatchedFn && tm) {\n                            this.dispatchedFn(tm);\n                        }\n                    }\n                }\n            };\n        }\n        const { max , queue , timeout  } = opts;\n        const sopts = {\n            queue,\n            timeout,\n            callback\n        };\n        if (max && max > 0) {\n            sopts.max = max;\n        }\n        this.sub = nc.subscribe(subject, sopts);\n        if (opts.cleanupFn) {\n            this.sub.cleanupFn = opts.cleanupFn;\n        }\n        if (!this.noIterator) {\n            this.iterClosed.then(()=>{\n                this.unsubscribe();\n            });\n        }\n        this.subIterDone = deferred();\n        Promise.all([\n            this.sub.closed,\n            this.iterClosed\n        ]).then(()=>{\n            this.subIterDone.resolve();\n        }).catch(()=>{\n            this.subIterDone.resolve();\n        });\n        (async (s)=>{\n            await s.closed;\n            this.stop();\n        })(this.sub).then().catch();\n    }\n    unsubscribe(max) {\n        this.sub.unsubscribe(max);\n    }\n    drain() {\n        return this.sub.drain();\n    }\n    isDraining() {\n        return this.sub.isDraining();\n    }\n    isClosed() {\n        return this.sub.isClosed();\n    }\n    callback(e, msg) {\n        this.sub.cancelTimeout();\n        const [err, tm] = this.adapter(e, msg);\n        if (err) {\n            this.stop(err);\n        }\n        if (tm) {\n            this.push(tm);\n        }\n    }\n    getSubject() {\n        return this.sub.getSubject();\n    }\n    getReceived() {\n        return this.sub.getReceived();\n    }\n    getProcessed() {\n        return this.sub.getProcessed();\n    }\n    getPending() {\n        return this.sub.getPending();\n    }\n    getID() {\n        return this.sub.getID();\n    }\n    getMax() {\n        return this.sub.getMax();\n    }\n    get closed() {\n        return this.sub.closed;\n    }\n}\nfunction isRequestError(msg) {\n    if (msg && msg.data.length === 0 && msg.headers) {\n        const headers = msg.headers;\n        if (headers.hasError) {\n            if (headers.code === 503) {\n                return NatsError.errorForCode(ErrorCode.NoResponders);\n            }\n        }\n    }\n    return null;\n}\nclass MsgImpl {\n    _headers;\n    _msg;\n    _rdata;\n    _reply;\n    _subject;\n    publisher;\n    constructor(msg, data, publisher){\n        this._msg = msg;\n        this._rdata = data;\n        this.publisher = publisher;\n    }\n    get subject() {\n        if (this._subject) {\n            return this._subject;\n        }\n        this._subject = TD.decode(this._msg.subject);\n        return this._subject;\n    }\n    get reply() {\n        if (this._reply) {\n            return this._reply;\n        }\n        this._reply = TD.decode(this._msg.reply);\n        return this._reply;\n    }\n    get sid() {\n        return this._msg.sid;\n    }\n    get headers() {\n        if (this._msg.hdr > -1 && !this._headers) {\n            const buf = this._rdata.subarray(0, this._msg.hdr);\n            this._headers = MsgHdrsImpl.decode(buf);\n        }\n        return this._headers;\n    }\n    get data() {\n        if (!this._rdata) {\n            return new Uint8Array(0);\n        }\n        return this._msg.hdr > -1 ? this._rdata.subarray(this._msg.hdr) : this._rdata;\n    }\n    respond(data = Empty, opts) {\n        if (this.reply) {\n            this.publisher.publish(this.reply, data, opts);\n            return true;\n        }\n        return false;\n    }\n}\nlet transportConfig;\nfunction setTransportFactory(config) {\n    transportConfig = config;\n}\nfunction defaultPort() {\n    return transportConfig !== undefined && transportConfig.defaultPort !== undefined ? transportConfig.defaultPort : 4222;\n}\nfunction getUrlParseFn() {\n    return transportConfig !== undefined && transportConfig.urlParseFn ? transportConfig.urlParseFn : undefined;\n}\nfunction newTransport() {\n    if (!transportConfig || typeof transportConfig.factory !== \"function\") {\n        throw new Error(\"transport fn is not set\");\n    }\n    return transportConfig.factory();\n}\nfunction getResolveFn() {\n    return transportConfig !== undefined && transportConfig.dnsResolveFn ? transportConfig.dnsResolveFn : undefined;\n}\nconst IPv4LEN = 4;\nconst ASCII0 = 48;\nconst ASCIIA = 65;\nconst ASCIIa = 97;\nfunction ipV4(a, b, c, d) {\n    const ip = new Uint8Array(16);\n    const prefix = [\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0xff,\n        0xff\n    ];\n    prefix.forEach((v, idx)=>{\n        ip[idx] = v;\n    });\n    ip[12] = a;\n    ip[13] = b;\n    ip[14] = c;\n    ip[15] = d;\n    return ip;\n}\nfunction isIP(h) {\n    return parseIP(h) !== undefined;\n}\nfunction parseIP(h) {\n    for(let i = 0; i < h.length; i++){\n        switch(h[i]){\n            case \".\":\n                return parseIPv4(h);\n            case \":\":\n                return parseIPv6(h);\n        }\n    }\n    return;\n}\nfunction parseIPv4(s) {\n    const ip = new Uint8Array(4);\n    for(let i = 0; i < 4; i++){\n        if (s.length === 0) {\n            return undefined;\n        }\n        if (i > 0) {\n            if (s[0] !== \".\") {\n                return undefined;\n            }\n            s = s.substring(1);\n        }\n        const { n , c , ok  } = dtoi(s);\n        if (!ok || n > 0xFF) {\n            return undefined;\n        }\n        s = s.substring(c);\n        ip[i] = n;\n    }\n    return ipV4(ip[0], ip[1], ip[2], ip[3]);\n}\nfunction parseIPv6(s) {\n    const ip = new Uint8Array(16);\n    let ellipsis = -1;\n    if (s.length >= 2 && s[0] === \":\" && s[1] === \":\") {\n        ellipsis = 0;\n        s = s.substring(2);\n        if (s.length === 0) {\n            return ip;\n        }\n    }\n    let i = 0;\n    while(i < 16){\n        const { n , c , ok  } = xtoi(s);\n        if (!ok || n > 0xFFFF) {\n            return undefined;\n        }\n        if (c < s.length && s[c] === \".\") {\n            if (ellipsis < 0 && i != 16 - 4) {\n                return undefined;\n            }\n            if (i + 4 > 16) {\n                return undefined;\n            }\n            const ip4 = parseIPv4(s);\n            if (ip4 === undefined) {\n                return undefined;\n            }\n            ip[i] = ip4[12];\n            ip[i + 1] = ip4[13];\n            ip[i + 2] = ip4[14];\n            ip[i + 3] = ip4[15];\n            s = \"\";\n            i += IPv4LEN;\n            break;\n        }\n        ip[i] = n >> 8;\n        ip[i + 1] = n;\n        i += 2;\n        s = s.substring(c);\n        if (s.length === 0) {\n            break;\n        }\n        if (s[0] !== \":\" || s.length == 1) {\n            return undefined;\n        }\n        s = s.substring(1);\n        if (s[0] === \":\") {\n            if (ellipsis >= 0) {\n                return undefined;\n            }\n            ellipsis = i;\n            s = s.substring(1);\n            if (s.length === 0) {\n                break;\n            }\n        }\n    }\n    if (s.length !== 0) {\n        return undefined;\n    }\n    if (i < 16) {\n        if (ellipsis < 0) {\n            return undefined;\n        }\n        const n1 = 16 - i;\n        for(let j = i - 1; j >= ellipsis; j--){\n            ip[j + n1] = ip[j];\n        }\n        for(let j1 = ellipsis + n1 - 1; j1 >= ellipsis; j1--){\n            ip[j1] = 0;\n        }\n    } else if (ellipsis >= 0) {\n        return undefined;\n    }\n    return ip;\n}\nfunction dtoi(s) {\n    let i = 0;\n    let n = 0;\n    for(i = 0; i < s.length && 48 <= s.charCodeAt(i) && s.charCodeAt(i) <= 57; i++){\n        n = n * 10 + (s.charCodeAt(i) - ASCII0);\n        if (n >= 0xFFFFFF) {\n            return {\n                n: 0xFFFFFF,\n                c: i,\n                ok: false\n            };\n        }\n    }\n    if (i === 0) {\n        return {\n            n: 0,\n            c: 0,\n            ok: false\n        };\n    }\n    return {\n        n: n,\n        c: i,\n        ok: true\n    };\n}\nfunction xtoi(s) {\n    let n = 0;\n    let i = 0;\n    for(i = 0; i < s.length; i++){\n        if (48 <= s.charCodeAt(i) && s.charCodeAt(i) <= 57) {\n            n *= 16;\n            n += s.charCodeAt(i) - ASCII0;\n        } else if (97 <= s.charCodeAt(i) && s.charCodeAt(i) <= 102) {\n            n *= 16;\n            n += s.charCodeAt(i) - ASCIIa + 10;\n        } else if (65 <= s.charCodeAt(i) && s.charCodeAt(i) <= 70) {\n            n *= 16;\n            n += s.charCodeAt(i) - ASCIIA + 10;\n        } else {\n            break;\n        }\n        if (n >= 0xFFFFFF) {\n            return {\n                n: 0,\n                c: i,\n                ok: false\n            };\n        }\n    }\n    if (i === 0) {\n        return {\n            n: 0,\n            c: i,\n            ok: false\n        };\n    }\n    return {\n        n: n,\n        c: i,\n        ok: true\n    };\n}\nfunction isIPV4OrHostname(hp) {\n    if (hp.indexOf(\".\") !== -1) {\n        return true;\n    }\n    if (hp.indexOf(\"[\") !== -1 || hp.indexOf(\"::\") !== -1) {\n        return false;\n    }\n    if (hp.split(\":\").length <= 2) {\n        return true;\n    }\n    return false;\n}\nfunction isIPV6(hp) {\n    return !isIPV4OrHostname(hp);\n}\nfunction hostPort(u) {\n    u = u.trim();\n    if (u.match(/^(.*:\\/\\/)(.*)/m)) {\n        u = u.replace(/^(.*:\\/\\/)(.*)/gm, \"$2\");\n    }\n    if (isIPV6(u) && u.indexOf(\"[\") === -1) {\n        u = `[${u}]`;\n    }\n    const op = isIPV6(u) ? u.match(/(]:)(\\d+)/) : u.match(/(:)(\\d+)/);\n    const port = op && op.length === 3 && op[1] && op[2] ? parseInt(op[2]) : 4222;\n    const protocol = port === 80 ? \"https\" : \"http\";\n    const url = new URL(`${protocol}://${u}`);\n    url.port = `${port}`;\n    let hostname = url.hostname;\n    if (hostname.charAt(0) === \"[\") {\n        hostname = hostname.substring(1, hostname.length - 1);\n    }\n    const listen = url.host;\n    return {\n        listen,\n        hostname,\n        port\n    };\n}\nclass ServerImpl {\n    src;\n    listen;\n    hostname;\n    port;\n    didConnect;\n    reconnects;\n    lastConnect;\n    gossiped;\n    tlsName;\n    resolves;\n    constructor(u, gossiped = false){\n        this.src = u;\n        this.tlsName = \"\";\n        const v = hostPort(u);\n        this.listen = v.listen;\n        this.hostname = v.hostname;\n        this.port = v.port;\n        this.didConnect = false;\n        this.reconnects = 0;\n        this.lastConnect = 0;\n        this.gossiped = gossiped;\n    }\n    toString() {\n        return this.listen;\n    }\n    async resolve(opts) {\n        if (!opts.fn) {\n            return [\n                this\n            ];\n        }\n        const buf = [];\n        if (isIP(this.hostname)) {\n            return [\n                this\n            ];\n        } else {\n            const ips = await opts.fn(this.hostname);\n            for (const ip of ips){\n                const proto = this.port === 80 ? \"https\" : \"http\";\n                const url = new URL(`${proto}://${isIPV6(ip) ? \"[\" + ip + \"]\" : ip}`);\n                url.port = `${this.port}`;\n                const ss = new ServerImpl(url.host, false);\n                ss.tlsName = this.hostname;\n                buf.push(ss);\n            }\n        }\n        if (opts.randomize) {\n            shuffle(buf);\n        }\n        this.resolves = buf;\n        return buf;\n    }\n}\nclass Servers {\n    firstSelect;\n    servers;\n    currentServer;\n    tlsName;\n    randomize;\n    constructor(listens = [], opts = {}){\n        this.firstSelect = true;\n        this.servers = [];\n        this.tlsName = \"\";\n        this.randomize = opts.randomize || false;\n        const urlParseFn = getUrlParseFn();\n        if (listens) {\n            listens.forEach((hp)=>{\n                hp = urlParseFn ? urlParseFn(hp) : hp;\n                this.servers.push(new ServerImpl(hp));\n            });\n            if (this.randomize) {\n                this.servers = shuffle(this.servers);\n            }\n        }\n        if (this.servers.length === 0) {\n            this.addServer(`${DEFAULT_HOST}:${defaultPort()}`, false);\n        }\n        this.currentServer = this.servers[0];\n    }\n    updateTLSName() {\n        const cs = this.getCurrentServer();\n        if (!isIP(cs.hostname)) {\n            this.tlsName = cs.hostname;\n            this.servers.forEach((s)=>{\n                if (s.gossiped) {\n                    s.tlsName = this.tlsName;\n                }\n            });\n        }\n    }\n    getCurrentServer() {\n        return this.currentServer;\n    }\n    addServer(u, implicit = false) {\n        const urlParseFn = getUrlParseFn();\n        u = urlParseFn ? urlParseFn(u) : u;\n        const s = new ServerImpl(u, implicit);\n        if (isIP(s.hostname)) {\n            s.tlsName = this.tlsName;\n        }\n        this.servers.push(s);\n    }\n    selectServer() {\n        if (this.firstSelect) {\n            this.firstSelect = false;\n            return this.currentServer;\n        }\n        const t = this.servers.shift();\n        if (t) {\n            this.servers.push(t);\n            this.currentServer = t;\n        }\n        return t;\n    }\n    removeCurrentServer() {\n        this.removeServer(this.currentServer);\n    }\n    removeServer(server) {\n        if (server) {\n            const index = this.servers.indexOf(server);\n            this.servers.splice(index, 1);\n        }\n    }\n    length() {\n        return this.servers.length;\n    }\n    next() {\n        return this.servers.length ? this.servers[0] : undefined;\n    }\n    getServers() {\n        return this.servers;\n    }\n    update(info) {\n        const added = [];\n        let deleted = [];\n        const urlParseFn = getUrlParseFn();\n        const discovered = new Map();\n        if (info.connect_urls && info.connect_urls.length > 0) {\n            info.connect_urls.forEach((hp)=>{\n                hp = urlParseFn ? urlParseFn(hp) : hp;\n                const s = new ServerImpl(hp, true);\n                discovered.set(hp, s);\n            });\n        }\n        const toDelete = [];\n        this.servers.forEach((s, index)=>{\n            const u = s.listen;\n            if (s.gossiped && this.currentServer.listen !== u && discovered.get(u) === undefined) {\n                toDelete.push(index);\n            }\n            discovered.delete(u);\n        });\n        toDelete.reverse();\n        toDelete.forEach((index)=>{\n            const removed = this.servers.splice(index, 1);\n            deleted = deleted.concat(removed[0].listen);\n        });\n        discovered.forEach((v, k)=>{\n            this.servers.push(v);\n            added.push(k);\n        });\n        return {\n            added,\n            deleted\n        };\n    }\n}\nclass SubscriptionImpl extends QueuedIteratorImpl {\n    sid;\n    queue;\n    draining;\n    max;\n    subject;\n    drained;\n    protocol;\n    timer;\n    info;\n    cleanupFn;\n    closed;\n    requestSubject;\n    constructor(protocol, subject, opts = {}){\n        super();\n        extend(this, opts);\n        this.protocol = protocol;\n        this.subject = subject;\n        this.draining = false;\n        this.noIterator = typeof opts.callback === \"function\";\n        this.closed = deferred();\n        if (opts.timeout) {\n            this.timer = timeout(opts.timeout);\n            this.timer.then(()=>{\n                this.timer = undefined;\n            }).catch((err)=>{\n                this.stop(err);\n                if (this.noIterator) {\n                    this.callback(err, {});\n                }\n            });\n        }\n        if (!this.noIterator) {\n            this.iterClosed.then(()=>{\n                this.closed.resolve();\n                this.unsubscribe();\n            });\n        }\n    }\n    setPrePostHandlers(opts) {\n        if (this.noIterator) {\n            const uc = this.callback;\n            const ingestion = opts.ingestionFilterFn ? opts.ingestionFilterFn : ()=>{\n                return {\n                    ingest: true,\n                    protocol: false\n                };\n            };\n            const filter = opts.protocolFilterFn ? opts.protocolFilterFn : ()=>{\n                return true;\n            };\n            const dispatched = opts.dispatchedFn ? opts.dispatchedFn : ()=>{};\n            this.callback = (err, msg)=>{\n                const { ingest  } = ingestion(msg);\n                if (!ingest) {\n                    return;\n                }\n                if (filter(msg)) {\n                    uc(err, msg);\n                    dispatched(msg);\n                }\n            };\n        } else {\n            this.protocolFilterFn = opts.protocolFilterFn;\n            this.dispatchedFn = opts.dispatchedFn;\n        }\n    }\n    callback(err, msg) {\n        this.cancelTimeout();\n        err ? this.stop(err) : this.push(msg);\n    }\n    close() {\n        if (!this.isClosed()) {\n            this.cancelTimeout();\n            this.stop();\n            if (this.cleanupFn) {\n                try {\n                    this.cleanupFn(this, this.info);\n                } catch (_err) {}\n            }\n            this.closed.resolve();\n        }\n    }\n    unsubscribe(max) {\n        this.protocol.unsubscribe(this, max);\n    }\n    cancelTimeout() {\n        if (this.timer) {\n            this.timer.cancel();\n            this.timer = undefined;\n        }\n    }\n    drain() {\n        if (this.protocol.isClosed()) {\n            return Promise.reject(NatsError.errorForCode(ErrorCode.ConnectionClosed));\n        }\n        if (this.isClosed()) {\n            return Promise.reject(NatsError.errorForCode(ErrorCode.SubClosed));\n        }\n        if (!this.drained) {\n            this.protocol.unsub(this);\n            this.drained = this.protocol.flush(deferred());\n            this.drained.then(()=>{\n                this.protocol.subscriptions.cancel(this);\n            });\n        }\n        return this.drained;\n    }\n    isDraining() {\n        return this.draining;\n    }\n    isClosed() {\n        return this.done;\n    }\n    getSubject() {\n        return this.subject;\n    }\n    getMax() {\n        return this.max;\n    }\n    getID() {\n        return this.sid;\n    }\n}\nclass Subscriptions {\n    mux;\n    subs;\n    sidCounter;\n    constructor(){\n        this.sidCounter = 0;\n        this.mux = null;\n        this.subs = new Map();\n    }\n    size() {\n        return this.subs.size;\n    }\n    add(s) {\n        this.sidCounter++;\n        s.sid = this.sidCounter;\n        this.subs.set(s.sid, s);\n        return s;\n    }\n    setMux(s) {\n        this.mux = s;\n        return s;\n    }\n    getMux() {\n        return this.mux;\n    }\n    get(sid) {\n        return this.subs.get(sid);\n    }\n    resub(s) {\n        this.sidCounter++;\n        this.subs.delete(s.sid);\n        s.sid = this.sidCounter;\n        this.subs.set(s.sid, s);\n        return s;\n    }\n    all() {\n        return Array.from(this.subs.values());\n    }\n    cancel(s) {\n        if (s) {\n            s.close();\n            this.subs.delete(s.sid);\n        }\n    }\n    handleError(err) {\n        if (err && err.permissionContext) {\n            const ctx = err.permissionContext;\n            const subs = this.all();\n            let sub;\n            if (ctx.operation === \"subscription\") {\n                sub = subs.find((s)=>{\n                    return s.subject === ctx.subject;\n                });\n            }\n            if (ctx.operation === \"publish\") {\n                sub = subs.find((s)=>{\n                    return s.requestSubject === ctx.subject;\n                });\n            }\n            if (sub) {\n                sub.callback(err, {});\n                sub.close();\n                return sub !== this.mux;\n            }\n        }\n        return false;\n    }\n    close() {\n        this.subs.forEach((sub)=>{\n            sub.close();\n        });\n    }\n}\nclass Heartbeat {\n    ph;\n    interval;\n    maxOut;\n    timer;\n    pendings;\n    constructor(ph, interval, maxOut){\n        this.ph = ph;\n        this.interval = interval;\n        this.maxOut = maxOut;\n        this.pendings = [];\n    }\n    start() {\n        this.cancel();\n        this._schedule();\n    }\n    cancel(stale) {\n        if (this.timer) {\n            clearTimeout(this.timer);\n            this.timer = undefined;\n        }\n        this._reset();\n        if (stale) {\n            this.ph.disconnect();\n        }\n    }\n    _schedule() {\n        this.timer = setTimeout(()=>{\n            this.ph.dispatchStatus({\n                type: DebugEvents.PingTimer,\n                data: `${this.pendings.length + 1}`\n            });\n            if (this.pendings.length === this.maxOut) {\n                this.cancel(true);\n                return;\n            }\n            const ping = deferred();\n            this.ph.flush(ping).then(()=>{\n                this._reset();\n            }).catch(()=>{\n                this.cancel();\n            });\n            this.pendings.push(ping);\n            this._schedule();\n        }, this.interval);\n    }\n    _reset() {\n        this.pendings = this.pendings.filter((p)=>{\n            const d = p;\n            d.resolve();\n            return false;\n        });\n    }\n}\nclass AssertionError extends Error {\n    constructor(msg){\n        super(msg);\n        this.name = \"AssertionError\";\n    }\n}\nfunction assert(cond, msg = \"Assertion failed.\") {\n    if (!cond) {\n        throw new AssertionError(msg);\n    }\n}\nconst MIN_READ = 32 * 1024;\nconst MAX_SIZE = 2 ** 32 - 2;\nfunction copy(src, dst, off = 0) {\n    const r = dst.byteLength - off;\n    if (src.byteLength > r) {\n        src = src.subarray(0, r);\n    }\n    dst.set(src, off);\n    return src.byteLength;\n}\nclass DenoBuffer {\n    _buf;\n    _off;\n    constructor(ab){\n        this._off = 0;\n        if (ab == null) {\n            this._buf = new Uint8Array(0);\n            return;\n        }\n        this._buf = new Uint8Array(ab);\n    }\n    bytes(options = {\n        copy: true\n    }) {\n        if (options.copy === false) return this._buf.subarray(this._off);\n        return this._buf.slice(this._off);\n    }\n    empty() {\n        return this._buf.byteLength <= this._off;\n    }\n    get length() {\n        return this._buf.byteLength - this._off;\n    }\n    get capacity() {\n        return this._buf.buffer.byteLength;\n    }\n    truncate(n) {\n        if (n === 0) {\n            this.reset();\n            return;\n        }\n        if (n < 0 || n > this.length) {\n            throw Error(\"bytes.Buffer: truncation out of range\");\n        }\n        this._reslice(this._off + n);\n    }\n    reset() {\n        this._reslice(0);\n        this._off = 0;\n    }\n    _tryGrowByReslice(n) {\n        const l = this._buf.byteLength;\n        if (n <= this.capacity - l) {\n            this._reslice(l + n);\n            return l;\n        }\n        return -1;\n    }\n    _reslice(len) {\n        assert(len <= this._buf.buffer.byteLength);\n        this._buf = new Uint8Array(this._buf.buffer, 0, len);\n    }\n    readByte() {\n        const a = new Uint8Array(1);\n        if (this.read(a)) {\n            return a[0];\n        }\n        return null;\n    }\n    read(p) {\n        if (this.empty()) {\n            this.reset();\n            if (p.byteLength === 0) {\n                return 0;\n            }\n            return null;\n        }\n        const nread = copy(this._buf.subarray(this._off), p);\n        this._off += nread;\n        return nread;\n    }\n    writeByte(n) {\n        return this.write(Uint8Array.of(n));\n    }\n    writeString(s) {\n        return this.write(TE.encode(s));\n    }\n    write(p) {\n        const m = this._grow(p.byteLength);\n        return copy(p, this._buf, m);\n    }\n    _grow(n) {\n        const m = this.length;\n        if (m === 0 && this._off !== 0) {\n            this.reset();\n        }\n        const i = this._tryGrowByReslice(n);\n        if (i >= 0) {\n            return i;\n        }\n        const c = this.capacity;\n        if (n <= Math.floor(c / 2) - m) {\n            copy(this._buf.subarray(this._off), this._buf);\n        } else if (c + n > MAX_SIZE) {\n            throw new Error(\"The buffer cannot be grown beyond the maximum size.\");\n        } else {\n            const buf = new Uint8Array(Math.min(2 * c + n, MAX_SIZE));\n            copy(this._buf.subarray(this._off), buf);\n            this._buf = buf;\n        }\n        this._off = 0;\n        this._reslice(Math.min(m + n, MAX_SIZE));\n        return m;\n    }\n    grow(n) {\n        if (n < 0) {\n            throw Error(\"Buffer._grow: negative count\");\n        }\n        const m = this._grow(n);\n        this._reslice(m);\n    }\n    readFrom(r) {\n        let n = 0;\n        const tmp = new Uint8Array(MIN_READ);\n        while(true){\n            const shouldGrow = this.capacity - this.length < MIN_READ;\n            const buf = shouldGrow ? tmp : new Uint8Array(this._buf.buffer, this.length);\n            const nread = r.read(buf);\n            if (nread === null) {\n                return n;\n            }\n            if (shouldGrow) this.write(buf.subarray(0, nread));\n            else this._reslice(this.length + nread);\n            n += nread;\n        }\n    }\n}\nvar Kind;\n(function(Kind) {\n    Kind[Kind[\"OK\"] = 0] = \"OK\";\n    Kind[Kind[\"ERR\"] = 1] = \"ERR\";\n    Kind[Kind[\"MSG\"] = 2] = \"MSG\";\n    Kind[Kind[\"INFO\"] = 3] = \"INFO\";\n    Kind[Kind[\"PING\"] = 4] = \"PING\";\n    Kind[Kind[\"PONG\"] = 5] = \"PONG\";\n})(Kind || (Kind = {}));\nfunction newMsgArg() {\n    const ma = {};\n    ma.sid = -1;\n    ma.hdr = -1;\n    ma.size = -1;\n    return ma;\n}\nconst ASCII_0 = 48;\nclass Parser {\n    dispatcher;\n    state;\n    as;\n    drop;\n    hdr;\n    ma;\n    argBuf;\n    msgBuf;\n    constructor(dispatcher){\n        this.dispatcher = dispatcher;\n        this.state = State.OP_START;\n        this.as = 0;\n        this.drop = 0;\n        this.hdr = 0;\n    }\n    parse(buf) {\n        let i;\n        for(i = 0; i < buf.length; i++){\n            const b = buf[i];\n            switch(this.state){\n                case State.OP_START:\n                    switch(b){\n                        case cc.M:\n                        case cc.m:\n                            this.state = State.OP_M;\n                            this.hdr = -1;\n                            this.ma = newMsgArg();\n                            break;\n                        case cc.H:\n                        case cc.h:\n                            this.state = State.OP_H;\n                            this.hdr = 0;\n                            this.ma = newMsgArg();\n                            break;\n                        case cc.P:\n                        case cc.p:\n                            this.state = State.OP_P;\n                            break;\n                        case cc.PLUS:\n                            this.state = State.OP_PLUS;\n                            break;\n                        case cc.MINUS:\n                            this.state = State.OP_MINUS;\n                            break;\n                        case cc.I:\n                        case cc.i:\n                            this.state = State.OP_I;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_H:\n                    switch(b){\n                        case cc.M:\n                        case cc.m:\n                            this.state = State.OP_M;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_M:\n                    switch(b){\n                        case cc.S:\n                        case cc.s:\n                            this.state = State.OP_MS;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_MS:\n                    switch(b){\n                        case cc.G:\n                        case cc.g:\n                            this.state = State.OP_MSG;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_MSG:\n                    switch(b){\n                        case cc.SPACE:\n                        case cc.TAB:\n                            this.state = State.OP_MSG_SPC;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_MSG_SPC:\n                    switch(b){\n                        case cc.SPACE:\n                        case cc.TAB:\n                            continue;\n                        default:\n                            this.state = State.MSG_ARG;\n                            this.as = i;\n                    }\n                    break;\n                case State.MSG_ARG:\n                    switch(b){\n                        case cc.CR:\n                            this.drop = 1;\n                            break;\n                        case cc.NL:\n                            {\n                                const arg = this.argBuf ? this.argBuf.bytes() : buf.subarray(this.as, i - this.drop);\n                                this.processMsgArgs(arg);\n                                this.drop = 0;\n                                this.as = i + 1;\n                                this.state = State.MSG_PAYLOAD;\n                                i = this.as + this.ma.size - 1;\n                                break;\n                            }\n                        default:\n                            if (this.argBuf) {\n                                this.argBuf.writeByte(b);\n                            }\n                    }\n                    break;\n                case State.MSG_PAYLOAD:\n                    if (this.msgBuf) {\n                        if (this.msgBuf.length >= this.ma.size) {\n                            const data = this.msgBuf.bytes({\n                                copy: false\n                            });\n                            this.dispatcher.push({\n                                kind: Kind.MSG,\n                                msg: this.ma,\n                                data: data\n                            });\n                            this.argBuf = undefined;\n                            this.msgBuf = undefined;\n                            this.state = State.MSG_END;\n                        } else {\n                            let toCopy = this.ma.size - this.msgBuf.length;\n                            const avail = buf.length - i;\n                            if (avail < toCopy) {\n                                toCopy = avail;\n                            }\n                            if (toCopy > 0) {\n                                this.msgBuf.write(buf.subarray(i, i + toCopy));\n                                i = i + toCopy - 1;\n                            } else {\n                                this.msgBuf.writeByte(b);\n                            }\n                        }\n                    } else if (i - this.as >= this.ma.size) {\n                        this.dispatcher.push({\n                            kind: Kind.MSG,\n                            msg: this.ma,\n                            data: buf.subarray(this.as, i)\n                        });\n                        this.argBuf = undefined;\n                        this.msgBuf = undefined;\n                        this.state = State.MSG_END;\n                    }\n                    break;\n                case State.MSG_END:\n                    switch(b){\n                        case cc.NL:\n                            this.drop = 0;\n                            this.as = i + 1;\n                            this.state = State.OP_START;\n                            break;\n                        default:\n                            continue;\n                    }\n                    break;\n                case State.OP_PLUS:\n                    switch(b){\n                        case cc.O:\n                        case cc.o:\n                            this.state = State.OP_PLUS_O;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_PLUS_O:\n                    switch(b){\n                        case cc.K:\n                        case cc.k:\n                            this.state = State.OP_PLUS_OK;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_PLUS_OK:\n                    switch(b){\n                        case cc.NL:\n                            this.dispatcher.push({\n                                kind: Kind.OK\n                            });\n                            this.drop = 0;\n                            this.state = State.OP_START;\n                            break;\n                    }\n                    break;\n                case State.OP_MINUS:\n                    switch(b){\n                        case cc.E:\n                        case cc.e:\n                            this.state = State.OP_MINUS_E;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_MINUS_E:\n                    switch(b){\n                        case cc.R:\n                        case cc.r:\n                            this.state = State.OP_MINUS_ER;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_MINUS_ER:\n                    switch(b){\n                        case cc.R:\n                        case cc.r:\n                            this.state = State.OP_MINUS_ERR;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_MINUS_ERR:\n                    switch(b){\n                        case cc.SPACE:\n                        case cc.TAB:\n                            this.state = State.OP_MINUS_ERR_SPC;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_MINUS_ERR_SPC:\n                    switch(b){\n                        case cc.SPACE:\n                        case cc.TAB:\n                            continue;\n                        default:\n                            this.state = State.MINUS_ERR_ARG;\n                            this.as = i;\n                    }\n                    break;\n                case State.MINUS_ERR_ARG:\n                    switch(b){\n                        case cc.CR:\n                            this.drop = 1;\n                            break;\n                        case cc.NL:\n                            {\n                                let arg1;\n                                if (this.argBuf) {\n                                    arg1 = this.argBuf.bytes();\n                                    this.argBuf = undefined;\n                                } else {\n                                    arg1 = buf.subarray(this.as, i - this.drop);\n                                }\n                                this.dispatcher.push({\n                                    kind: Kind.ERR,\n                                    data: arg1\n                                });\n                                this.drop = 0;\n                                this.as = i + 1;\n                                this.state = State.OP_START;\n                                break;\n                            }\n                        default:\n                            if (this.argBuf) {\n                                this.argBuf.write(Uint8Array.of(b));\n                            }\n                    }\n                    break;\n                case State.OP_P:\n                    switch(b){\n                        case cc.I:\n                        case cc.i:\n                            this.state = State.OP_PI;\n                            break;\n                        case cc.O:\n                        case cc.o:\n                            this.state = State.OP_PO;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_PO:\n                    switch(b){\n                        case cc.N:\n                        case cc.n:\n                            this.state = State.OP_PON;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_PON:\n                    switch(b){\n                        case cc.G:\n                        case cc.g:\n                            this.state = State.OP_PONG;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_PONG:\n                    switch(b){\n                        case cc.NL:\n                            this.dispatcher.push({\n                                kind: Kind.PONG\n                            });\n                            this.drop = 0;\n                            this.state = State.OP_START;\n                            break;\n                    }\n                    break;\n                case State.OP_PI:\n                    switch(b){\n                        case cc.N:\n                        case cc.n:\n                            this.state = State.OP_PIN;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_PIN:\n                    switch(b){\n                        case cc.G:\n                        case cc.g:\n                            this.state = State.OP_PING;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_PING:\n                    switch(b){\n                        case cc.NL:\n                            this.dispatcher.push({\n                                kind: Kind.PING\n                            });\n                            this.drop = 0;\n                            this.state = State.OP_START;\n                            break;\n                    }\n                    break;\n                case State.OP_I:\n                    switch(b){\n                        case cc.N:\n                        case cc.n:\n                            this.state = State.OP_IN;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_IN:\n                    switch(b){\n                        case cc.F:\n                        case cc.f:\n                            this.state = State.OP_INF;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_INF:\n                    switch(b){\n                        case cc.O:\n                        case cc.o:\n                            this.state = State.OP_INFO;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_INFO:\n                    switch(b){\n                        case cc.SPACE:\n                        case cc.TAB:\n                            this.state = State.OP_INFO_SPC;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_INFO_SPC:\n                    switch(b){\n                        case cc.SPACE:\n                        case cc.TAB:\n                            continue;\n                        default:\n                            this.state = State.INFO_ARG;\n                            this.as = i;\n                    }\n                    break;\n                case State.INFO_ARG:\n                    switch(b){\n                        case cc.CR:\n                            this.drop = 1;\n                            break;\n                        case cc.NL:\n                            {\n                                let arg2;\n                                if (this.argBuf) {\n                                    arg2 = this.argBuf.bytes();\n                                    this.argBuf = undefined;\n                                } else {\n                                    arg2 = buf.subarray(this.as, i - this.drop);\n                                }\n                                this.dispatcher.push({\n                                    kind: Kind.INFO,\n                                    data: arg2\n                                });\n                                this.drop = 0;\n                                this.as = i + 1;\n                                this.state = State.OP_START;\n                                break;\n                            }\n                        default:\n                            if (this.argBuf) {\n                                this.argBuf.writeByte(b);\n                            }\n                    }\n                    break;\n                default:\n                    throw this.fail(buf.subarray(i));\n            }\n        }\n        if ((this.state === State.MSG_ARG || this.state === State.MINUS_ERR_ARG || this.state === State.INFO_ARG) && !this.argBuf) {\n            this.argBuf = new DenoBuffer(buf.subarray(this.as, i - this.drop));\n        }\n        if (this.state === State.MSG_PAYLOAD && !this.msgBuf) {\n            if (!this.argBuf) {\n                this.cloneMsgArg();\n            }\n            this.msgBuf = new DenoBuffer(buf.subarray(this.as));\n        }\n    }\n    cloneMsgArg() {\n        const s = this.ma.subject.length;\n        const r = this.ma.reply ? this.ma.reply.length : 0;\n        const buf = new Uint8Array(s + r);\n        buf.set(this.ma.subject);\n        if (this.ma.reply) {\n            buf.set(this.ma.reply, s);\n        }\n        this.argBuf = new DenoBuffer(buf);\n        this.ma.subject = buf.subarray(0, s);\n        if (this.ma.reply) {\n            this.ma.reply = buf.subarray(s);\n        }\n    }\n    processMsgArgs(arg) {\n        if (this.hdr >= 0) {\n            return this.processHeaderMsgArgs(arg);\n        }\n        const args = [];\n        let start = -1;\n        for(let i = 0; i < arg.length; i++){\n            const b = arg[i];\n            switch(b){\n                case cc.SPACE:\n                case cc.TAB:\n                case cc.CR:\n                case cc.NL:\n                    if (start >= 0) {\n                        args.push(arg.subarray(start, i));\n                        start = -1;\n                    }\n                    break;\n                default:\n                    if (start < 0) {\n                        start = i;\n                    }\n            }\n        }\n        if (start >= 0) {\n            args.push(arg.subarray(start));\n        }\n        switch(args.length){\n            case 3:\n                this.ma.subject = args[0];\n                this.ma.sid = this.protoParseInt(args[1]);\n                this.ma.reply = undefined;\n                this.ma.size = this.protoParseInt(args[2]);\n                break;\n            case 4:\n                this.ma.subject = args[0];\n                this.ma.sid = this.protoParseInt(args[1]);\n                this.ma.reply = args[2];\n                this.ma.size = this.protoParseInt(args[3]);\n                break;\n            default:\n                throw this.fail(arg, \"processMsgArgs Parse Error\");\n        }\n        if (this.ma.sid < 0) {\n            throw this.fail(arg, \"processMsgArgs Bad or Missing Sid Error\");\n        }\n        if (this.ma.size < 0) {\n            throw this.fail(arg, \"processMsgArgs Bad or Missing Size Error\");\n        }\n    }\n    fail(data, label = \"\") {\n        if (!label) {\n            label = `parse error [${this.state}]`;\n        } else {\n            label = `${label} [${this.state}]`;\n        }\n        return new Error(`${label}: ${TD.decode(data)}`);\n    }\n    processHeaderMsgArgs(arg) {\n        const args = [];\n        let start = -1;\n        for(let i = 0; i < arg.length; i++){\n            const b = arg[i];\n            switch(b){\n                case cc.SPACE:\n                case cc.TAB:\n                case cc.CR:\n                case cc.NL:\n                    if (start >= 0) {\n                        args.push(arg.subarray(start, i));\n                        start = -1;\n                    }\n                    break;\n                default:\n                    if (start < 0) {\n                        start = i;\n                    }\n            }\n        }\n        if (start >= 0) {\n            args.push(arg.subarray(start));\n        }\n        switch(args.length){\n            case 4:\n                this.ma.subject = args[0];\n                this.ma.sid = this.protoParseInt(args[1]);\n                this.ma.reply = undefined;\n                this.ma.hdr = this.protoParseInt(args[2]);\n                this.ma.size = this.protoParseInt(args[3]);\n                break;\n            case 5:\n                this.ma.subject = args[0];\n                this.ma.sid = this.protoParseInt(args[1]);\n                this.ma.reply = args[2];\n                this.ma.hdr = this.protoParseInt(args[3]);\n                this.ma.size = this.protoParseInt(args[4]);\n                break;\n            default:\n                throw this.fail(arg, \"processHeaderMsgArgs Parse Error\");\n        }\n        if (this.ma.sid < 0) {\n            throw this.fail(arg, \"processHeaderMsgArgs Bad or Missing Sid Error\");\n        }\n        if (this.ma.hdr < 0 || this.ma.hdr > this.ma.size) {\n            throw this.fail(arg, \"processHeaderMsgArgs Bad or Missing Header Size Error\");\n        }\n        if (this.ma.size < 0) {\n            throw this.fail(arg, \"processHeaderMsgArgs Bad or Missing Size Error\");\n        }\n    }\n    protoParseInt(a) {\n        if (a.length === 0) {\n            return -1;\n        }\n        let n = 0;\n        for(let i = 0; i < a.length; i++){\n            if (a[i] < 48 || a[i] > 57) {\n                return -1;\n            }\n            n = n * 10 + (a[i] - ASCII_0);\n        }\n        return n;\n    }\n}\nvar State;\n(function(State) {\n    State[State[\"OP_START\"] = 0] = \"OP_START\";\n    State[State[\"OP_PLUS\"] = 1] = \"OP_PLUS\";\n    State[State[\"OP_PLUS_O\"] = 2] = \"OP_PLUS_O\";\n    State[State[\"OP_PLUS_OK\"] = 3] = \"OP_PLUS_OK\";\n    State[State[\"OP_MINUS\"] = 4] = \"OP_MINUS\";\n    State[State[\"OP_MINUS_E\"] = 5] = \"OP_MINUS_E\";\n    State[State[\"OP_MINUS_ER\"] = 6] = \"OP_MINUS_ER\";\n    State[State[\"OP_MINUS_ERR\"] = 7] = \"OP_MINUS_ERR\";\n    State[State[\"OP_MINUS_ERR_SPC\"] = 8] = \"OP_MINUS_ERR_SPC\";\n    State[State[\"MINUS_ERR_ARG\"] = 9] = \"MINUS_ERR_ARG\";\n    State[State[\"OP_M\"] = 10] = \"OP_M\";\n    State[State[\"OP_MS\"] = 11] = \"OP_MS\";\n    State[State[\"OP_MSG\"] = 12] = \"OP_MSG\";\n    State[State[\"OP_MSG_SPC\"] = 13] = \"OP_MSG_SPC\";\n    State[State[\"MSG_ARG\"] = 14] = \"MSG_ARG\";\n    State[State[\"MSG_PAYLOAD\"] = 15] = \"MSG_PAYLOAD\";\n    State[State[\"MSG_END\"] = 16] = \"MSG_END\";\n    State[State[\"OP_H\"] = 17] = \"OP_H\";\n    State[State[\"OP_P\"] = 18] = \"OP_P\";\n    State[State[\"OP_PI\"] = 19] = \"OP_PI\";\n    State[State[\"OP_PIN\"] = 20] = \"OP_PIN\";\n    State[State[\"OP_PING\"] = 21] = \"OP_PING\";\n    State[State[\"OP_PO\"] = 22] = \"OP_PO\";\n    State[State[\"OP_PON\"] = 23] = \"OP_PON\";\n    State[State[\"OP_PONG\"] = 24] = \"OP_PONG\";\n    State[State[\"OP_I\"] = 25] = \"OP_I\";\n    State[State[\"OP_IN\"] = 26] = \"OP_IN\";\n    State[State[\"OP_INF\"] = 27] = \"OP_INF\";\n    State[State[\"OP_INFO\"] = 28] = \"OP_INFO\";\n    State[State[\"OP_INFO_SPC\"] = 29] = \"OP_INFO_SPC\";\n    State[State[\"INFO_ARG\"] = 30] = \"INFO_ARG\";\n})(State || (State = {}));\nvar cc;\n(function(cc) {\n    cc[cc[\"CR\"] = \"\\r\".charCodeAt(0)] = \"CR\";\n    cc[cc[\"E\"] = \"E\".charCodeAt(0)] = \"E\";\n    cc[cc[\"e\"] = \"e\".charCodeAt(0)] = \"e\";\n    cc[cc[\"F\"] = \"F\".charCodeAt(0)] = \"F\";\n    cc[cc[\"f\"] = \"f\".charCodeAt(0)] = \"f\";\n    cc[cc[\"G\"] = \"G\".charCodeAt(0)] = \"G\";\n    cc[cc[\"g\"] = \"g\".charCodeAt(0)] = \"g\";\n    cc[cc[\"H\"] = \"H\".charCodeAt(0)] = \"H\";\n    cc[cc[\"h\"] = \"h\".charCodeAt(0)] = \"h\";\n    cc[cc[\"I\"] = \"I\".charCodeAt(0)] = \"I\";\n    cc[cc[\"i\"] = \"i\".charCodeAt(0)] = \"i\";\n    cc[cc[\"K\"] = \"K\".charCodeAt(0)] = \"K\";\n    cc[cc[\"k\"] = \"k\".charCodeAt(0)] = \"k\";\n    cc[cc[\"M\"] = \"M\".charCodeAt(0)] = \"M\";\n    cc[cc[\"m\"] = \"m\".charCodeAt(0)] = \"m\";\n    cc[cc[\"MINUS\"] = \"-\".charCodeAt(0)] = \"MINUS\";\n    cc[cc[\"N\"] = \"N\".charCodeAt(0)] = \"N\";\n    cc[cc[\"n\"] = \"n\".charCodeAt(0)] = \"n\";\n    cc[cc[\"NL\"] = \"\\n\".charCodeAt(0)] = \"NL\";\n    cc[cc[\"O\"] = \"O\".charCodeAt(0)] = \"O\";\n    cc[cc[\"o\"] = \"o\".charCodeAt(0)] = \"o\";\n    cc[cc[\"P\"] = \"P\".charCodeAt(0)] = \"P\";\n    cc[cc[\"p\"] = \"p\".charCodeAt(0)] = \"p\";\n    cc[cc[\"PLUS\"] = \"+\".charCodeAt(0)] = \"PLUS\";\n    cc[cc[\"R\"] = \"R\".charCodeAt(0)] = \"R\";\n    cc[cc[\"r\"] = \"r\".charCodeAt(0)] = \"r\";\n    cc[cc[\"S\"] = \"S\".charCodeAt(0)] = \"S\";\n    cc[cc[\"s\"] = \"s\".charCodeAt(0)] = \"s\";\n    cc[cc[\"SPACE\"] = \" \".charCodeAt(0)] = \"SPACE\";\n    cc[cc[\"TAB\"] = \"\\t\".charCodeAt(0)] = \"TAB\";\n})(cc || (cc = {}));\nconst FLUSH_THRESHOLD = 1024 * 32;\nconst INFO = /^INFO\\s+([^\\r\\n]+)\\r\\n/i;\nfunction createInbox(prefix = \"\") {\n    prefix = prefix || \"_INBOX\";\n    if (typeof prefix !== \"string\") {\n        throw new Error(\"prefix must be a string\");\n    }\n    return `${prefix}.${nuid.next()}`;\n}\nclass MuxSubscription {\n    baseInbox;\n    reqs;\n    constructor(){\n        this.reqs = new Map();\n    }\n    size() {\n        return this.reqs.size;\n    }\n    init(prefix) {\n        this.baseInbox = `${createInbox(prefix)}.`;\n        return this.baseInbox;\n    }\n    add(r) {\n        if (!isNaN(r.received)) {\n            r.received = 0;\n        }\n        this.reqs.set(r.token, r);\n    }\n    get(token) {\n        return this.reqs.get(token);\n    }\n    cancel(r) {\n        this.reqs.delete(r.token);\n    }\n    getToken(m) {\n        const s = m.subject || \"\";\n        if (s.indexOf(this.baseInbox) === 0) {\n            return s.substring(this.baseInbox.length);\n        }\n        return null;\n    }\n    all() {\n        return Array.from(this.reqs.values());\n    }\n    handleError(isMuxPermissionError, err) {\n        if (err && err.permissionContext) {\n            if (isMuxPermissionError) {\n                this.all().forEach((r)=>{\n                    r.resolver(err, {});\n                });\n                return true;\n            }\n            const ctx = err.permissionContext;\n            if (ctx.operation === \"publish\") {\n                const req = this.all().find((s)=>{\n                    return s.requestSubject === ctx.subject;\n                });\n                if (req) {\n                    req.resolver(err, {});\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    dispatcher() {\n        return (err, m)=>{\n            const token = this.getToken(m);\n            if (token) {\n                const r = this.get(token);\n                if (r) {\n                    if (err === null && m.headers) {\n                        err = isRequestError(m);\n                    }\n                    r.resolver(err, m);\n                }\n            }\n        };\n    }\n    close() {\n        const err = NatsError.errorForCode(ErrorCode.Timeout);\n        this.reqs.forEach((req)=>{\n            req.resolver(err, {});\n        });\n    }\n}\nconst PONG_CMD = encode(\"PONG\\r\\n\");\nconst PING_CMD = encode(\"PING\\r\\n\");\nclass Connect {\n    echo;\n    no_responders;\n    protocol;\n    verbose;\n    pedantic;\n    jwt;\n    nkey;\n    sig;\n    user;\n    pass;\n    auth_token;\n    tls_required;\n    name;\n    lang;\n    version;\n    headers;\n    constructor(transport, opts, nonce){\n        this.protocol = 1;\n        this.version = transport.version;\n        this.lang = transport.lang;\n        this.echo = opts.noEcho ? false : undefined;\n        this.verbose = opts.verbose;\n        this.pedantic = opts.pedantic;\n        this.tls_required = opts.tls ? true : undefined;\n        this.name = opts.name;\n        const creds = (opts && opts.authenticator ? opts.authenticator(nonce) : {}) || {};\n        extend(this, creds);\n    }\n}\nclass ProtocolHandler {\n    connected;\n    connectedOnce;\n    infoReceived;\n    info;\n    muxSubscriptions;\n    options;\n    outbound;\n    pongs;\n    subscriptions;\n    transport;\n    noMorePublishing;\n    connectError;\n    publisher;\n    _closed;\n    closed;\n    listeners;\n    heartbeats;\n    parser;\n    outMsgs;\n    inMsgs;\n    outBytes;\n    inBytes;\n    pendingLimit;\n    lastError;\n    abortReconnect;\n    servers;\n    server;\n    features;\n    constructor(options, publisher){\n        this._closed = false;\n        this.connected = false;\n        this.connectedOnce = false;\n        this.infoReceived = false;\n        this.noMorePublishing = false;\n        this.abortReconnect = false;\n        this.listeners = [];\n        this.pendingLimit = FLUSH_THRESHOLD;\n        this.outMsgs = 0;\n        this.inMsgs = 0;\n        this.outBytes = 0;\n        this.inBytes = 0;\n        this.options = options;\n        this.publisher = publisher;\n        this.subscriptions = new Subscriptions();\n        this.muxSubscriptions = new MuxSubscription();\n        this.outbound = new DataBuffer();\n        this.pongs = [];\n        this.pendingLimit = options.pendingLimit || this.pendingLimit;\n        this.features = new Features({\n            major: 0,\n            minor: 0,\n            micro: 0\n        });\n        const servers = typeof options.servers === \"string\" ? [\n            options.servers\n        ] : options.servers;\n        this.servers = new Servers(servers, {\n            randomize: !options.noRandomize\n        });\n        this.closed = deferred();\n        this.parser = new Parser(this);\n        this.heartbeats = new Heartbeat(this, this.options.pingInterval || DEFAULT_PING_INTERVAL, this.options.maxPingOut || DEFAULT_MAX_PING_OUT);\n    }\n    resetOutbound() {\n        this.outbound.reset();\n        const pongs = this.pongs;\n        this.pongs = [];\n        pongs.forEach((p)=>{\n            p.reject(NatsError.errorForCode(ErrorCode.Disconnect));\n        });\n        this.parser = new Parser(this);\n        this.infoReceived = false;\n    }\n    dispatchStatus(status) {\n        this.listeners.forEach((q)=>{\n            q.push(status);\n        });\n    }\n    status() {\n        const iter = new QueuedIteratorImpl();\n        this.listeners.push(iter);\n        return iter;\n    }\n    prepare() {\n        this.info = undefined;\n        this.resetOutbound();\n        const pong = deferred();\n        this.pongs.unshift(pong);\n        this.connectError = (err)=>{\n            pong.reject(err);\n        };\n        this.transport = newTransport();\n        this.transport.closed().then(async (_err)=>{\n            this.connected = false;\n            if (!this.isClosed()) {\n                await this.disconnected(this.transport.closeError);\n                return;\n            }\n        });\n        return pong;\n    }\n    disconnect() {\n        this.dispatchStatus({\n            type: DebugEvents.StaleConnection,\n            data: \"\"\n        });\n        this.transport.disconnect();\n    }\n    async disconnected(_err) {\n        this.dispatchStatus({\n            type: Events.Disconnect,\n            data: this.servers.getCurrentServer().toString()\n        });\n        if (this.options.reconnect) {\n            await this.dialLoop().then(()=>{\n                this.dispatchStatus({\n                    type: Events.Reconnect,\n                    data: this.servers.getCurrentServer().toString()\n                });\n            }).catch((err)=>{\n                this._close(err);\n            });\n        } else {\n            await this._close();\n        }\n    }\n    async dial(srv) {\n        const pong = this.prepare();\n        let timer;\n        try {\n            timer = timeout(this.options.timeout || 20000);\n            const cp = this.transport.connect(srv, this.options);\n            await Promise.race([\n                cp,\n                timer\n            ]);\n            (async ()=>{\n                try {\n                    for await (const b of this.transport){\n                        this.parser.parse(b);\n                    }\n                } catch (err) {\n                    console.log(\"reader closed\", err);\n                }\n            })().then();\n        } catch (err) {\n            pong.reject(err);\n        }\n        try {\n            await Promise.race([\n                timer,\n                pong\n            ]);\n            if (timer) {\n                timer.cancel();\n            }\n            this.connected = true;\n            this.connectError = undefined;\n            this.sendSubscriptions();\n            this.connectedOnce = true;\n            this.server.didConnect = true;\n            this.server.reconnects = 0;\n            this.flushPending();\n            this.heartbeats.start();\n        } catch (err1) {\n            if (timer) {\n                timer.cancel();\n            }\n            await this.transport.close(err1);\n            throw err1;\n        }\n    }\n    async _doDial(srv) {\n        const alts = await srv.resolve({\n            fn: getResolveFn(),\n            randomize: !this.options.noRandomize\n        });\n        let lastErr = null;\n        for (const a of alts){\n            try {\n                lastErr = null;\n                this.dispatchStatus({\n                    type: DebugEvents.Reconnecting,\n                    data: a.toString()\n                });\n                await this.dial(a);\n                return;\n            } catch (err) {\n                lastErr = err;\n            }\n        }\n        throw lastErr;\n    }\n    async dialLoop() {\n        let lastError;\n        while(true){\n            const wait = this.options.reconnectDelayHandler ? this.options.reconnectDelayHandler() : DEFAULT_RECONNECT_TIME_WAIT;\n            let maxWait = wait;\n            const srv = this.selectServer();\n            if (!srv || this.abortReconnect) {\n                if (lastError) {\n                    throw lastError;\n                } else if (this.lastError) {\n                    throw this.lastError;\n                } else {\n                    throw NatsError.errorForCode(ErrorCode.ConnectionRefused);\n                }\n            }\n            const now = Date.now();\n            if (srv.lastConnect === 0 || srv.lastConnect + wait <= now) {\n                srv.lastConnect = Date.now();\n                try {\n                    await this._doDial(srv);\n                    break;\n                } catch (err) {\n                    lastError = err;\n                    if (!this.connectedOnce) {\n                        if (this.options.waitOnFirstConnect) {\n                            continue;\n                        }\n                        this.servers.removeCurrentServer();\n                    }\n                    srv.reconnects++;\n                    const mra = this.options.maxReconnectAttempts || 0;\n                    if (mra !== -1 && srv.reconnects >= mra) {\n                        this.servers.removeCurrentServer();\n                    }\n                }\n            } else {\n                maxWait = Math.min(maxWait, srv.lastConnect + wait - now);\n                await delay(maxWait);\n            }\n        }\n    }\n    static async connect(options, publisher) {\n        const h = new ProtocolHandler(options, publisher);\n        await h.dialLoop();\n        return h;\n    }\n    static toError(s) {\n        const t = s ? s.toLowerCase() : \"\";\n        if (t.indexOf(\"permissions violation\") !== -1) {\n            const err = new NatsError(s, ErrorCode.PermissionsViolation);\n            const m = s.match(/(Publish|Subscription) to \"(\\S+)\"/);\n            if (m) {\n                err.permissionContext = {\n                    operation: m[1].toLowerCase(),\n                    subject: m[2]\n                };\n            }\n            return err;\n        } else if (t.indexOf(\"authorization violation\") !== -1) {\n            return new NatsError(s, ErrorCode.AuthorizationViolation);\n        } else if (t.indexOf(\"user authentication expired\") !== -1) {\n            return new NatsError(s, ErrorCode.AuthenticationExpired);\n        } else {\n            return new NatsError(s, ErrorCode.ProtocolError);\n        }\n    }\n    processMsg(msg, data) {\n        this.inMsgs++;\n        this.inBytes += data.length;\n        if (!this.subscriptions.sidCounter) {\n            return;\n        }\n        const sub = this.subscriptions.get(msg.sid);\n        if (!sub) {\n            return;\n        }\n        sub.received += 1;\n        if (sub.callback) {\n            sub.callback(null, new MsgImpl(msg, data, this));\n        }\n        if (sub.max !== undefined && sub.received >= sub.max) {\n            sub.unsubscribe();\n        }\n    }\n    async processError(m) {\n        const s = decode(m);\n        const err = ProtocolHandler.toError(s);\n        let isMuxPermissionError = false;\n        const status = {\n            type: Events.Error,\n            data: err.code\n        };\n        if (err.permissionContext) {\n            status.permissionContext = err.permissionContext;\n            const mux = this.subscriptions.getMux();\n            isMuxPermissionError = mux?.subject === err.permissionContext.subject;\n        }\n        this.subscriptions.handleError(err);\n        this.muxSubscriptions.handleError(isMuxPermissionError, err);\n        if (isMuxPermissionError) {\n            this.subscriptions.setMux(null);\n        }\n        this.dispatchStatus(status);\n        await this.handleError(err);\n    }\n    async handleError(err) {\n        if (err.isAuthError()) {\n            this.handleAuthError(err);\n        }\n        if (err.isProtocolError()) {\n            await this._close(err);\n        }\n        this.lastError = err;\n    }\n    handleAuthError(err) {\n        if (this.lastError && err.code === this.lastError.code) {\n            this.abortReconnect = true;\n        }\n        if (this.connectError) {\n            this.connectError(err);\n        } else {\n            this.disconnect();\n        }\n    }\n    processPing() {\n        this.transport.send(PONG_CMD);\n    }\n    processPong() {\n        const cb = this.pongs.shift();\n        if (cb) {\n            cb.resolve();\n        }\n    }\n    processInfo(m) {\n        const info = JSON.parse(decode(m));\n        this.info = info;\n        const updates = this.options && this.options.ignoreClusterUpdates ? undefined : this.servers.update(info);\n        if (!this.infoReceived) {\n            this.features = new Features(parseSemVer(info.version));\n            this.infoReceived = true;\n            if (this.transport.isEncrypted()) {\n                this.servers.updateTLSName();\n            }\n            const { version , lang  } = this.transport;\n            try {\n                const c = new Connect({\n                    version,\n                    lang\n                }, this.options, info.nonce);\n                if (info.headers) {\n                    c.headers = true;\n                    c.no_responders = true;\n                }\n                const cs = JSON.stringify(c);\n                this.transport.send(encode(`CONNECT ${cs}${CR_LF}`));\n                this.transport.send(PING_CMD);\n            } catch (err) {\n                this._close(NatsError.errorForCode(ErrorCode.BadAuthentication, err));\n            }\n        }\n        if (updates) {\n            this.dispatchStatus({\n                type: Events.Update,\n                data: updates\n            });\n        }\n        const ldm = info.ldm !== undefined ? info.ldm : false;\n        if (ldm) {\n            this.dispatchStatus({\n                type: Events.LDM,\n                data: this.servers.getCurrentServer().toString()\n            });\n        }\n    }\n    push(e) {\n        switch(e.kind){\n            case Kind.MSG:\n                {\n                    const { msg , data  } = e;\n                    this.processMsg(msg, data);\n                    break;\n                }\n            case Kind.OK:\n                break;\n            case Kind.ERR:\n                this.processError(e.data);\n                break;\n            case Kind.PING:\n                this.processPing();\n                break;\n            case Kind.PONG:\n                this.processPong();\n                break;\n            case Kind.INFO:\n                this.processInfo(e.data);\n                break;\n        }\n    }\n    sendCommand(cmd, ...payloads) {\n        const len = this.outbound.length();\n        let buf;\n        if (typeof cmd === \"string\") {\n            buf = encode(cmd);\n        } else {\n            buf = cmd;\n        }\n        this.outbound.fill(buf, ...payloads);\n        if (len === 0) {\n            setTimeout(()=>{\n                this.flushPending();\n            });\n        } else if (this.outbound.size() >= this.pendingLimit) {\n            this.flushPending();\n        }\n    }\n    publish(subject, data, options) {\n        let len = data.length;\n        options = options || {};\n        options.reply = options.reply || \"\";\n        let headers = Empty;\n        let hlen = 0;\n        if (options.headers) {\n            if (this.info && !this.info.headers) {\n                throw new NatsError(\"headers\", ErrorCode.ServerOptionNotAvailable);\n            }\n            const hdrs = options.headers;\n            headers = hdrs.encode();\n            hlen = headers.length;\n            len = data.length + hlen;\n        }\n        if (this.info && len > this.info.max_payload) {\n            throw NatsError.errorForCode(ErrorCode.MaxPayloadExceeded);\n        }\n        this.outBytes += len;\n        this.outMsgs++;\n        let proto;\n        if (options.headers) {\n            if (options.reply) {\n                proto = `HPUB ${subject} ${options.reply} ${hlen} ${len}${CR_LF}`;\n            } else {\n                proto = `HPUB ${subject} ${hlen} ${len}\\r\\n`;\n            }\n            this.sendCommand(proto, headers, data, CRLF);\n        } else {\n            if (options.reply) {\n                proto = `PUB ${subject} ${options.reply} ${len}\\r\\n`;\n            } else {\n                proto = `PUB ${subject} ${len}\\r\\n`;\n            }\n            this.sendCommand(proto, data, CRLF);\n        }\n    }\n    request(r) {\n        this.initMux();\n        this.muxSubscriptions.add(r);\n        return r;\n    }\n    subscribe(s) {\n        this.subscriptions.add(s);\n        this._subunsub(s);\n        return s;\n    }\n    _sub(s) {\n        if (s.queue) {\n            this.sendCommand(`SUB ${s.subject} ${s.queue} ${s.sid}\\r\\n`);\n        } else {\n            this.sendCommand(`SUB ${s.subject} ${s.sid}\\r\\n`);\n        }\n    }\n    _subunsub(s) {\n        this._sub(s);\n        if (s.max) {\n            this.unsubscribe(s, s.max);\n        }\n        return s;\n    }\n    unsubscribe(s, max) {\n        this.unsub(s, max);\n        if (s.max === undefined || s.received >= s.max) {\n            this.subscriptions.cancel(s);\n        }\n    }\n    unsub(s, max) {\n        if (!s || this.isClosed()) {\n            return;\n        }\n        if (max) {\n            this.sendCommand(`UNSUB ${s.sid} ${max}${CR_LF}`);\n        } else {\n            this.sendCommand(`UNSUB ${s.sid}${CR_LF}`);\n        }\n        s.max = max;\n    }\n    resub(s, subject) {\n        if (!s || this.isClosed()) {\n            return;\n        }\n        s.subject = subject;\n        this.subscriptions.resub(s);\n        this._sub(s);\n    }\n    flush(p) {\n        if (!p) {\n            p = deferred();\n        }\n        this.pongs.push(p);\n        this.sendCommand(PING_CMD);\n        return p;\n    }\n    sendSubscriptions() {\n        const cmds = [];\n        this.subscriptions.all().forEach((s)=>{\n            const sub = s;\n            if (sub.queue) {\n                cmds.push(`SUB ${sub.subject} ${sub.queue} ${sub.sid}${CR_LF}`);\n            } else {\n                cmds.push(`SUB ${sub.subject} ${sub.sid}${CR_LF}`);\n            }\n        });\n        if (cmds.length) {\n            this.transport.send(encode(cmds.join(\"\")));\n        }\n    }\n    async _close(err) {\n        if (this._closed) {\n            return;\n        }\n        this.heartbeats.cancel();\n        if (this.connectError) {\n            this.connectError(err);\n            this.connectError = undefined;\n        }\n        this.muxSubscriptions.close();\n        this.subscriptions.close();\n        this.listeners.forEach((l)=>{\n            l.stop();\n        });\n        this._closed = true;\n        await this.transport.close(err);\n        await this.closed.resolve(err);\n    }\n    close() {\n        return this._close();\n    }\n    isClosed() {\n        return this._closed;\n    }\n    drain() {\n        const subs = this.subscriptions.all();\n        const promises = [];\n        subs.forEach((sub)=>{\n            promises.push(sub.drain());\n        });\n        return Promise.all(promises).then(async ()=>{\n            this.noMorePublishing = true;\n            await this.flush();\n            return this.close();\n        }).catch(()=>{});\n    }\n    flushPending() {\n        if (!this.infoReceived || !this.connected) {\n            return;\n        }\n        if (this.outbound.size()) {\n            const d = this.outbound.drain();\n            this.transport.send(d);\n        }\n    }\n    initMux() {\n        const mux = this.subscriptions.getMux();\n        if (!mux) {\n            const inbox = this.muxSubscriptions.init(this.options.inboxPrefix);\n            const sub = new SubscriptionImpl(this, `${inbox}*`);\n            sub.callback = this.muxSubscriptions.dispatcher();\n            this.subscriptions.setMux(sub);\n            this.subscribe(sub);\n        }\n    }\n    selectServer() {\n        const server = this.servers.selectServer();\n        if (server === undefined) {\n            return undefined;\n        }\n        this.server = server;\n        return this.server;\n    }\n    getServer() {\n        return this.server;\n    }\n}\n(function(nacl) {\n    'use strict';\n    var u64 = function(h, l) {\n        this.hi = h | 0 >>> 0;\n        this.lo = l | 0 >>> 0;\n    };\n    var gf = function(init) {\n        var i, r = new Float64Array(16);\n        if (init) for(i = 0; i < init.length; i++)r[i] = init[i];\n        return r;\n    };\n    var randombytes = function() {\n        throw new Error('no PRNG');\n    };\n    var _0 = new Uint8Array(16);\n    var _9 = new Uint8Array(32);\n    _9[0] = 9;\n    var gf0 = gf(), gf1 = gf([\n        1\n    ]), _121665 = gf([\n        0xdb41,\n        1\n    ]), D = gf([\n        0x78a3,\n        0x1359,\n        0x4dca,\n        0x75eb,\n        0xd8ab,\n        0x4141,\n        0x0a4d,\n        0x0070,\n        0xe898,\n        0x7779,\n        0x4079,\n        0x8cc7,\n        0xfe73,\n        0x2b6f,\n        0x6cee,\n        0x5203\n    ]), D2 = gf([\n        0xf159,\n        0x26b2,\n        0x9b94,\n        0xebd6,\n        0xb156,\n        0x8283,\n        0x149a,\n        0x00e0,\n        0xd130,\n        0xeef3,\n        0x80f2,\n        0x198e,\n        0xfce7,\n        0x56df,\n        0xd9dc,\n        0x2406\n    ]), X = gf([\n        0xd51a,\n        0x8f25,\n        0x2d60,\n        0xc956,\n        0xa7b2,\n        0x9525,\n        0xc760,\n        0x692c,\n        0xdc5c,\n        0xfdd6,\n        0xe231,\n        0xc0a4,\n        0x53fe,\n        0xcd6e,\n        0x36d3,\n        0x2169\n    ]), Y = gf([\n        0x6658,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666\n    ]), I = gf([\n        0xa0b0,\n        0x4a0e,\n        0x1b27,\n        0xc4ee,\n        0xe478,\n        0xad2f,\n        0x1806,\n        0x2f43,\n        0xd7a7,\n        0x3dfb,\n        0x0099,\n        0x2b4d,\n        0xdf0b,\n        0x4fc1,\n        0x2480,\n        0x2b83\n    ]);\n    function L32(x, c) {\n        return x << c | x >>> 32 - c;\n    }\n    function ld32(x, i) {\n        var u = x[i + 3] & 0xff;\n        u = u << 8 | x[i + 2] & 0xff;\n        u = u << 8 | x[i + 1] & 0xff;\n        return u << 8 | x[i + 0] & 0xff;\n    }\n    function dl64(x, i) {\n        var h = x[i] << 24 | x[i + 1] << 16 | x[i + 2] << 8 | x[i + 3];\n        var l = x[i + 4] << 24 | x[i + 5] << 16 | x[i + 6] << 8 | x[i + 7];\n        return new u64(h, l);\n    }\n    function st32(x, j, u) {\n        var i;\n        for(i = 0; i < 4; i++){\n            x[j + i] = u & 255;\n            u >>>= 8;\n        }\n    }\n    function ts64(x, i, u) {\n        x[i] = u.hi >> 24 & 0xff;\n        x[i + 1] = u.hi >> 16 & 0xff;\n        x[i + 2] = u.hi >> 8 & 0xff;\n        x[i + 3] = u.hi & 0xff;\n        x[i + 4] = u.lo >> 24 & 0xff;\n        x[i + 5] = u.lo >> 16 & 0xff;\n        x[i + 6] = u.lo >> 8 & 0xff;\n        x[i + 7] = u.lo & 0xff;\n    }\n    function vn(x, xi, y, yi, n) {\n        var i, d = 0;\n        for(i = 0; i < n; i++)d |= x[xi + i] ^ y[yi + i];\n        return (1 & d - 1 >>> 8) - 1;\n    }\n    function crypto_verify_16(x, xi, y, yi) {\n        return vn(x, xi, y, yi, 16);\n    }\n    function crypto_verify_32(x, xi, y, yi) {\n        return vn(x, xi, y, yi, 32);\n    }\n    function core(out, inp, k, c, h) {\n        var w = new Uint32Array(16), x = new Uint32Array(16), y = new Uint32Array(16), t = new Uint32Array(4);\n        var i, j, m;\n        for(i = 0; i < 4; i++){\n            x[5 * i] = ld32(c, 4 * i);\n            x[1 + i] = ld32(k, 4 * i);\n            x[6 + i] = ld32(inp, 4 * i);\n            x[11 + i] = ld32(k, 16 + 4 * i);\n        }\n        for(i = 0; i < 16; i++)y[i] = x[i];\n        for(i = 0; i < 20; i++){\n            for(j = 0; j < 4; j++){\n                for(m = 0; m < 4; m++)t[m] = x[(5 * j + 4 * m) % 16];\n                t[1] ^= L32(t[0] + t[3] | 0, 7);\n                t[2] ^= L32(t[1] + t[0] | 0, 9);\n                t[3] ^= L32(t[2] + t[1] | 0, 13);\n                t[0] ^= L32(t[3] + t[2] | 0, 18);\n                for(m = 0; m < 4; m++)w[4 * j + (j + m) % 4] = t[m];\n            }\n            for(m = 0; m < 16; m++)x[m] = w[m];\n        }\n        if (h) {\n            for(i = 0; i < 16; i++)x[i] = x[i] + y[i] | 0;\n            for(i = 0; i < 4; i++){\n                x[5 * i] = x[5 * i] - ld32(c, 4 * i) | 0;\n                x[6 + i] = x[6 + i] - ld32(inp, 4 * i) | 0;\n            }\n            for(i = 0; i < 4; i++){\n                st32(out, 4 * i, x[5 * i]);\n                st32(out, 16 + 4 * i, x[6 + i]);\n            }\n        } else {\n            for(i = 0; i < 16; i++)st32(out, 4 * i, x[i] + y[i] | 0);\n        }\n    }\n    function crypto_core_salsa20(out, inp, k, c) {\n        core(out, inp, k, c, false);\n        return 0;\n    }\n    function crypto_core_hsalsa20(out, inp, k, c) {\n        core(out, inp, k, c, true);\n        return 0;\n    }\n    var sigma = new Uint8Array([\n        101,\n        120,\n        112,\n        97,\n        110,\n        100,\n        32,\n        51,\n        50,\n        45,\n        98,\n        121,\n        116,\n        101,\n        32,\n        107\n    ]);\n    function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {\n        var z = new Uint8Array(16), x = new Uint8Array(64);\n        var u, i;\n        if (!b) return 0;\n        for(i = 0; i < 16; i++)z[i] = 0;\n        for(i = 0; i < 8; i++)z[i] = n[i];\n        while(b >= 64){\n            crypto_core_salsa20(x, z, k, sigma);\n            for(i = 0; i < 64; i++)c[cpos + i] = (m ? m[mpos + i] : 0) ^ x[i];\n            u = 1;\n            for(i = 8; i < 16; i++){\n                u = u + (z[i] & 0xff) | 0;\n                z[i] = u & 0xff;\n                u >>>= 8;\n            }\n            b -= 64;\n            cpos += 64;\n            if (m) mpos += 64;\n        }\n        if (b > 0) {\n            crypto_core_salsa20(x, z, k, sigma);\n            for(i = 0; i < b; i++)c[cpos + i] = (m ? m[mpos + i] : 0) ^ x[i];\n        }\n        return 0;\n    }\n    function crypto_stream_salsa20(c, cpos, d, n, k) {\n        return crypto_stream_salsa20_xor(c, cpos, null, 0, d, n, k);\n    }\n    function crypto_stream(c, cpos, d, n, k) {\n        var s = new Uint8Array(32);\n        crypto_core_hsalsa20(s, n, k, sigma);\n        return crypto_stream_salsa20(c, cpos, d, n.subarray(16), s);\n    }\n    function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {\n        var s = new Uint8Array(32);\n        crypto_core_hsalsa20(s, n, k, sigma);\n        return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, n.subarray(16), s);\n    }\n    function add1305(h, c) {\n        var j, u = 0;\n        for(j = 0; j < 17; j++){\n            u = u + (h[j] + c[j] | 0) | 0;\n            h[j] = u & 255;\n            u >>>= 8;\n        }\n    }\n    var minusp = new Uint32Array([\n        5,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        252\n    ]);\n    function crypto_onetimeauth(out, outpos, m, mpos, n, k) {\n        var s, i, j, u;\n        var x = new Uint32Array(17), r = new Uint32Array(17), h = new Uint32Array(17), c = new Uint32Array(17), g = new Uint32Array(17);\n        for(j = 0; j < 17; j++)r[j] = h[j] = 0;\n        for(j = 0; j < 16; j++)r[j] = k[j];\n        r[3] &= 15;\n        r[4] &= 252;\n        r[7] &= 15;\n        r[8] &= 252;\n        r[11] &= 15;\n        r[12] &= 252;\n        r[15] &= 15;\n        while(n > 0){\n            for(j = 0; j < 17; j++)c[j] = 0;\n            for(j = 0; j < 16 && j < n; ++j)c[j] = m[mpos + j];\n            c[j] = 1;\n            mpos += j;\n            n -= j;\n            add1305(h, c);\n            for(i = 0; i < 17; i++){\n                x[i] = 0;\n                for(j = 0; j < 17; j++)x[i] = x[i] + h[j] * (j <= i ? r[i - j] : 320 * r[i + 17 - j] | 0) | 0 | 0;\n            }\n            for(i = 0; i < 17; i++)h[i] = x[i];\n            u = 0;\n            for(j = 0; j < 16; j++){\n                u = u + h[j] | 0;\n                h[j] = u & 255;\n                u >>>= 8;\n            }\n            u = u + h[16] | 0;\n            h[16] = u & 3;\n            u = 5 * (u >>> 2) | 0;\n            for(j = 0; j < 16; j++){\n                u = u + h[j] | 0;\n                h[j] = u & 255;\n                u >>>= 8;\n            }\n            u = u + h[16] | 0;\n            h[16] = u;\n        }\n        for(j = 0; j < 17; j++)g[j] = h[j];\n        add1305(h, minusp);\n        s = -(h[16] >>> 7) | 0;\n        for(j = 0; j < 17; j++)h[j] ^= s & (g[j] ^ h[j]);\n        for(j = 0; j < 16; j++)c[j] = k[j + 16];\n        c[16] = 0;\n        add1305(h, c);\n        for(j = 0; j < 16; j++)out[outpos + j] = h[j];\n        return 0;\n    }\n    function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {\n        var x = new Uint8Array(16);\n        crypto_onetimeauth(x, 0, m, mpos, n, k);\n        return crypto_verify_16(h, hpos, x, 0);\n    }\n    function crypto_secretbox(c, m, d, n, k) {\n        var i;\n        if (d < 32) return -1;\n        crypto_stream_xor(c, 0, m, 0, d, n, k);\n        crypto_onetimeauth(c, 16, c, 32, d - 32, c);\n        for(i = 0; i < 16; i++)c[i] = 0;\n        return 0;\n    }\n    function crypto_secretbox_open(m, c, d, n, k) {\n        var i;\n        var x = new Uint8Array(32);\n        if (d < 32) return -1;\n        crypto_stream(x, 0, 32, n, k);\n        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0) return -1;\n        crypto_stream_xor(m, 0, c, 0, d, n, k);\n        for(i = 0; i < 32; i++)m[i] = 0;\n        return 0;\n    }\n    function set25519(r, a) {\n        var i;\n        for(i = 0; i < 16; i++)r[i] = a[i] | 0;\n    }\n    function car25519(o) {\n        var c;\n        var i;\n        for(i = 0; i < 16; i++){\n            o[i] += 65536;\n            c = Math.floor(o[i] / 65536);\n            o[(i + 1) * (i < 15 ? 1 : 0)] += c - 1 + 37 * (c - 1) * (i === 15 ? 1 : 0);\n            o[i] -= c * 65536;\n        }\n    }\n    function sel25519(p, q, b) {\n        var t, c = ~(b - 1);\n        for(var i = 0; i < 16; i++){\n            t = c & (p[i] ^ q[i]);\n            p[i] ^= t;\n            q[i] ^= t;\n        }\n    }\n    function pack25519(o, n) {\n        var i, j, b;\n        var m = gf(), t = gf();\n        for(i = 0; i < 16; i++)t[i] = n[i];\n        car25519(t);\n        car25519(t);\n        car25519(t);\n        for(j = 0; j < 2; j++){\n            m[0] = t[0] - 0xffed;\n            for(i = 1; i < 15; i++){\n                m[i] = t[i] - 0xffff - (m[i - 1] >> 16 & 1);\n                m[i - 1] &= 0xffff;\n            }\n            m[15] = t[15] - 0x7fff - (m[14] >> 16 & 1);\n            b = m[15] >> 16 & 1;\n            m[14] &= 0xffff;\n            sel25519(t, m, 1 - b);\n        }\n        for(i = 0; i < 16; i++){\n            o[2 * i] = t[i] & 0xff;\n            o[2 * i + 1] = t[i] >> 8;\n        }\n    }\n    function neq25519(a, b) {\n        var c = new Uint8Array(32), d = new Uint8Array(32);\n        pack25519(c, a);\n        pack25519(d, b);\n        return crypto_verify_32(c, 0, d, 0);\n    }\n    function par25519(a) {\n        var d = new Uint8Array(32);\n        pack25519(d, a);\n        return d[0] & 1;\n    }\n    function unpack25519(o, n) {\n        var i;\n        for(i = 0; i < 16; i++)o[i] = n[2 * i] + (n[2 * i + 1] << 8);\n        o[15] &= 0x7fff;\n    }\n    function A(o, a, b) {\n        var i;\n        for(i = 0; i < 16; i++)o[i] = a[i] + b[i] | 0;\n    }\n    function Z(o, a, b) {\n        var i;\n        for(i = 0; i < 16; i++)o[i] = a[i] - b[i] | 0;\n    }\n    function M(o, a, b) {\n        var i, j, t = new Float64Array(31);\n        for(i = 0; i < 31; i++)t[i] = 0;\n        for(i = 0; i < 16; i++){\n            for(j = 0; j < 16; j++){\n                t[i + j] += a[i] * b[j];\n            }\n        }\n        for(i = 0; i < 15; i++){\n            t[i] += 38 * t[i + 16];\n        }\n        for(i = 0; i < 16; i++)o[i] = t[i];\n        car25519(o);\n        car25519(o);\n    }\n    function S(o, a) {\n        M(o, a, a);\n    }\n    function inv25519(o, i) {\n        var c = gf();\n        var a;\n        for(a = 0; a < 16; a++)c[a] = i[a];\n        for(a = 253; a >= 0; a--){\n            S(c, c);\n            if (a !== 2 && a !== 4) M(c, c, i);\n        }\n        for(a = 0; a < 16; a++)o[a] = c[a];\n    }\n    function pow2523(o, i) {\n        var c = gf();\n        var a;\n        for(a = 0; a < 16; a++)c[a] = i[a];\n        for(a = 250; a >= 0; a--){\n            S(c, c);\n            if (a !== 1) M(c, c, i);\n        }\n        for(a = 0; a < 16; a++)o[a] = c[a];\n    }\n    function crypto_scalarmult(q, n, p) {\n        var z = new Uint8Array(32);\n        var x = new Float64Array(80), r, i;\n        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();\n        for(i = 0; i < 31; i++)z[i] = n[i];\n        z[31] = n[31] & 127 | 64;\n        z[0] &= 248;\n        unpack25519(x, p);\n        for(i = 0; i < 16; i++){\n            b[i] = x[i];\n            d[i] = a[i] = c[i] = 0;\n        }\n        a[0] = d[0] = 1;\n        for(i = 254; i >= 0; --i){\n            r = z[i >>> 3] >>> (i & 7) & 1;\n            sel25519(a, b, r);\n            sel25519(c, d, r);\n            A(e, a, c);\n            Z(a, a, c);\n            A(c, b, d);\n            Z(b, b, d);\n            S(d, e);\n            S(f, a);\n            M(a, c, a);\n            M(c, b, e);\n            A(e, a, c);\n            Z(a, a, c);\n            S(b, a);\n            Z(c, d, f);\n            M(a, c, _121665);\n            A(a, a, d);\n            M(c, c, a);\n            M(a, d, f);\n            M(d, b, x);\n            S(b, e);\n            sel25519(a, b, r);\n            sel25519(c, d, r);\n        }\n        for(i = 0; i < 16; i++){\n            x[i + 16] = a[i];\n            x[i + 32] = c[i];\n            x[i + 48] = b[i];\n            x[i + 64] = d[i];\n        }\n        var x32 = x.subarray(32);\n        var x16 = x.subarray(16);\n        inv25519(x32, x32);\n        M(x16, x16, x32);\n        pack25519(q, x16);\n        return 0;\n    }\n    function crypto_scalarmult_base(q, n) {\n        return crypto_scalarmult(q, n, _9);\n    }\n    function crypto_box_keypair(y, x) {\n        randombytes(x, 32);\n        return crypto_scalarmult_base(y, x);\n    }\n    function crypto_box_beforenm(k, y, x) {\n        var s = new Uint8Array(32);\n        crypto_scalarmult(s, x, y);\n        return crypto_core_hsalsa20(k, _0, s, sigma);\n    }\n    var crypto_box_afternm = crypto_secretbox;\n    var crypto_box_open_afternm = crypto_secretbox_open;\n    function crypto_box(c, m, d, n, y, x) {\n        var k = new Uint8Array(32);\n        crypto_box_beforenm(k, y, x);\n        return crypto_box_afternm(c, m, d, n, k);\n    }\n    function crypto_box_open(m, c, d, n, y, x) {\n        var k = new Uint8Array(32);\n        crypto_box_beforenm(k, y, x);\n        return crypto_box_open_afternm(m, c, d, n, k);\n    }\n    function add64() {\n        var a = 0, b = 0, c = 0, d = 0, m16 = 65535, l, h, i;\n        for(i = 0; i < arguments.length; i++){\n            l = arguments[i].lo;\n            h = arguments[i].hi;\n            a += l & m16;\n            b += l >>> 16;\n            c += h & m16;\n            d += h >>> 16;\n        }\n        b += a >>> 16;\n        c += b >>> 16;\n        d += c >>> 16;\n        return new u64(c & m16 | d << 16, a & m16 | b << 16);\n    }\n    function shr64(x, c) {\n        return new u64(x.hi >>> c, x.lo >>> c | x.hi << 32 - c);\n    }\n    function xor64() {\n        var l = 0, h = 0, i;\n        for(i = 0; i < arguments.length; i++){\n            l ^= arguments[i].lo;\n            h ^= arguments[i].hi;\n        }\n        return new u64(h, l);\n    }\n    function R(x, c) {\n        var h, l, c1 = 32 - c;\n        if (c < 32) {\n            h = x.hi >>> c | x.lo << c1;\n            l = x.lo >>> c | x.hi << c1;\n        } else if (c < 64) {\n            h = x.lo >>> c | x.hi << c1;\n            l = x.hi >>> c | x.lo << c1;\n        }\n        return new u64(h, l);\n    }\n    function Ch(x, y, z) {\n        var h = x.hi & y.hi ^ ~x.hi & z.hi, l = x.lo & y.lo ^ ~x.lo & z.lo;\n        return new u64(h, l);\n    }\n    function Maj(x, y, z) {\n        var h = x.hi & y.hi ^ x.hi & z.hi ^ y.hi & z.hi, l = x.lo & y.lo ^ x.lo & z.lo ^ y.lo & z.lo;\n        return new u64(h, l);\n    }\n    function Sigma0(x) {\n        return xor64(R(x, 28), R(x, 34), R(x, 39));\n    }\n    function Sigma1(x) {\n        return xor64(R(x, 14), R(x, 18), R(x, 41));\n    }\n    function sigma0(x) {\n        return xor64(R(x, 1), R(x, 8), shr64(x, 7));\n    }\n    function sigma1(x) {\n        return xor64(R(x, 19), R(x, 61), shr64(x, 6));\n    }\n    var K = [\n        new u64(0x428a2f98, 0xd728ae22),\n        new u64(0x71374491, 0x23ef65cd),\n        new u64(0xb5c0fbcf, 0xec4d3b2f),\n        new u64(0xe9b5dba5, 0x8189dbbc),\n        new u64(0x3956c25b, 0xf348b538),\n        new u64(0x59f111f1, 0xb605d019),\n        new u64(0x923f82a4, 0xaf194f9b),\n        new u64(0xab1c5ed5, 0xda6d8118),\n        new u64(0xd807aa98, 0xa3030242),\n        new u64(0x12835b01, 0x45706fbe),\n        new u64(0x243185be, 0x4ee4b28c),\n        new u64(0x550c7dc3, 0xd5ffb4e2),\n        new u64(0x72be5d74, 0xf27b896f),\n        new u64(0x80deb1fe, 0x3b1696b1),\n        new u64(0x9bdc06a7, 0x25c71235),\n        new u64(0xc19bf174, 0xcf692694),\n        new u64(0xe49b69c1, 0x9ef14ad2),\n        new u64(0xefbe4786, 0x384f25e3),\n        new u64(0x0fc19dc6, 0x8b8cd5b5),\n        new u64(0x240ca1cc, 0x77ac9c65),\n        new u64(0x2de92c6f, 0x592b0275),\n        new u64(0x4a7484aa, 0x6ea6e483),\n        new u64(0x5cb0a9dc, 0xbd41fbd4),\n        new u64(0x76f988da, 0x831153b5),\n        new u64(0x983e5152, 0xee66dfab),\n        new u64(0xa831c66d, 0x2db43210),\n        new u64(0xb00327c8, 0x98fb213f),\n        new u64(0xbf597fc7, 0xbeef0ee4),\n        new u64(0xc6e00bf3, 0x3da88fc2),\n        new u64(0xd5a79147, 0x930aa725),\n        new u64(0x06ca6351, 0xe003826f),\n        new u64(0x14292967, 0x0a0e6e70),\n        new u64(0x27b70a85, 0x46d22ffc),\n        new u64(0x2e1b2138, 0x5c26c926),\n        new u64(0x4d2c6dfc, 0x5ac42aed),\n        new u64(0x53380d13, 0x9d95b3df),\n        new u64(0x650a7354, 0x8baf63de),\n        new u64(0x766a0abb, 0x3c77b2a8),\n        new u64(0x81c2c92e, 0x47edaee6),\n        new u64(0x92722c85, 0x1482353b),\n        new u64(0xa2bfe8a1, 0x4cf10364),\n        new u64(0xa81a664b, 0xbc423001),\n        new u64(0xc24b8b70, 0xd0f89791),\n        new u64(0xc76c51a3, 0x0654be30),\n        new u64(0xd192e819, 0xd6ef5218),\n        new u64(0xd6990624, 0x5565a910),\n        new u64(0xf40e3585, 0x5771202a),\n        new u64(0x106aa070, 0x32bbd1b8),\n        new u64(0x19a4c116, 0xb8d2d0c8),\n        new u64(0x1e376c08, 0x5141ab53),\n        new u64(0x2748774c, 0xdf8eeb99),\n        new u64(0x34b0bcb5, 0xe19b48a8),\n        new u64(0x391c0cb3, 0xc5c95a63),\n        new u64(0x4ed8aa4a, 0xe3418acb),\n        new u64(0x5b9cca4f, 0x7763e373),\n        new u64(0x682e6ff3, 0xd6b2b8a3),\n        new u64(0x748f82ee, 0x5defb2fc),\n        new u64(0x78a5636f, 0x43172f60),\n        new u64(0x84c87814, 0xa1f0ab72),\n        new u64(0x8cc70208, 0x1a6439ec),\n        new u64(0x90befffa, 0x23631e28),\n        new u64(0xa4506ceb, 0xde82bde9),\n        new u64(0xbef9a3f7, 0xb2c67915),\n        new u64(0xc67178f2, 0xe372532b),\n        new u64(0xca273ece, 0xea26619c),\n        new u64(0xd186b8c7, 0x21c0c207),\n        new u64(0xeada7dd6, 0xcde0eb1e),\n        new u64(0xf57d4f7f, 0xee6ed178),\n        new u64(0x06f067aa, 0x72176fba),\n        new u64(0x0a637dc5, 0xa2c898a6),\n        new u64(0x113f9804, 0xbef90dae),\n        new u64(0x1b710b35, 0x131c471b),\n        new u64(0x28db77f5, 0x23047d84),\n        new u64(0x32caab7b, 0x40c72493),\n        new u64(0x3c9ebe0a, 0x15c9bebc),\n        new u64(0x431d67c4, 0x9c100d4c),\n        new u64(0x4cc5d4be, 0xcb3e42b6),\n        new u64(0x597f299c, 0xfc657e2a),\n        new u64(0x5fcb6fab, 0x3ad6faec),\n        new u64(0x6c44198c, 0x4a475817)\n    ];\n    function crypto_hashblocks(x, m, n) {\n        var z = [], b = [], a = [], w = [], t, i, j;\n        for(i = 0; i < 8; i++)z[i] = a[i] = dl64(x, 8 * i);\n        var pos = 0;\n        while(n >= 128){\n            for(i = 0; i < 16; i++)w[i] = dl64(m, 8 * i + pos);\n            for(i = 0; i < 80; i++){\n                for(j = 0; j < 8; j++)b[j] = a[j];\n                t = add64(a[7], Sigma1(a[4]), Ch(a[4], a[5], a[6]), K[i], w[i % 16]);\n                b[7] = add64(t, Sigma0(a[0]), Maj(a[0], a[1], a[2]));\n                b[3] = add64(b[3], t);\n                for(j = 0; j < 8; j++)a[(j + 1) % 8] = b[j];\n                if (i % 16 === 15) {\n                    for(j = 0; j < 16; j++){\n                        w[j] = add64(w[j], w[(j + 9) % 16], sigma0(w[(j + 1) % 16]), sigma1(w[(j + 14) % 16]));\n                    }\n                }\n            }\n            for(i = 0; i < 8; i++){\n                a[i] = add64(a[i], z[i]);\n                z[i] = a[i];\n            }\n            pos += 128;\n            n -= 128;\n        }\n        for(i = 0; i < 8; i++)ts64(x, 8 * i, z[i]);\n        return n;\n    }\n    var iv = new Uint8Array([\n        0x6a,\n        0x09,\n        0xe6,\n        0x67,\n        0xf3,\n        0xbc,\n        0xc9,\n        0x08,\n        0xbb,\n        0x67,\n        0xae,\n        0x85,\n        0x84,\n        0xca,\n        0xa7,\n        0x3b,\n        0x3c,\n        0x6e,\n        0xf3,\n        0x72,\n        0xfe,\n        0x94,\n        0xf8,\n        0x2b,\n        0xa5,\n        0x4f,\n        0xf5,\n        0x3a,\n        0x5f,\n        0x1d,\n        0x36,\n        0xf1,\n        0x51,\n        0x0e,\n        0x52,\n        0x7f,\n        0xad,\n        0xe6,\n        0x82,\n        0xd1,\n        0x9b,\n        0x05,\n        0x68,\n        0x8c,\n        0x2b,\n        0x3e,\n        0x6c,\n        0x1f,\n        0x1f,\n        0x83,\n        0xd9,\n        0xab,\n        0xfb,\n        0x41,\n        0xbd,\n        0x6b,\n        0x5b,\n        0xe0,\n        0xcd,\n        0x19,\n        0x13,\n        0x7e,\n        0x21,\n        0x79\n    ]);\n    function crypto_hash(out, m, n) {\n        var h = new Uint8Array(64), x = new Uint8Array(256);\n        var i, b = n;\n        for(i = 0; i < 64; i++)h[i] = iv[i];\n        crypto_hashblocks(h, m, n);\n        n %= 128;\n        for(i = 0; i < 256; i++)x[i] = 0;\n        for(i = 0; i < n; i++)x[i] = m[b - n + i];\n        x[n] = 128;\n        n = 256 - 128 * (n < 112 ? 1 : 0);\n        x[n - 9] = 0;\n        ts64(x, n - 8, new u64(b / 0x20000000 | 0, b << 3));\n        crypto_hashblocks(h, x, n);\n        for(i = 0; i < 64; i++)out[i] = h[i];\n        return 0;\n    }\n    function add(p, q) {\n        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();\n        Z(a, p[1], p[0]);\n        Z(t, q[1], q[0]);\n        M(a, a, t);\n        A(b, p[0], p[1]);\n        A(t, q[0], q[1]);\n        M(b, b, t);\n        M(c, p[3], q[3]);\n        M(c, c, D2);\n        M(d, p[2], q[2]);\n        A(d, d, d);\n        Z(e, b, a);\n        Z(f, d, c);\n        A(g, d, c);\n        A(h, b, a);\n        M(p[0], e, f);\n        M(p[1], h, g);\n        M(p[2], g, f);\n        M(p[3], e, h);\n    }\n    function cswap(p, q, b) {\n        var i;\n        for(i = 0; i < 4; i++){\n            sel25519(p[i], q[i], b);\n        }\n    }\n    function pack(r, p) {\n        var tx = gf(), ty = gf(), zi = gf();\n        inv25519(zi, p[2]);\n        M(tx, p[0], zi);\n        M(ty, p[1], zi);\n        pack25519(r, ty);\n        r[31] ^= par25519(tx) << 7;\n    }\n    function scalarmult(p, q, s) {\n        var b, i;\n        set25519(p[0], gf0);\n        set25519(p[1], gf1);\n        set25519(p[2], gf1);\n        set25519(p[3], gf0);\n        for(i = 255; i >= 0; --i){\n            b = s[i / 8 | 0] >> (i & 7) & 1;\n            cswap(p, q, b);\n            add(q, p);\n            add(p, p);\n            cswap(p, q, b);\n        }\n    }\n    function scalarbase(p, s) {\n        var q = [\n            gf(),\n            gf(),\n            gf(),\n            gf()\n        ];\n        set25519(q[0], X);\n        set25519(q[1], Y);\n        set25519(q[2], gf1);\n        M(q[3], X, Y);\n        scalarmult(p, q, s);\n    }\n    function crypto_sign_keypair(pk, sk, seeded) {\n        var d = new Uint8Array(64);\n        var p = [\n            gf(),\n            gf(),\n            gf(),\n            gf()\n        ];\n        var i;\n        if (!seeded) randombytes(sk, 32);\n        crypto_hash(d, sk, 32);\n        d[0] &= 248;\n        d[31] &= 127;\n        d[31] |= 64;\n        scalarbase(p, d);\n        pack(pk, p);\n        for(i = 0; i < 32; i++)sk[i + 32] = pk[i];\n        return 0;\n    }\n    var L = new Float64Array([\n        0xed,\n        0xd3,\n        0xf5,\n        0x5c,\n        0x1a,\n        0x63,\n        0x12,\n        0x58,\n        0xd6,\n        0x9c,\n        0xf7,\n        0xa2,\n        0xde,\n        0xf9,\n        0xde,\n        0x14,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0x10\n    ]);\n    function modL(r, x) {\n        var carry, i, j, k;\n        for(i = 63; i >= 32; --i){\n            carry = 0;\n            for(j = i - 32, k = i - 12; j < k; ++j){\n                x[j] += carry - 16 * x[i] * L[j - (i - 32)];\n                carry = Math.floor((x[j] + 128) / 256);\n                x[j] -= carry * 256;\n            }\n            x[j] += carry;\n            x[i] = 0;\n        }\n        carry = 0;\n        for(j = 0; j < 32; j++){\n            x[j] += carry - (x[31] >> 4) * L[j];\n            carry = x[j] >> 8;\n            x[j] &= 255;\n        }\n        for(j = 0; j < 32; j++)x[j] -= carry * L[j];\n        for(i = 0; i < 32; i++){\n            x[i + 1] += x[i] >> 8;\n            r[i] = x[i] & 255;\n        }\n    }\n    function reduce(r) {\n        var x = new Float64Array(64), i;\n        for(i = 0; i < 64; i++)x[i] = r[i];\n        for(i = 0; i < 64; i++)r[i] = 0;\n        modL(r, x);\n    }\n    function crypto_sign(sm, m, n, sk) {\n        var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);\n        var i, j, x = new Float64Array(64);\n        var p = [\n            gf(),\n            gf(),\n            gf(),\n            gf()\n        ];\n        crypto_hash(d, sk, 32);\n        d[0] &= 248;\n        d[31] &= 127;\n        d[31] |= 64;\n        var smlen = n + 64;\n        for(i = 0; i < n; i++)sm[64 + i] = m[i];\n        for(i = 0; i < 32; i++)sm[32 + i] = d[32 + i];\n        crypto_hash(r, sm.subarray(32), n + 32);\n        reduce(r);\n        scalarbase(p, r);\n        pack(sm, p);\n        for(i = 32; i < 64; i++)sm[i] = sk[i];\n        crypto_hash(h, sm, n + 64);\n        reduce(h);\n        for(i = 0; i < 64; i++)x[i] = 0;\n        for(i = 0; i < 32; i++)x[i] = r[i];\n        for(i = 0; i < 32; i++){\n            for(j = 0; j < 32; j++){\n                x[i + j] += h[i] * d[j];\n            }\n        }\n        modL(sm.subarray(32), x);\n        return smlen;\n    }\n    function unpackneg(r, p) {\n        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();\n        set25519(r[2], gf1);\n        unpack25519(r[1], p);\n        S(num, r[1]);\n        M(den, num, D);\n        Z(num, num, r[2]);\n        A(den, r[2], den);\n        S(den2, den);\n        S(den4, den2);\n        M(den6, den4, den2);\n        M(t, den6, num);\n        M(t, t, den);\n        pow2523(t, t);\n        M(t, t, num);\n        M(t, t, den);\n        M(t, t, den);\n        M(r[0], t, den);\n        S(chk, r[0]);\n        M(chk, chk, den);\n        if (neq25519(chk, num)) M(r[0], r[0], I);\n        S(chk, r[0]);\n        M(chk, chk, den);\n        if (neq25519(chk, num)) return -1;\n        if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0]);\n        M(r[3], r[0], r[1]);\n        return 0;\n    }\n    function crypto_sign_open(m, sm, n, pk) {\n        var i;\n        var t = new Uint8Array(32), h = new Uint8Array(64);\n        var p = [\n            gf(),\n            gf(),\n            gf(),\n            gf()\n        ], q = [\n            gf(),\n            gf(),\n            gf(),\n            gf()\n        ];\n        if (n < 64) return -1;\n        if (unpackneg(q, pk)) return -1;\n        for(i = 0; i < n; i++)m[i] = sm[i];\n        for(i = 0; i < 32; i++)m[i + 32] = pk[i];\n        crypto_hash(h, m, n);\n        reduce(h);\n        scalarmult(p, q, h);\n        scalarbase(q, sm.subarray(32));\n        add(p, q);\n        pack(t, p);\n        n -= 64;\n        if (crypto_verify_32(sm, 0, t, 0)) {\n            for(i = 0; i < n; i++)m[i] = 0;\n            return -1;\n        }\n        for(i = 0; i < n; i++)m[i] = sm[i + 64];\n        return n;\n    }\n    var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;\n    nacl.lowlevel = {\n        crypto_core_hsalsa20: crypto_core_hsalsa20,\n        crypto_stream_xor: crypto_stream_xor,\n        crypto_stream: crypto_stream,\n        crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,\n        crypto_stream_salsa20: crypto_stream_salsa20,\n        crypto_onetimeauth: crypto_onetimeauth,\n        crypto_onetimeauth_verify: crypto_onetimeauth_verify,\n        crypto_verify_16: crypto_verify_16,\n        crypto_verify_32: crypto_verify_32,\n        crypto_secretbox: crypto_secretbox,\n        crypto_secretbox_open: crypto_secretbox_open,\n        crypto_scalarmult: crypto_scalarmult,\n        crypto_scalarmult_base: crypto_scalarmult_base,\n        crypto_box_beforenm: crypto_box_beforenm,\n        crypto_box_afternm: crypto_box_afternm,\n        crypto_box: crypto_box,\n        crypto_box_open: crypto_box_open,\n        crypto_box_keypair: crypto_box_keypair,\n        crypto_hash: crypto_hash,\n        crypto_sign: crypto_sign,\n        crypto_sign_keypair: crypto_sign_keypair,\n        crypto_sign_open: crypto_sign_open,\n        crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,\n        crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,\n        crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,\n        crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,\n        crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,\n        crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,\n        crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,\n        crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,\n        crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,\n        crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,\n        crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,\n        crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,\n        crypto_sign_BYTES: crypto_sign_BYTES,\n        crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,\n        crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,\n        crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,\n        crypto_hash_BYTES: crypto_hash_BYTES,\n        gf: gf,\n        D: D,\n        L: L,\n        pack25519: pack25519,\n        unpack25519: unpack25519,\n        M: M,\n        A: A,\n        S: S,\n        Z: Z,\n        pow2523: pow2523,\n        add: add,\n        set25519: set25519,\n        modL: modL,\n        scalarmult: scalarmult,\n        scalarbase: scalarbase\n    };\n    function checkLengths(k, n) {\n        if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');\n        if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');\n    }\n    function checkBoxLengths(pk, sk) {\n        if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');\n        if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');\n    }\n    function checkArrayTypes() {\n        for(var i = 0; i < arguments.length; i++){\n            if (!(arguments[i] instanceof Uint8Array)) throw new TypeError('unexpected type, use Uint8Array');\n        }\n    }\n    function cleanup(arr) {\n        for(var i = 0; i < arr.length; i++)arr[i] = 0;\n    }\n    nacl.randomBytes = function(n) {\n        var b = new Uint8Array(n);\n        randombytes(b, n);\n        return b;\n    };\n    nacl.secretbox = function(msg, nonce, key) {\n        checkArrayTypes(msg, nonce, key);\n        checkLengths(key, nonce);\n        var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);\n        var c = new Uint8Array(m.length);\n        for(var i = 0; i < msg.length; i++)m[i + crypto_secretbox_ZEROBYTES] = msg[i];\n        crypto_secretbox(c, m, m.length, nonce, key);\n        return c.subarray(crypto_secretbox_BOXZEROBYTES);\n    };\n    nacl.secretbox.open = function(box, nonce, key) {\n        checkArrayTypes(box, nonce, key);\n        checkLengths(key, nonce);\n        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);\n        var m = new Uint8Array(c.length);\n        for(var i = 0; i < box.length; i++)c[i + crypto_secretbox_BOXZEROBYTES] = box[i];\n        if (c.length < 32) return null;\n        if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;\n        return m.subarray(crypto_secretbox_ZEROBYTES);\n    };\n    nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;\n    nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;\n    nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;\n    nacl.scalarMult = function(n, p) {\n        checkArrayTypes(n, p);\n        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');\n        if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');\n        var q = new Uint8Array(crypto_scalarmult_BYTES);\n        crypto_scalarmult(q, n, p);\n        return q;\n    };\n    nacl.scalarMult.base = function(n) {\n        checkArrayTypes(n);\n        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');\n        var q = new Uint8Array(crypto_scalarmult_BYTES);\n        crypto_scalarmult_base(q, n);\n        return q;\n    };\n    nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;\n    nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;\n    nacl.box = function(msg, nonce, publicKey, secretKey) {\n        var k = nacl.box.before(publicKey, secretKey);\n        return nacl.secretbox(msg, nonce, k);\n    };\n    nacl.box.before = function(publicKey, secretKey) {\n        checkArrayTypes(publicKey, secretKey);\n        checkBoxLengths(publicKey, secretKey);\n        var k = new Uint8Array(crypto_box_BEFORENMBYTES);\n        crypto_box_beforenm(k, publicKey, secretKey);\n        return k;\n    };\n    nacl.box.after = nacl.secretbox;\n    nacl.box.open = function(msg, nonce, publicKey, secretKey) {\n        var k = nacl.box.before(publicKey, secretKey);\n        return nacl.secretbox.open(msg, nonce, k);\n    };\n    nacl.box.open.after = nacl.secretbox.open;\n    nacl.box.keyPair = function() {\n        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);\n        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);\n        crypto_box_keypair(pk, sk);\n        return {\n            publicKey: pk,\n            secretKey: sk\n        };\n    };\n    nacl.box.keyPair.fromSecretKey = function(secretKey) {\n        checkArrayTypes(secretKey);\n        if (secretKey.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');\n        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);\n        crypto_scalarmult_base(pk, secretKey);\n        return {\n            publicKey: pk,\n            secretKey: new Uint8Array(secretKey)\n        };\n    };\n    nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;\n    nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;\n    nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;\n    nacl.box.nonceLength = crypto_box_NONCEBYTES;\n    nacl.box.overheadLength = nacl.secretbox.overheadLength;\n    nacl.sign = function(msg, secretKey) {\n        checkArrayTypes(msg, secretKey);\n        if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error('bad secret key size');\n        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);\n        crypto_sign(signedMsg, msg, msg.length, secretKey);\n        return signedMsg;\n    };\n    nacl.sign.open = function(signedMsg, publicKey) {\n        checkArrayTypes(signedMsg, publicKey);\n        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error('bad public key size');\n        var tmp = new Uint8Array(signedMsg.length);\n        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);\n        if (mlen < 0) return null;\n        var m = new Uint8Array(mlen);\n        for(var i = 0; i < m.length; i++)m[i] = tmp[i];\n        return m;\n    };\n    nacl.sign.detached = function(msg, secretKey) {\n        var signedMsg = nacl.sign(msg, secretKey);\n        var sig = new Uint8Array(crypto_sign_BYTES);\n        for(var i = 0; i < sig.length; i++)sig[i] = signedMsg[i];\n        return sig;\n    };\n    nacl.sign.detached.verify = function(msg, sig, publicKey) {\n        checkArrayTypes(msg, sig, publicKey);\n        if (sig.length !== crypto_sign_BYTES) throw new Error('bad signature size');\n        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error('bad public key size');\n        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);\n        var m = new Uint8Array(crypto_sign_BYTES + msg.length);\n        var i;\n        for(i = 0; i < crypto_sign_BYTES; i++)sm[i] = sig[i];\n        for(i = 0; i < msg.length; i++)sm[i + crypto_sign_BYTES] = msg[i];\n        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;\n    };\n    nacl.sign.keyPair = function() {\n        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);\n        crypto_sign_keypair(pk, sk);\n        return {\n            publicKey: pk,\n            secretKey: sk\n        };\n    };\n    nacl.sign.keyPair.fromSecretKey = function(secretKey) {\n        checkArrayTypes(secretKey);\n        if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error('bad secret key size');\n        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n        for(var i = 0; i < pk.length; i++)pk[i] = secretKey[32 + i];\n        return {\n            publicKey: pk,\n            secretKey: new Uint8Array(secretKey)\n        };\n    };\n    nacl.sign.keyPair.fromSeed = function(seed) {\n        checkArrayTypes(seed);\n        if (seed.length !== crypto_sign_SEEDBYTES) throw new Error('bad seed size');\n        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);\n        for(var i = 0; i < 32; i++)sk[i] = seed[i];\n        crypto_sign_keypair(pk, sk, true);\n        return {\n            publicKey: pk,\n            secretKey: sk\n        };\n    };\n    nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;\n    nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;\n    nacl.sign.seedLength = crypto_sign_SEEDBYTES;\n    nacl.sign.signatureLength = crypto_sign_BYTES;\n    nacl.hash = function(msg) {\n        checkArrayTypes(msg);\n        var h = new Uint8Array(crypto_hash_BYTES);\n        crypto_hash(h, msg, msg.length);\n        return h;\n    };\n    nacl.hash.hashLength = crypto_hash_BYTES;\n    nacl.verify = function(x, y) {\n        checkArrayTypes(x, y);\n        if (x.length === 0 || y.length === 0) return false;\n        if (x.length !== y.length) return false;\n        return vn(x, 0, y, 0, x.length) === 0 ? true : false;\n    };\n    nacl.setPRNG = function(fn) {\n        randombytes = fn;\n    };\n    (function() {\n        var crypto1 = typeof globalThis !== 'undefined' ? globalThis.crypto || globalThis.msCrypto : null;\n        if (crypto1 && crypto1.getRandomValues) {\n            var QUOTA = 65536;\n            nacl.setPRNG(function(x, n) {\n                var i, v = new Uint8Array(n);\n                for(i = 0; i < n; i += QUOTA){\n                    crypto1.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));\n                }\n                for(i = 0; i < n; i++)x[i] = v[i];\n                cleanup(v);\n            });\n        } else if (typeof require !== 'undefined') {\n            crypto1 = require('crypto');\n            if (crypto1 && crypto1.randomBytes) {\n                nacl.setPRNG(function(x, n) {\n                    var i, v = crypto1.randomBytes(n);\n                    for(i = 0; i < n; i++)x[i] = v[i];\n                    cleanup(v);\n                });\n            }\n        }\n    })();\n})(typeof module !== 'undefined' && module.exports ? module.exports : globalThis.nacl = globalThis.nacl || {});\nconst nacl = globalThis.nacl;\nconst denoHelper = {\n    fromSeed: nacl.sign.keyPair.fromSeed,\n    sign: nacl.sign.detached,\n    verify: nacl.sign.detached.verify,\n    randomBytes: nacl.randomBytes\n};\nlet helper;\nfunction setEd25519Helper(lib) {\n    helper = lib;\n}\nfunction getEd25519Helper() {\n    return helper;\n}\nconst crc16tab = new Uint16Array([\n    0x0000,\n    0x1021,\n    0x2042,\n    0x3063,\n    0x4084,\n    0x50a5,\n    0x60c6,\n    0x70e7,\n    0x8108,\n    0x9129,\n    0xa14a,\n    0xb16b,\n    0xc18c,\n    0xd1ad,\n    0xe1ce,\n    0xf1ef,\n    0x1231,\n    0x0210,\n    0x3273,\n    0x2252,\n    0x52b5,\n    0x4294,\n    0x72f7,\n    0x62d6,\n    0x9339,\n    0x8318,\n    0xb37b,\n    0xa35a,\n    0xd3bd,\n    0xc39c,\n    0xf3ff,\n    0xe3de,\n    0x2462,\n    0x3443,\n    0x0420,\n    0x1401,\n    0x64e6,\n    0x74c7,\n    0x44a4,\n    0x5485,\n    0xa56a,\n    0xb54b,\n    0x8528,\n    0x9509,\n    0xe5ee,\n    0xf5cf,\n    0xc5ac,\n    0xd58d,\n    0x3653,\n    0x2672,\n    0x1611,\n    0x0630,\n    0x76d7,\n    0x66f6,\n    0x5695,\n    0x46b4,\n    0xb75b,\n    0xa77a,\n    0x9719,\n    0x8738,\n    0xf7df,\n    0xe7fe,\n    0xd79d,\n    0xc7bc,\n    0x48c4,\n    0x58e5,\n    0x6886,\n    0x78a7,\n    0x0840,\n    0x1861,\n    0x2802,\n    0x3823,\n    0xc9cc,\n    0xd9ed,\n    0xe98e,\n    0xf9af,\n    0x8948,\n    0x9969,\n    0xa90a,\n    0xb92b,\n    0x5af5,\n    0x4ad4,\n    0x7ab7,\n    0x6a96,\n    0x1a71,\n    0x0a50,\n    0x3a33,\n    0x2a12,\n    0xdbfd,\n    0xcbdc,\n    0xfbbf,\n    0xeb9e,\n    0x9b79,\n    0x8b58,\n    0xbb3b,\n    0xab1a,\n    0x6ca6,\n    0x7c87,\n    0x4ce4,\n    0x5cc5,\n    0x2c22,\n    0x3c03,\n    0x0c60,\n    0x1c41,\n    0xedae,\n    0xfd8f,\n    0xcdec,\n    0xddcd,\n    0xad2a,\n    0xbd0b,\n    0x8d68,\n    0x9d49,\n    0x7e97,\n    0x6eb6,\n    0x5ed5,\n    0x4ef4,\n    0x3e13,\n    0x2e32,\n    0x1e51,\n    0x0e70,\n    0xff9f,\n    0xefbe,\n    0xdfdd,\n    0xcffc,\n    0xbf1b,\n    0xaf3a,\n    0x9f59,\n    0x8f78,\n    0x9188,\n    0x81a9,\n    0xb1ca,\n    0xa1eb,\n    0xd10c,\n    0xc12d,\n    0xf14e,\n    0xe16f,\n    0x1080,\n    0x00a1,\n    0x30c2,\n    0x20e3,\n    0x5004,\n    0x4025,\n    0x7046,\n    0x6067,\n    0x83b9,\n    0x9398,\n    0xa3fb,\n    0xb3da,\n    0xc33d,\n    0xd31c,\n    0xe37f,\n    0xf35e,\n    0x02b1,\n    0x1290,\n    0x22f3,\n    0x32d2,\n    0x4235,\n    0x5214,\n    0x6277,\n    0x7256,\n    0xb5ea,\n    0xa5cb,\n    0x95a8,\n    0x8589,\n    0xf56e,\n    0xe54f,\n    0xd52c,\n    0xc50d,\n    0x34e2,\n    0x24c3,\n    0x14a0,\n    0x0481,\n    0x7466,\n    0x6447,\n    0x5424,\n    0x4405,\n    0xa7db,\n    0xb7fa,\n    0x8799,\n    0x97b8,\n    0xe75f,\n    0xf77e,\n    0xc71d,\n    0xd73c,\n    0x26d3,\n    0x36f2,\n    0x0691,\n    0x16b0,\n    0x6657,\n    0x7676,\n    0x4615,\n    0x5634,\n    0xd94c,\n    0xc96d,\n    0xf90e,\n    0xe92f,\n    0x99c8,\n    0x89e9,\n    0xb98a,\n    0xa9ab,\n    0x5844,\n    0x4865,\n    0x7806,\n    0x6827,\n    0x18c0,\n    0x08e1,\n    0x3882,\n    0x28a3,\n    0xcb7d,\n    0xdb5c,\n    0xeb3f,\n    0xfb1e,\n    0x8bf9,\n    0x9bd8,\n    0xabbb,\n    0xbb9a,\n    0x4a75,\n    0x5a54,\n    0x6a37,\n    0x7a16,\n    0x0af1,\n    0x1ad0,\n    0x2ab3,\n    0x3a92,\n    0xfd2e,\n    0xed0f,\n    0xdd6c,\n    0xcd4d,\n    0xbdaa,\n    0xad8b,\n    0x9de8,\n    0x8dc9,\n    0x7c26,\n    0x6c07,\n    0x5c64,\n    0x4c45,\n    0x3ca2,\n    0x2c83,\n    0x1ce0,\n    0x0cc1,\n    0xef1f,\n    0xff3e,\n    0xcf5d,\n    0xdf7c,\n    0xaf9b,\n    0xbfba,\n    0x8fd9,\n    0x9ff8,\n    0x6e17,\n    0x7e36,\n    0x4e55,\n    0x5e74,\n    0x2e93,\n    0x3eb2,\n    0x0ed1,\n    0x1ef0, \n]);\nclass crc16 {\n    static checksum(data) {\n        let crc = 0;\n        for(let i = 0; i < data.byteLength; i++){\n            let b = data[i];\n            crc = crc << 8 & 0xffff ^ crc16tab[(crc >> 8 ^ b) & 0x00FF];\n        }\n        return crc;\n    }\n    static validate(data, expected) {\n        let ba = crc16.checksum(data);\n        return ba == expected;\n    }\n}\nconst b32Alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\";\nclass base32 {\n    static encode(src) {\n        let bits = 0;\n        let value = 0;\n        let a = new Uint8Array(src);\n        let buf = new Uint8Array(src.byteLength * 2);\n        let j = 0;\n        for(let i = 0; i < a.byteLength; i++){\n            value = value << 8 | a[i];\n            bits += 8;\n            while(bits >= 5){\n                let index = value >>> bits - 5 & 31;\n                buf[j++] = b32Alphabet.charAt(index).charCodeAt(0);\n                bits -= 5;\n            }\n        }\n        if (bits > 0) {\n            let index1 = value << 5 - bits & 31;\n            buf[j++] = b32Alphabet.charAt(index1).charCodeAt(0);\n        }\n        return buf.slice(0, j);\n    }\n    static decode(src) {\n        let bits = 0;\n        let __byte = 0;\n        let j = 0;\n        let a = new Uint8Array(src);\n        let out = new Uint8Array(a.byteLength * 5 / 8 | 0);\n        for(let i = 0; i < a.byteLength; i++){\n            let v = String.fromCharCode(a[i]);\n            let vv = b32Alphabet.indexOf(v);\n            if (vv === -1) {\n                throw new Error(\"Illegal Base32 character: \" + a[i]);\n            }\n            __byte = __byte << 5 | vv;\n            bits += 5;\n            if (bits >= 8) {\n                out[j++] = __byte >>> bits - 8 & 255;\n                bits -= 8;\n            }\n        }\n        return out.slice(0, j);\n    }\n}\nclass NKeysError extends Error {\n    name;\n    code;\n    chainedError;\n    constructor(code, chainedError){\n        super(code);\n        this.name = \"NKeysError\";\n        this.code = code;\n        this.chainedError = chainedError;\n    }\n}\nfunction createOperator() {\n    return createPair(Prefix.Operator);\n}\nfunction createAccount() {\n    return createPair(Prefix.Account);\n}\nfunction createUser() {\n    return createPair(Prefix.User);\n}\nvar NKeysErrorCode;\n(function(NKeysErrorCode) {\n    NKeysErrorCode[\"InvalidPrefixByte\"] = \"nkeys: invalid prefix byte\";\n    NKeysErrorCode[\"InvalidKey\"] = \"nkeys: invalid key\";\n    NKeysErrorCode[\"InvalidPublicKey\"] = \"nkeys: invalid public key\";\n    NKeysErrorCode[\"InvalidSeedLen\"] = \"nkeys: invalid seed length\";\n    NKeysErrorCode[\"InvalidSeed\"] = \"nkeys: invalid seed\";\n    NKeysErrorCode[\"InvalidEncoding\"] = \"nkeys: invalid encoded key\";\n    NKeysErrorCode[\"InvalidSignature\"] = \"nkeys: signature verification failed\";\n    NKeysErrorCode[\"CannotSign\"] = \"nkeys: cannot sign, no private key available\";\n    NKeysErrorCode[\"PublicKeyOnly\"] = \"nkeys: no seed or private key available\";\n    NKeysErrorCode[\"InvalidChecksum\"] = \"nkeys: invalid checksum\";\n    NKeysErrorCode[\"SerializationError\"] = \"nkeys: serialization error\";\n    NKeysErrorCode[\"ApiError\"] = \"nkeys: api error\";\n    NKeysErrorCode[\"ClearedPair\"] = \"nkeys: pair is cleared\";\n})(NKeysErrorCode || (NKeysErrorCode = {}));\nvar Prefix;\n(function(Prefix) {\n    Prefix[Prefix[\"Seed\"] = 144] = \"Seed\";\n    Prefix[Prefix[\"Private\"] = 120] = \"Private\";\n    Prefix[Prefix[\"Operator\"] = 112] = \"Operator\";\n    Prefix[Prefix[\"Server\"] = 104] = \"Server\";\n    Prefix[Prefix[\"Cluster\"] = 16] = \"Cluster\";\n    Prefix[Prefix[\"Account\"] = 0] = \"Account\";\n    Prefix[Prefix[\"User\"] = 160] = \"User\";\n})(Prefix || (Prefix = {}));\nclass Prefixes {\n    static isValidPublicPrefix(prefix) {\n        return prefix == Prefix.Server || prefix == Prefix.Operator || prefix == Prefix.Cluster || prefix == Prefix.Account || prefix == Prefix.User;\n    }\n    static startsWithValidPrefix(s) {\n        let c = s[0];\n        return c == \"S\" || c == \"P\" || c == \"O\" || c == \"N\" || c == \"C\" || c == \"A\" || c == \"U\";\n    }\n    static isValidPrefix(prefix) {\n        let v = this.parsePrefix(prefix);\n        return v != -1;\n    }\n    static parsePrefix(v) {\n        switch(v){\n            case Prefix.Seed:\n                return Prefix.Seed;\n            case Prefix.Private:\n                return Prefix.Private;\n            case Prefix.Operator:\n                return Prefix.Operator;\n            case Prefix.Server:\n                return Prefix.Server;\n            case Prefix.Cluster:\n                return Prefix.Cluster;\n            case Prefix.Account:\n                return Prefix.Account;\n            case Prefix.User:\n                return Prefix.User;\n            default:\n                return -1;\n        }\n    }\n}\nclass Codec {\n    static encode(prefix, src) {\n        if (!src || !(src instanceof Uint8Array)) {\n            throw new NKeysError(NKeysErrorCode.SerializationError);\n        }\n        if (!Prefixes.isValidPrefix(prefix)) {\n            throw new NKeysError(NKeysErrorCode.InvalidPrefixByte);\n        }\n        return Codec._encode(false, prefix, src);\n    }\n    static encodeSeed(role, src) {\n        if (!src) {\n            throw new NKeysError(NKeysErrorCode.ApiError);\n        }\n        if (!Prefixes.isValidPublicPrefix(role)) {\n            throw new NKeysError(NKeysErrorCode.InvalidPrefixByte);\n        }\n        if (src.byteLength !== 32) {\n            throw new NKeysError(NKeysErrorCode.InvalidSeedLen);\n        }\n        return Codec._encode(true, role, src);\n    }\n    static decode(expected, src) {\n        if (!Prefixes.isValidPrefix(expected)) {\n            throw new NKeysError(NKeysErrorCode.InvalidPrefixByte);\n        }\n        const raw = Codec._decode(src);\n        if (raw[0] !== expected) {\n            throw new NKeysError(NKeysErrorCode.InvalidPrefixByte);\n        }\n        return raw.slice(1);\n    }\n    static decodeSeed(src) {\n        const raw = Codec._decode(src);\n        const prefix = Codec._decodePrefix(raw);\n        if (prefix[0] != Prefix.Seed) {\n            throw new NKeysError(NKeysErrorCode.InvalidSeed);\n        }\n        if (!Prefixes.isValidPublicPrefix(prefix[1])) {\n            throw new NKeysError(NKeysErrorCode.InvalidPrefixByte);\n        }\n        return {\n            buf: raw.slice(2),\n            prefix: prefix[1]\n        };\n    }\n    static _encode(seed, role, payload) {\n        const payloadOffset = seed ? 2 : 1;\n        const payloadLen = payload.byteLength;\n        const cap = payloadOffset + payloadLen + 2;\n        const checkOffset = payloadOffset + payloadLen;\n        const raw = new Uint8Array(cap);\n        if (seed) {\n            const encodedPrefix = Codec._encodePrefix(Prefix.Seed, role);\n            raw.set(encodedPrefix);\n        } else {\n            raw[0] = role;\n        }\n        raw.set(payload, payloadOffset);\n        const checksum = crc16.checksum(raw.slice(0, checkOffset));\n        const dv = new DataView(raw.buffer);\n        dv.setUint16(checkOffset, checksum, true);\n        return base32.encode(raw);\n    }\n    static _decode(src) {\n        if (src.byteLength < 4) {\n            throw new NKeysError(NKeysErrorCode.InvalidEncoding);\n        }\n        let raw;\n        try {\n            raw = base32.decode(src);\n        } catch (ex) {\n            throw new NKeysError(NKeysErrorCode.InvalidEncoding, ex);\n        }\n        const checkOffset = raw.byteLength - 2;\n        const dv = new DataView(raw.buffer);\n        const checksum = dv.getUint16(checkOffset, true);\n        const payload = raw.slice(0, checkOffset);\n        if (!crc16.validate(payload, checksum)) {\n            throw new NKeysError(NKeysErrorCode.InvalidChecksum);\n        }\n        return payload;\n    }\n    static _encodePrefix(kind, role) {\n        const b1 = kind | role >> 5;\n        const b2 = (role & 31) << 3;\n        return new Uint8Array([\n            b1,\n            b2\n        ]);\n    }\n    static _decodePrefix(raw) {\n        const b1 = raw[0] & 248;\n        const b2 = (raw[0] & 7) << 5 | (raw[1] & 248) >> 3;\n        return new Uint8Array([\n            b1,\n            b2\n        ]);\n    }\n}\nclass KP {\n    seed;\n    constructor(seed){\n        this.seed = seed;\n    }\n    getRawSeed() {\n        if (!this.seed) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        let sd = Codec.decodeSeed(this.seed);\n        return sd.buf;\n    }\n    getSeed() {\n        if (!this.seed) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        return this.seed;\n    }\n    getPublicKey() {\n        if (!this.seed) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        const sd = Codec.decodeSeed(this.seed);\n        const kp = getEd25519Helper().fromSeed(this.getRawSeed());\n        const buf = Codec.encode(sd.prefix, kp.publicKey);\n        return new TextDecoder().decode(buf);\n    }\n    getPrivateKey() {\n        if (!this.seed) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        const kp = getEd25519Helper().fromSeed(this.getRawSeed());\n        return Codec.encode(Prefix.Private, kp.secretKey);\n    }\n    sign(input) {\n        if (!this.seed) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        const kp = getEd25519Helper().fromSeed(this.getRawSeed());\n        return getEd25519Helper().sign(input, kp.secretKey);\n    }\n    verify(input, sig) {\n        if (!this.seed) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        const kp = getEd25519Helper().fromSeed(this.getRawSeed());\n        return getEd25519Helper().verify(input, sig, kp.publicKey);\n    }\n    clear() {\n        if (!this.seed) {\n            return;\n        }\n        this.seed.fill(0);\n        this.seed = undefined;\n    }\n}\nfunction createPair(prefix) {\n    const rawSeed = getEd25519Helper().randomBytes(32);\n    let str = Codec.encodeSeed(prefix, new Uint8Array(rawSeed));\n    return new KP(str);\n}\nclass PublicKey {\n    publicKey;\n    constructor(publicKey){\n        this.publicKey = publicKey;\n    }\n    getPublicKey() {\n        if (!this.publicKey) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        return new TextDecoder().decode(this.publicKey);\n    }\n    getPrivateKey() {\n        if (!this.publicKey) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        throw new NKeysError(NKeysErrorCode.PublicKeyOnly);\n    }\n    getSeed() {\n        if (!this.publicKey) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        throw new NKeysError(NKeysErrorCode.PublicKeyOnly);\n    }\n    sign(_) {\n        if (!this.publicKey) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        throw new NKeysError(NKeysErrorCode.CannotSign);\n    }\n    verify(input, sig) {\n        if (!this.publicKey) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        let buf = Codec._decode(this.publicKey);\n        return getEd25519Helper().verify(input, sig, buf.slice(1));\n    }\n    clear() {\n        if (!this.publicKey) {\n            return;\n        }\n        this.publicKey.fill(0);\n        this.publicKey = undefined;\n    }\n}\nfunction fromPublic(src) {\n    const ba = new TextEncoder().encode(src);\n    const raw = Codec._decode(ba);\n    const prefix = Prefixes.parsePrefix(raw[0]);\n    if (Prefixes.isValidPublicPrefix(prefix)) {\n        return new PublicKey(ba);\n    }\n    throw new NKeysError(NKeysErrorCode.InvalidPublicKey);\n}\nfunction fromSeed(src) {\n    Codec.decodeSeed(src);\n    return new KP(src);\n}\nfunction encode2(bytes) {\n    return btoa(String.fromCharCode(...bytes));\n}\nfunction decode2(b64str) {\n    const bin = atob(b64str);\n    const bytes = new Uint8Array(bin.length);\n    for(let i = 0; i < bin.length; i++){\n        bytes[i] = bin.charCodeAt(i);\n    }\n    return bytes;\n}\nsetEd25519Helper(denoHelper);\nconst mod = {\n    createAccount,\n    createOperator,\n    createPair,\n    createUser,\n    fromPublic,\n    fromSeed,\n    NKeysError,\n    NKeysErrorCode,\n    Prefix,\n    decode: decode2,\n    encode: encode2\n};\nfunction buildAuthenticator(opts) {\n    if (opts.authenticator) {\n        return opts.authenticator;\n    }\n    if (opts.token) {\n        return tokenAuthenticator(opts.token);\n    }\n    if (opts.user) {\n        return usernamePasswordAuthenticator(opts.user, opts.pass);\n    }\n    return noAuthFn();\n}\nfunction noAuthFn() {\n    return ()=>{\n        return;\n    };\n}\nfunction usernamePasswordAuthenticator(user, pass) {\n    return ()=>{\n        return {\n            user,\n            pass\n        };\n    };\n}\nfunction tokenAuthenticator(token) {\n    return ()=>{\n        return {\n            auth_token: token\n        };\n    };\n}\nfunction nkeyAuthenticator(seed) {\n    return (nonce)=>{\n        seed = typeof seed === \"function\" ? seed() : seed;\n        const kp = seed ? mod.fromSeed(seed) : undefined;\n        const nkey = kp ? kp.getPublicKey() : \"\";\n        const challenge = TE.encode(nonce || \"\");\n        const sigBytes = kp !== undefined && nonce ? kp.sign(challenge) : undefined;\n        const sig = sigBytes ? mod.encode(sigBytes) : \"\";\n        return {\n            nkey,\n            sig\n        };\n    };\n}\nfunction jwtAuthenticator(ajwt, seed) {\n    return (nonce)=>{\n        const jwt = typeof ajwt === \"function\" ? ajwt() : ajwt;\n        const fn = nkeyAuthenticator(seed);\n        const { nkey , sig  } = fn(nonce);\n        return {\n            jwt,\n            nkey,\n            sig\n        };\n    };\n}\nfunction credsAuthenticator(creds) {\n    const CREDS = /\\s*(?:(?:[-]{3,}[^\\n]*[-]{3,}\\n)(.+)(?:\\n\\s*[-]{3,}[^\\n]*[-]{3,}\\n))/ig;\n    const s = TD.decode(creds);\n    let m = CREDS.exec(s);\n    if (!m) {\n        throw NatsError.errorForCode(ErrorCode.BadCreds);\n    }\n    const jwt = m[1].trim();\n    m = CREDS.exec(s);\n    if (!m) {\n        throw NatsError.errorForCode(ErrorCode.BadCreds);\n    }\n    const seed = TE.encode(m[1].trim());\n    return jwtAuthenticator(jwt, seed);\n}\nclass StreamAPIImpl extends BaseApiClient {\n    constructor(nc, opts){\n        super(nc, opts);\n    }\n    async add(cfg = {}) {\n        validateStreamName(cfg.name);\n        const r = await this._request(`${this.prefix}.STREAM.CREATE.${cfg.name}`, cfg);\n        const si = r;\n        this._fixInfo(si);\n        return si;\n    }\n    async delete(stream) {\n        validateStreamName(stream);\n        const r = await this._request(`${this.prefix}.STREAM.DELETE.${stream}`);\n        const cr = r;\n        return cr.success;\n    }\n    async update(name, cfg = {}) {\n        if (typeof name === \"object\") {\n            const sc = name;\n            name = sc.name;\n            cfg = sc;\n            console.trace(`\\u001B[33m >> streams.update(config: StreamConfig) api changed to streams.update(name: string, config: StreamUpdateConfig) - this shim will be removed - update your code.  \\u001B[0m`);\n        }\n        validateStreamName(name);\n        const old = await this.info(name);\n        const update = Object.assign(old.config, cfg);\n        const r = await this._request(`${this.prefix}.STREAM.UPDATE.${name}`, update);\n        const si = r;\n        this._fixInfo(si);\n        return si;\n    }\n    async info(name, data) {\n        validateStreamName(name);\n        const r = await this._request(`${this.prefix}.STREAM.INFO.${name}`, data);\n        const si = r;\n        this._fixInfo(si);\n        return si;\n    }\n    list() {\n        const filter = (v)=>{\n            const slr = v;\n            slr.streams.forEach((si)=>{\n                this._fixInfo(si);\n            });\n            return slr.streams;\n        };\n        const subj = `${this.prefix}.STREAM.LIST`;\n        return new ListerImpl(subj, filter, this);\n    }\n    _fixInfo(si) {\n        si.config.sealed = si.config.sealed || false;\n        si.config.deny_delete = si.config.deny_delete || false;\n        si.config.deny_purge = si.config.deny_purge || false;\n        si.config.allow_rollup_hdrs = si.config.allow_rollup_hdrs || false;\n    }\n    async purge(name, opts) {\n        if (opts) {\n            const { keep , seq  } = opts;\n            if (typeof keep === \"number\" && typeof seq === \"number\") {\n                throw new Error(\"can specify one of keep or seq\");\n            }\n        }\n        validateStreamName(name);\n        const v = await this._request(`${this.prefix}.STREAM.PURGE.${name}`, opts);\n        return v;\n    }\n    async deleteMessage(stream, seq, erase = true) {\n        validateStreamName(stream);\n        const dr = {\n            seq\n        };\n        if (!erase) {\n            dr.no_erase = true;\n        }\n        const r = await this._request(`${this.prefix}.STREAM.MSG.DELETE.${stream}`, dr);\n        const cr = r;\n        return cr.success;\n    }\n    async getMessage(stream, query) {\n        validateStreamName(stream);\n        const r = await this._request(`${this.prefix}.STREAM.MSG.GET.${stream}`, query);\n        const sm = r;\n        return new StoredMsgImpl(sm);\n    }\n    find(subject) {\n        return this.findStream(subject);\n    }\n}\nclass StoredMsgImpl {\n    subject;\n    seq;\n    data;\n    time;\n    header;\n    constructor(smr){\n        this.subject = smr.message.subject;\n        this.seq = smr.message.seq;\n        this.time = new Date(Date.parse(smr.message.time));\n        this.data = smr.message.data ? this._parse(smr.message.data) : Empty;\n        if (smr.message.hdrs) {\n            const hd = this._parse(smr.message.hdrs);\n            this.header = MsgHdrsImpl.decode(hd);\n        } else {\n            this.header = headers();\n        }\n    }\n    _parse(s) {\n        const bs = atob(s);\n        const len = bs.length;\n        const bytes = new Uint8Array(len);\n        for(let i = 0; i < len; i++){\n            bytes[i] = bs.charCodeAt(i);\n        }\n        return bytes;\n    }\n}\nclass DirectStreamAPIImpl extends BaseApiClient {\n    constructor(nc, opts){\n        super(nc, opts);\n    }\n    async getMessage(stream, query) {\n        validateStreamName(stream);\n        let qq = query;\n        const { last_by_subj  } = qq;\n        if (last_by_subj) {\n            qq = null;\n        }\n        const payload = qq ? this.jc.encode(qq) : Empty;\n        const subj = last_by_subj ? `$JS.API.DIRECT.GET.${stream}.${last_by_subj}` : `$JS.API.DIRECT.GET.${stream}`;\n        const r = await this.nc.request(subj, payload);\n        const err = checkJsError(r);\n        if (err) {\n            return Promise.reject(err);\n        }\n        const dm = new DirectMsgImpl(r);\n        return Promise.resolve(dm);\n    }\n}\nclass DirectMsgImpl {\n    data;\n    header;\n    constructor(m){\n        if (!m.headers) {\n            throw new Error(\"headers expected\");\n        }\n        this.data = m.data;\n        this.header = m.headers;\n    }\n    get subject() {\n        return this.header.get(DirectMsgHeaders.Subject);\n    }\n    get seq() {\n        const v = this.header.get(DirectMsgHeaders.Sequence);\n        return typeof v === \"string\" ? parseInt(v) : 0;\n    }\n    get time() {\n        return new Date(Date.parse(this.header.get(DirectMsgHeaders.TimeStamp)));\n    }\n    get stream() {\n        return this.header.get(DirectMsgHeaders.Stream);\n    }\n}\nclass JetStreamManagerImpl extends BaseApiClient {\n    streams;\n    consumers;\n    direct;\n    constructor(nc, opts){\n        super(nc, opts);\n        this.streams = new StreamAPIImpl(nc, opts);\n        this.consumers = new ConsumerAPIImpl(nc, opts);\n        this.direct = new DirectStreamAPIImpl(nc, opts);\n    }\n    async getAccountInfo() {\n        const r = await this._request(`${this.prefix}.INFO`);\n        return r;\n    }\n    advisories() {\n        const iter = new QueuedIteratorImpl();\n        this.nc.subscribe(`$JS.EVENT.ADVISORY.>`, {\n            callback: (err, msg)=>{\n                if (err) {\n                    throw err;\n                }\n                try {\n                    const d = this.parseJsResponse(msg);\n                    const chunks = d.type.split(\".\");\n                    const kind = chunks[chunks.length - 1];\n                    iter.push({\n                        kind: kind,\n                        data: d\n                    });\n                } catch (err1) {\n                    iter.stop(err1);\n                }\n            }\n        });\n        return iter;\n    }\n}\nclass Metric {\n    name;\n    duration;\n    date;\n    payload;\n    msgs;\n    lang;\n    version;\n    bytes;\n    asyncRequests;\n    min;\n    max;\n    constructor(name, duration){\n        this.name = name;\n        this.duration = duration;\n        this.date = Date.now();\n        this.payload = 0;\n        this.msgs = 0;\n        this.bytes = 0;\n    }\n    toString() {\n        const sec = this.duration / 1000;\n        const mps = Math.round(this.msgs / sec);\n        const label = this.asyncRequests ? \"asyncRequests\" : \"\";\n        let minmax = \"\";\n        if (this.max) {\n            minmax = `${this.min}/${this.max}`;\n        }\n        return `${this.name}${label ? \" [asyncRequests]\" : \"\"} ${humanizeNumber(mps)} msgs/sec - [${sec.toFixed(2)} secs] ~ ${throughput(this.bytes, sec)} ${minmax}`;\n    }\n    toCsv() {\n        return `\"${this.name}\",${new Date(this.date).toISOString()},${this.lang},${this.version},${this.msgs},${this.payload},${this.bytes},${this.duration},${this.asyncRequests ? this.asyncRequests : false}\\n`;\n    }\n    static header() {\n        return `Test,Date,Lang,Version,Count,MsgPayload,Bytes,Millis,Async\\n`;\n    }\n}\nclass Bench {\n    nc;\n    callbacks;\n    msgs;\n    size;\n    subject;\n    asyncRequests;\n    pub;\n    sub;\n    req;\n    rep;\n    perf;\n    payload;\n    constructor(nc, opts = {\n        msgs: 100000,\n        size: 128,\n        subject: \"\",\n        asyncRequests: false,\n        pub: false,\n        sub: false,\n        req: false,\n        rep: false\n    }){\n        this.nc = nc;\n        this.callbacks = opts.callbacks || false;\n        this.msgs = opts.msgs || 0;\n        this.size = opts.size || 0;\n        this.subject = opts.subject || nuid.next();\n        this.asyncRequests = opts.asyncRequests || false;\n        this.pub = opts.pub || false;\n        this.sub = opts.sub || false;\n        this.req = opts.req || false;\n        this.rep = opts.rep || false;\n        this.perf = new Perf();\n        this.payload = this.size ? new Uint8Array(this.size) : Empty;\n        if (!this.pub && !this.sub && !this.req && !this.rep) {\n            throw new Error(\"no bench option selected\");\n        }\n    }\n    async run() {\n        this.nc.closed().then((err)=>{\n            if (err) {\n                throw new NatsError(`bench closed with an error: ${err.message}`, ErrorCode.Unknown, err);\n            }\n        });\n        if (this.callbacks) {\n            await this.runCallbacks();\n        } else {\n            await this.runAsync();\n        }\n        return this.processMetrics();\n    }\n    processMetrics() {\n        const nc = this.nc;\n        const { lang , version  } = nc.protocol.transport;\n        if (this.pub && this.sub) {\n            this.perf.measure(\"pubsub\", \"pubStart\", \"subStop\");\n        }\n        const measures = this.perf.getEntries();\n        const pubsub = measures.find((m)=>m.name === \"pubsub\");\n        const req = measures.find((m)=>m.name === \"req\");\n        const pub = measures.find((m)=>m.name === \"pub\");\n        const sub = measures.find((m)=>m.name === \"sub\");\n        const stats = this.nc.stats();\n        const metrics = [];\n        if (pubsub) {\n            const { name , duration  } = pubsub;\n            const m = new Metric(name, duration);\n            m.msgs = this.msgs * 2;\n            m.bytes = stats.inBytes + stats.outBytes;\n            m.lang = lang;\n            m.version = version;\n            m.payload = this.payload.length;\n            metrics.push(m);\n        }\n        if (pub) {\n            const { name: name1 , duration: duration1  } = pub;\n            const m1 = new Metric(name1, duration1);\n            m1.msgs = this.msgs;\n            m1.bytes = stats.outBytes;\n            m1.lang = lang;\n            m1.version = version;\n            m1.payload = this.payload.length;\n            metrics.push(m1);\n        }\n        if (sub) {\n            const { name: name2 , duration: duration2  } = sub;\n            const m2 = new Metric(name2, duration2);\n            m2.msgs = this.msgs;\n            m2.bytes = stats.inBytes;\n            m2.lang = lang;\n            m2.version = version;\n            m2.payload = this.payload.length;\n            metrics.push(m2);\n        }\n        if (req) {\n            const { name: name3 , duration: duration3  } = req;\n            const m3 = new Metric(name3, duration3);\n            m3.msgs = this.msgs * 2;\n            m3.bytes = stats.inBytes + stats.outBytes;\n            m3.lang = lang;\n            m3.version = version;\n            m3.payload = this.payload.length;\n            metrics.push(m3);\n        }\n        return metrics;\n    }\n    async runCallbacks() {\n        const jobs = [];\n        if (this.req) {\n            const d = deferred();\n            jobs.push(d);\n            const sub = this.nc.subscribe(this.subject, {\n                max: this.msgs,\n                callback: (_, m)=>{\n                    m.respond(this.payload);\n                    if (sub.getProcessed() === this.msgs) {\n                        d.resolve();\n                    }\n                }\n            });\n        }\n        if (this.sub) {\n            const d1 = deferred();\n            jobs.push(d1);\n            let i = 0;\n            this.nc.subscribe(this.subject, {\n                max: this.msgs,\n                callback: ()=>{\n                    i++;\n                    if (i === 1) {\n                        this.perf.mark(\"subStart\");\n                    }\n                    if (i === this.msgs) {\n                        this.perf.mark(\"subStop\");\n                        this.perf.measure(\"sub\", \"subStart\", \"subStop\");\n                        d1.resolve();\n                    }\n                }\n            });\n        }\n        if (this.pub) {\n            const job = (async ()=>{\n                this.perf.mark(\"pubStart\");\n                for(let i = 0; i < this.msgs; i++){\n                    this.nc.publish(this.subject, this.payload);\n                }\n                await this.nc.flush();\n                this.perf.mark(\"pubStop\");\n                this.perf.measure(\"pub\", \"pubStart\", \"pubStop\");\n            })();\n            jobs.push(job);\n        }\n        if (this.req) {\n            const job1 = (async ()=>{\n                if (this.asyncRequests) {\n                    this.perf.mark(\"reqStart\");\n                    const a = [];\n                    for(let i = 0; i < this.msgs; i++){\n                        a.push(this.nc.request(this.subject, this.payload, {\n                            timeout: 20000\n                        }));\n                    }\n                    await Promise.all(a);\n                    this.perf.mark(\"reqStop\");\n                    this.perf.measure(\"req\", \"reqStart\", \"reqStop\");\n                } else {\n                    this.perf.mark(\"reqStart\");\n                    for(let i1 = 0; i1 < this.msgs; i1++){\n                        await this.nc.request(this.subject);\n                    }\n                    this.perf.mark(\"reqStop\");\n                    this.perf.measure(\"req\", \"reqStart\", \"reqStop\");\n                }\n            })();\n            jobs.push(job1);\n        }\n        await Promise.all(jobs);\n    }\n    async runAsync() {\n        const jobs = [];\n        if (this.req) {\n            const sub = this.nc.subscribe(this.subject, {\n                max: this.msgs\n            });\n            const job = (async ()=>{\n                for await (const m of sub){\n                    m.respond(this.payload);\n                }\n            })();\n            jobs.push(job);\n        }\n        if (this.sub) {\n            let first = false;\n            const sub1 = this.nc.subscribe(this.subject, {\n                max: this.msgs\n            });\n            const job1 = (async ()=>{\n                for await (const _m of sub1){\n                    if (!first) {\n                        this.perf.mark(\"subStart\");\n                        first = true;\n                    }\n                }\n                this.perf.mark(\"subStop\");\n                this.perf.measure(\"sub\", \"subStart\", \"subStop\");\n            })();\n            jobs.push(job1);\n        }\n        if (this.pub) {\n            const job2 = (async ()=>{\n                this.perf.mark(\"pubStart\");\n                for(let i = 0; i < this.msgs; i++){\n                    this.nc.publish(this.subject, this.payload);\n                }\n                await this.nc.flush();\n                this.perf.mark(\"pubStop\");\n                this.perf.measure(\"pub\", \"pubStart\", \"pubStop\");\n            })();\n            jobs.push(job2);\n        }\n        if (this.req) {\n            const job3 = (async ()=>{\n                if (this.asyncRequests) {\n                    this.perf.mark(\"reqStart\");\n                    const a = [];\n                    for(let i = 0; i < this.msgs; i++){\n                        a.push(this.nc.request(this.subject, this.payload, {\n                            timeout: 20000\n                        }));\n                    }\n                    await Promise.all(a);\n                    this.perf.mark(\"reqStop\");\n                    this.perf.measure(\"req\", \"reqStart\", \"reqStop\");\n                } else {\n                    this.perf.mark(\"reqStart\");\n                    for(let i1 = 0; i1 < this.msgs; i1++){\n                        await this.nc.request(this.subject);\n                    }\n                    this.perf.mark(\"reqStop\");\n                    this.perf.measure(\"req\", \"reqStart\", \"reqStop\");\n                }\n            })();\n            jobs.push(job3);\n        }\n        await Promise.all(jobs);\n    }\n}\nfunction throughput(bytes, seconds) {\n    return humanizeBytes(bytes / seconds);\n}\nfunction humanizeBytes(bytes, si = false) {\n    const base = si ? 1000 : 1024;\n    const pre = si ? [\n        \"k\",\n        \"M\",\n        \"G\",\n        \"T\",\n        \"P\",\n        \"E\"\n    ] : [\n        \"K\",\n        \"M\",\n        \"G\",\n        \"T\",\n        \"P\",\n        \"E\"\n    ];\n    const post = si ? \"iB\" : \"B\";\n    if (bytes < base) {\n        return `${bytes.toFixed(2)} ${post}/sec`;\n    }\n    const exp = parseInt(Math.log(bytes) / Math.log(base) + \"\");\n    const index = parseInt(exp - 1 + \"\");\n    return `${(bytes / Math.pow(base, exp)).toFixed(2)} ${pre[index]}${post}/sec`;\n}\nfunction humanizeNumber(n) {\n    return n.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n}\n\nfunction defaultOptions() {\n    return {\n        maxPingOut: 2,\n        maxReconnectAttempts: 10,\n        noRandomize: false,\n        pedantic: false,\n        pingInterval: DEFAULT_PING_INTERVAL,\n        reconnect: true,\n        reconnectJitter: 100,\n        reconnectJitterTLS: 1000,\n        reconnectTimeWait: DEFAULT_RECONNECT_TIME_WAIT,\n        tls: undefined,\n        verbose: false,\n        waitOnFirstConnect: false\n    };\n}\nfunction parseOptions(opts) {\n    const dhp = `${DEFAULT_HOST}:${defaultPort()}`;\n    opts = opts || {\n        servers: [\n            dhp\n        ]\n    };\n    opts.servers = opts.servers || [];\n    if (typeof opts.servers === \"string\") {\n        opts.servers = [\n            opts.servers\n        ];\n    }\n    if (opts.servers.length > 0 && opts.port) {\n        throw new NatsError(\"port and servers options are mutually exclusive\", ErrorCode.InvalidOption);\n    }\n    if (opts.servers.length === 0 && opts.port) {\n        opts.servers = [\n            `${DEFAULT_HOST}:${opts.port}`\n        ];\n    }\n    if (opts.servers && opts.servers.length === 0) {\n        opts.servers = [\n            dhp\n        ];\n    }\n    const options = extend(defaultOptions(), opts);\n    if (opts.user && opts.token) {\n        throw NatsError.errorForCode(ErrorCode.BadAuthentication);\n    }\n    if (opts.authenticator && (opts.token || opts.user || opts.pass)) {\n        throw NatsError.errorForCode(ErrorCode.BadAuthentication);\n    }\n    options.authenticator = buildAuthenticator(options);\n    [\n        \"reconnectDelayHandler\",\n        \"authenticator\"\n    ].forEach((n)=>{\n        if (options[n] && typeof options[n] !== \"function\") {\n            throw new NatsError(`${n} option should be a function`, ErrorCode.NotFunction);\n        }\n    });\n    if (!options.reconnectDelayHandler) {\n        options.reconnectDelayHandler = ()=>{\n            let extra = options.tls ? options.reconnectJitterTLS : options.reconnectJitter;\n            if (extra) {\n                extra++;\n                extra = Math.floor(Math.random() * extra);\n            }\n            return options.reconnectTimeWait + extra;\n        };\n    }\n    if (options.inboxPrefix) {\n        try {\n            createInbox(options.inboxPrefix);\n        } catch (err) {\n            throw new NatsError(err.message, ErrorCode.ApiError);\n        }\n    }\n    if (options.resolve) {\n        if (typeof getResolveFn() !== \"function\") {\n            throw new NatsError(`'resolve' is not supported on this client`, ErrorCode.InvalidOption);\n        }\n    }\n    return options;\n}\nvar PubHeaders;\n(function(PubHeaders) {\n    PubHeaders[\"MsgIdHdr\"] = \"Nats-Msg-Id\";\n    PubHeaders[\"ExpectedStreamHdr\"] = \"Nats-Expected-Stream\";\n    PubHeaders[\"ExpectedLastSeqHdr\"] = \"Nats-Expected-Last-Sequence\";\n    PubHeaders[\"ExpectedLastMsgIdHdr\"] = \"Nats-Expected-Last-Msg-Id\";\n    PubHeaders[\"ExpectedLastSubjectSequenceHdr\"] = \"Nats-Expected-Last-Subject-Sequence\";\n})(PubHeaders || (PubHeaders = {}));\nfunction NoopKvCodecs() {\n    return {\n        key: {\n            encode (k) {\n                return k;\n            },\n            decode (k) {\n                return k;\n            }\n        },\n        value: {\n            encode (v) {\n                return v;\n            },\n            decode (v) {\n                return v;\n            }\n        }\n    };\n}\nfunction defaultBucketOpts() {\n    return {\n        replicas: 1,\n        history: 1,\n        timeout: 2000,\n        maxBucketSize: -1,\n        maxValueSize: -1,\n        codec: NoopKvCodecs(),\n        storage: StorageType.File\n    };\n}\nconst kvOperationHdr = \"KV-Operation\";\nconst kvPrefix = \"KV_\";\nconst kvSubjectPrefix = \"$KV\";\nconst validKeyRe = /^[-/=.\\w]+$/;\nconst validSearchKey = /^[-/=.>*\\w]+$/;\nconst validBucketRe = /^[-\\w]+$/;\nfunction validateKey(k) {\n    if (k.startsWith(\".\") || k.endsWith(\".\") || !validKeyRe.test(k)) {\n        throw new Error(`invalid key: ${k}`);\n    }\n}\nfunction validateSearchKey(k) {\n    if (k.startsWith(\".\") || k.endsWith(\".\") || !validSearchKey.test(k)) {\n        throw new Error(`invalid key: ${k}`);\n    }\n}\nfunction hasWildcards(k) {\n    if (k.startsWith(\".\") || k.endsWith(\".\")) {\n        throw new Error(`invalid key: ${k}`);\n    }\n    const chunks = k.split(\".\");\n    let hasWildcards = false;\n    for(let i = 0; i < chunks.length; i++){\n        switch(chunks[i]){\n            case \"*\":\n                hasWildcards = true;\n                break;\n            case \">\":\n                if (i !== chunks.length - 1) {\n                    throw new Error(`invalid key: ${k}`);\n                }\n                hasWildcards = true;\n                break;\n            default:\n        }\n    }\n    return hasWildcards;\n}\nfunction validateBucket(name) {\n    if (!validBucketRe.test(name)) {\n        throw new Error(`invalid bucket name: ${name}`);\n    }\n}\nclass Bucket {\n    jsm;\n    js;\n    stream;\n    bucket;\n    direct;\n    codec;\n    _prefixLen;\n    subjPrefix;\n    constructor(bucket, jsm, js){\n        validateBucket(bucket);\n        this.jsm = jsm;\n        this.js = js;\n        this.bucket = bucket;\n        this._prefixLen = 0;\n        this.subjPrefix = kvSubjectPrefix;\n        const jsi = js;\n        const prefix = jsi.prefix || \"$JS.API\";\n        if (prefix !== \"$JS.API\") {\n            this.subjPrefix = `${prefix}.${kvSubjectPrefix}`;\n        }\n    }\n    static async create(js, name, opts = {}) {\n        validateBucket(name);\n        const to = opts.timeout || 2000;\n        const jsi = js;\n        let jsopts = jsi.opts || {};\n        jsopts = Object.assign(jsopts, {\n            timeout: to\n        });\n        const jsm = await jsi.nc.jetstreamManager(jsopts);\n        const bucket = new Bucket(name, jsm, js);\n        await bucket.init(opts);\n        return bucket;\n    }\n    static async bind(js, name, opts = {}) {\n        const jsi = js;\n        const jsm = await jsi.nc.jetstreamManager();\n        const info = await jsm.streams.info(`${kvPrefix}${name}`);\n        validateBucket(info.config.name);\n        const bucket = new Bucket(name, jsm, js);\n        Object.assign(bucket, info);\n        bucket.codec = opts.codec || NoopKvCodecs();\n        bucket.direct = info.config.allow_direct ?? false;\n        return bucket;\n    }\n    async init(opts = {}) {\n        const bo = Object.assign(defaultBucketOpts(), opts);\n        this.codec = bo.codec;\n        const sc = {};\n        this.stream = sc.name = opts.streamName ?? this.bucketName();\n        sc.subjects = [\n            this.subjectForBucket()\n        ];\n        sc.retention = RetentionPolicy.Limits;\n        sc.max_msgs_per_subject = bo.history;\n        if (bo.maxBucketSize) {\n            bo.max_bytes = bo.maxBucketSize;\n        }\n        if (bo.max_bytes) {\n            sc.max_bytes = bo.max_bytes;\n        }\n        sc.max_msg_size = bo.maxValueSize;\n        sc.storage = bo.storage;\n        const location = opts.placementCluster ?? \"\";\n        if (location) {\n            opts.placement = {};\n            opts.placement.cluster = location;\n            opts.placement.tags = [];\n        }\n        if (opts.placement) {\n            sc.placement = opts.placement;\n        }\n        if (opts.republish) {\n            sc.republish = opts.republish;\n        }\n        if (opts.description) {\n            sc.description = opts.description;\n        }\n        const nci = this.js.nc;\n        const have = nci.getServerVersion();\n        const discardNew = have ? compare(have, parseSemVer(\"2.7.2\")) >= 0 : false;\n        sc.discard = discardNew ? DiscardPolicy.New : DiscardPolicy.Old;\n        const direct = have ? compare(have, parseSemVer(\"2.8.5\")) >= 0 : false;\n        sc.allow_direct = opts.allow_direct ? direct : false;\n        this.direct = sc.allow_direct;\n        sc.num_replicas = bo.replicas;\n        if (bo.ttl) {\n            sc.max_age = nanos(bo.ttl);\n        }\n        sc.allow_rollup_hdrs = true;\n        try {\n            await this.jsm.streams.info(sc.name);\n        } catch (err) {\n            if (err.message === \"stream not found\") {\n                await this.jsm.streams.add(sc);\n            }\n        }\n    }\n    bucketName() {\n        return this.stream ?? `${kvPrefix}${this.bucket}`;\n    }\n    subjectForBucket() {\n        return `${this.subjPrefix}.${this.bucket}.>`;\n    }\n    subjectForKey(k) {\n        return `${this.subjPrefix}.${this.bucket}.${k}`;\n    }\n    fullKeyName(k) {\n        return `${kvSubjectPrefix}.${this.bucket}.${k}`;\n    }\n    get prefixLen() {\n        if (this._prefixLen === 0) {\n            this._prefixLen = `${kvSubjectPrefix}.${this.bucket}.`.length;\n        }\n        return this._prefixLen;\n    }\n    encodeKey(key) {\n        const chunks = [];\n        for (const t of key.split(\".\")){\n            switch(t){\n                case \">\":\n                case \"*\":\n                    chunks.push(t);\n                    break;\n                default:\n                    chunks.push(this.codec.key.encode(t));\n                    break;\n            }\n        }\n        return chunks.join(\".\");\n    }\n    decodeKey(ekey) {\n        const chunks = [];\n        for (const t of ekey.split(\".\")){\n            switch(t){\n                case \">\":\n                case \"*\":\n                    chunks.push(t);\n                    break;\n                default:\n                    chunks.push(this.codec.key.decode(t));\n                    break;\n            }\n        }\n        return chunks.join(\".\");\n    }\n    validateKey = validateKey;\n    validateSearchKey = validateSearchKey;\n    hasWildcards = hasWildcards;\n    close() {\n        return Promise.resolve();\n    }\n    dataLen(data, h) {\n        const slen = h ? h.get(JsHeaders.MessageSizeHdr) || \"\" : \"\";\n        if (slen !== \"\") {\n            return parseInt(slen, 10);\n        }\n        return data.length;\n    }\n    smToEntry(sm) {\n        return {\n            bucket: this.bucket,\n            key: sm.subject.substring(this.prefixLen),\n            value: sm.data,\n            delta: 0,\n            created: sm.time,\n            revision: sm.seq,\n            operation: sm.header.get(kvOperationHdr) || \"PUT\",\n            length: this.dataLen(sm.data, sm.header)\n        };\n    }\n    jmToEntry(jm) {\n        const key = this.decodeKey(jm.subject.substring(this.prefixLen));\n        return {\n            bucket: this.bucket,\n            key: key,\n            value: jm.data,\n            created: new Date(millis(jm.info.timestampNanos)),\n            revision: jm.seq,\n            operation: jm.headers?.get(kvOperationHdr) || \"PUT\",\n            delta: jm.info.pending,\n            length: this.dataLen(jm.data, jm.headers)\n        };\n    }\n    create(k, data) {\n        return this.put(k, data, {\n            previousSeq: 0\n        });\n    }\n    update(k, data, version) {\n        if (version <= 0) {\n            throw new Error(\"version must be greater than 0\");\n        }\n        return this.put(k, data, {\n            previousSeq: version\n        });\n    }\n    async put(k, data, opts = {}) {\n        const ek = this.encodeKey(k);\n        this.validateKey(ek);\n        const o = {};\n        if (opts.previousSeq !== undefined) {\n            const h = headers();\n            o.headers = h;\n            h.set(\"Nats-Expected-Last-Subject-Sequence\", `${opts.previousSeq}`);\n        }\n        const pa = await this.js.publish(this.subjectForKey(ek), data, o);\n        return pa.seq;\n    }\n    async get(k, opts) {\n        const ek = this.encodeKey(k);\n        this.validateKey(ek);\n        let arg = {\n            last_by_subj: this.fullKeyName(ek)\n        };\n        if (opts && opts.revision > 0) {\n            arg = {\n                seq: opts.revision\n            };\n        }\n        let sm;\n        try {\n            if (this.direct) {\n                const jsmi = this.jsm;\n                sm = await jsmi.direct.getMessage(this.bucketName(), arg);\n            } else {\n                sm = await this.jsm.streams.getMessage(this.bucketName(), arg);\n            }\n            const ke = this.smToEntry(sm);\n            if (ke.key !== ek) {\n                return null;\n            }\n            return ke;\n        } catch (err) {\n            if (err.code === ErrorCode.JetStream404NoMessages) {\n                return null;\n            }\n            throw err;\n        }\n    }\n    purge(k) {\n        return this._deleteOrPurge(k, \"PURGE\");\n    }\n    delete(k) {\n        return this._deleteOrPurge(k, \"DEL\");\n    }\n    async purgeDeletes(olderMillis = 30 * 60 * 1000) {\n        const done = deferred();\n        const buf = [];\n        const i = await this.watch({\n            key: \">\",\n            initializedFn: ()=>{\n                done.resolve();\n            }\n        });\n        (async ()=>{\n            for await (const e of i){\n                if (e.operation === \"DEL\" || e.operation === \"PURGE\") {\n                    buf.push(e);\n                }\n            }\n        })().then();\n        await done;\n        i.stop();\n        const min = Date.now() - olderMillis;\n        const proms = buf.map((e)=>{\n            const subj = this.subjectForKey(e.key);\n            if (e.created.getTime() >= min) {\n                return this.jsm.streams.purge(this.stream, {\n                    filter: subj,\n                    keep: 1\n                });\n            } else {\n                return this.jsm.streams.purge(this.stream, {\n                    filter: subj,\n                    keep: 0\n                });\n            }\n        });\n        const purged = await Promise.all(proms);\n        purged.unshift({\n            success: true,\n            purged: 0\n        });\n        return purged.reduce((pv, cv)=>{\n            pv.purged += cv.purged;\n            return pv;\n        });\n    }\n    async _deleteOrPurge(k, op) {\n        if (!this.hasWildcards(k)) {\n            return this._doDeleteOrPurge(k, op);\n        }\n        const iter = await this.keys(k);\n        const buf = [];\n        for await (const k1 of iter){\n            buf.push(this._doDeleteOrPurge(k1, op));\n            if (buf.length === 100) {\n                await Promise.all(buf);\n                buf.length = 0;\n            }\n        }\n        if (buf.length > 0) {\n            await Promise.all(buf);\n        }\n    }\n    async _doDeleteOrPurge(k, op) {\n        const ek = this.encodeKey(k);\n        this.validateKey(ek);\n        const h = headers();\n        h.set(kvOperationHdr, op);\n        if (op === \"PURGE\") {\n            h.set(JsHeaders.RollupHdr, JsHeaders.RollupValueSubject);\n        }\n        await this.js.publish(this.subjectForKey(ek), Empty, {\n            headers: h\n        });\n    }\n    _buildCC(k, history = false, opts = {}) {\n        const ek = this.encodeKey(k);\n        this.validateSearchKey(k);\n        return Object.assign({\n            \"deliver_policy\": history ? DeliverPolicy.All : DeliverPolicy.LastPerSubject,\n            \"ack_policy\": AckPolicy.None,\n            \"filter_subject\": this.fullKeyName(ek),\n            \"flow_control\": true,\n            \"idle_heartbeat\": nanos(5 * 1000)\n        }, opts);\n    }\n    remove(k) {\n        return this.purge(k);\n    }\n    async history(opts = {}) {\n        const k = opts.key ?? \">\";\n        const qi = new QueuedIteratorImpl();\n        const co = {};\n        co.headers_only = opts.headers_only || false;\n        let fn;\n        fn = ()=>{\n            qi.stop();\n        };\n        let count = 0;\n        const cc = this._buildCC(k, true, co);\n        const subj = cc.filter_subject;\n        const copts = consumerOpts(cc);\n        copts.orderedConsumer();\n        copts.callback((err, jm)=>{\n            if (err) {\n                qi.stop(err);\n                return;\n            }\n            if (jm) {\n                const e = this.jmToEntry(jm);\n                qi.push(e);\n                qi.received++;\n                if (fn && count > 0 && qi.received >= count || jm.info.pending === 0) {\n                    qi.push(fn);\n                    fn = undefined;\n                }\n            }\n        });\n        const sub = await this.js.subscribe(subj, copts);\n        if (fn) {\n            const { info: { last  }  } = sub;\n            const expect = last.num_pending + last.delivered.consumer_seq;\n            if (expect === 0 || qi.received >= expect) {\n                try {\n                    fn();\n                } catch (err) {\n                    qi.stop(err);\n                } finally{\n                    fn = undefined;\n                }\n            } else {\n                count = expect;\n            }\n        }\n        qi._data = sub;\n        qi.iterClosed.then(()=>{\n            sub.unsubscribe();\n        });\n        sub.closed.then(()=>{\n            qi.stop();\n        }).catch((err)=>{\n            qi.stop(err);\n        });\n        return qi;\n    }\n    async watch(opts = {}) {\n        const k = opts.key ?? \">\";\n        const qi = new QueuedIteratorImpl();\n        const co = {};\n        co.headers_only = opts.headers_only || false;\n        let fn = opts.initializedFn;\n        let count = 0;\n        const cc = this._buildCC(k, false, co);\n        const subj = cc.filter_subject;\n        const copts = consumerOpts(cc);\n        copts.orderedConsumer();\n        copts.callback((err, jm)=>{\n            if (err) {\n                qi.stop(err);\n                return;\n            }\n            if (jm) {\n                const e = this.jmToEntry(jm);\n                qi.push(e);\n                qi.received++;\n                if (fn && (count > 0 && qi.received >= count || jm.info.pending === 0)) {\n                    qi.push(fn);\n                    fn = undefined;\n                }\n            }\n        });\n        const sub = await this.js.subscribe(subj, copts);\n        if (fn) {\n            const { info: { last  }  } = sub;\n            const expect = last.num_pending + last.delivered.consumer_seq;\n            if (expect === 0 || qi.received >= expect) {\n                try {\n                    fn();\n                } catch (err) {\n                    qi.stop(err);\n                } finally{\n                    fn = undefined;\n                }\n            } else {\n                count = expect;\n            }\n        }\n        qi._data = sub;\n        qi.iterClosed.then(()=>{\n            sub.unsubscribe();\n        });\n        sub.closed.then(()=>{\n            qi.stop();\n        }).catch((err)=>{\n            qi.stop(err);\n        });\n        return qi;\n    }\n    async keys(k = \">\") {\n        const keys = new QueuedIteratorImpl();\n        const cc = this._buildCC(k, false, {\n            headers_only: true\n        });\n        const subj = cc.filter_subject;\n        const copts = consumerOpts(cc);\n        copts.orderedConsumer();\n        const sub = await this.js.subscribe(subj, copts);\n        (async ()=>{\n            for await (const jm of sub){\n                const op = jm.headers?.get(kvOperationHdr);\n                if (op !== \"DEL\" && op !== \"PURGE\") {\n                    const key = this.decodeKey(jm.subject.substring(this.prefixLen));\n                    keys.push(key);\n                }\n                if (jm.info.pending === 0) {\n                    sub.unsubscribe();\n                }\n            }\n        })().then(()=>{\n            keys.stop();\n        }).catch((err)=>{\n            keys.stop(err);\n        });\n        const si = sub;\n        if (si.info.last.num_pending === 0) {\n            sub.unsubscribe();\n        }\n        return keys;\n    }\n    purgeBucket(opts) {\n        return this.jsm.streams.purge(this.bucketName(), opts);\n    }\n    destroy() {\n        return this.jsm.streams.delete(this.bucketName());\n    }\n    async status() {\n        const ji = this.js;\n        const cluster = ji.nc.info?.cluster ?? \"\";\n        const si = await this.jsm.streams.info(this.bucketName());\n        return {\n            bucket: this.bucketName(),\n            values: si.state.messages,\n            history: si.config.max_msgs_per_subject,\n            ttl: millis(si.config.max_age),\n            bucket_location: cluster,\n            backingStore: si.config.storage,\n            storage: si.config.storage,\n            replicas: si.config.num_replicas\n        };\n    }\n}\nfunction objectStoreStreamName(bucket) {\n    validateBucket(bucket);\n    return `OBJ_${bucket}`;\n}\nfunction objectStoreBucketName(stream) {\n    if (stream.startsWith(\"OBJ_\")) {\n        return stream.substring(4);\n    }\n    return stream;\n}\nclass ObjectStoreInfoImpl {\n    si;\n    backingStore;\n    constructor(si){\n        this.si = si;\n        this.backingStore = \"JetStream\";\n    }\n    get bucket() {\n        return objectStoreBucketName(this.si.config.name);\n    }\n    get description() {\n        return this.si.config.description ?? \"\";\n    }\n    get ttl() {\n        return this.si.config.max_age;\n    }\n    get storage() {\n        return this.si.config.storage;\n    }\n    get replicas() {\n        return this.si.config.num_replicas;\n    }\n    get sealed() {\n        return this.si.config.sealed;\n    }\n    get size() {\n        return this.si.state.bytes;\n    }\n    get streamInfo() {\n        return this.si;\n    }\n}\nclass ObjectInfoImpl {\n    info;\n    hdrs;\n    constructor(oi){\n        this.info = oi;\n    }\n    get name() {\n        return this.info.name;\n    }\n    get description() {\n        return this.info.description ?? \"\";\n    }\n    get headers() {\n        if (!this.hdrs) {\n            this.hdrs = MsgHdrsImpl.fromRecord(this.info.headers || {});\n        }\n        return this.hdrs;\n    }\n    get options() {\n        return this.info.options;\n    }\n    get bucket() {\n        return this.info.bucket;\n    }\n    get chunks() {\n        return this.info.chunks;\n    }\n    get deleted() {\n        return this.info.deleted ?? false;\n    }\n    get digest() {\n        return this.info.digest;\n    }\n    get mtime() {\n        return this.info.mtime;\n    }\n    get nuid() {\n        return this.info.nuid;\n    }\n    get size() {\n        return this.info.size;\n    }\n}\nfunction toServerObjectStoreMeta(meta) {\n    const v = {\n        name: meta.name,\n        description: meta.description ?? \"\",\n        options: meta.options\n    };\n    if (meta.headers) {\n        const mhi = meta.headers;\n        v.headers = mhi.toRecord();\n    }\n    return v;\n}\nfunction meta(oi) {\n    return {\n        name: oi.name,\n        description: oi.description,\n        headers: oi.headers,\n        options: oi.options\n    };\n}\nfunction emptyReadableStream() {\n    return new ReadableStream({\n        pull (c) {\n            c.enqueue(new Uint8Array(0));\n            c.close();\n        }\n    });\n}\nclass ObjectStoreImpl {\n    jsm;\n    js;\n    stream;\n    name;\n    constructor(name, jsm, js){\n        this.name = name;\n        this.jsm = jsm;\n        this.js = js;\n    }\n    _sanitizeName(name) {\n        if (!name || name.length === 0) {\n            return {\n                name,\n                error: new Error(\"name cannot be empty\")\n            };\n        }\n        name = name.replace(/[\\. ]/g, \"_\");\n        let error = undefined;\n        try {\n            validateKey(name);\n        } catch (err) {\n            error = err;\n        }\n        return {\n            name,\n            error\n        };\n    }\n    async info(name) {\n        const info = await this.rawInfo(name);\n        return info ? new ObjectInfoImpl(info) : null;\n    }\n    async list() {\n        const buf = [];\n        const iter = await this.watch({\n            ignoreDeletes: true,\n            includeHistory: true\n        });\n        for await (const info of iter){\n            if (info === null) {\n                break;\n            }\n            buf.push(info);\n        }\n        return Promise.resolve(buf);\n    }\n    async rawInfo(name) {\n        const { name: obj , error  } = this._sanitizeName(name);\n        if (error) {\n            return Promise.reject(error);\n        }\n        const meta = `$O.${this.name}.M.${obj}`;\n        try {\n            const m = await this.jsm.streams.getMessage(this.stream, {\n                last_by_subj: meta\n            });\n            const jc = JSONCodec();\n            const info = jc.decode(m.data);\n            return info;\n        } catch (err) {\n            if (err.code === \"404\") {\n                return null;\n            }\n            return Promise.reject(err);\n        }\n    }\n    async seal() {\n        let info = await this.jsm.streams.info(this.stream);\n        if (info === null) {\n            return Promise.reject(new Error(\"object store not found\"));\n        }\n        info.config.sealed = true;\n        info = await this.jsm.streams.update(this.stream, info.config);\n        return Promise.resolve(new ObjectStoreInfoImpl(info));\n    }\n    async status(opts) {\n        const info = await this.jsm.streams.info(this.stream, opts);\n        if (info === null) {\n            return Promise.reject(new Error(\"object store not found\"));\n        }\n        return Promise.resolve(new ObjectStoreInfoImpl(info));\n    }\n    destroy() {\n        return this.jsm.streams.delete(this.stream);\n    }\n    async put(meta, rs) {\n        const jsi = this.js;\n        const maxPayload = jsi.nc.info?.max_payload || 1024;\n        meta = meta || {};\n        meta.options = meta.options || {};\n        let maxChunk = meta.options?.max_chunk_size || 128 * 1024;\n        maxChunk = maxChunk > maxPayload ? maxPayload : maxChunk;\n        meta.options.max_chunk_size = maxChunk;\n        const old = await this.info(meta.name);\n        const { name: n , error  } = this._sanitizeName(meta.name);\n        if (error) {\n            return Promise.reject(error);\n        }\n        const id = nuid.next();\n        const chunkSubj = this._chunkSubject(id);\n        const metaSubj = this._metaSubject(n);\n        const info = Object.assign({\n            bucket: this.name,\n            nuid: id,\n            size: 0,\n            chunks: 0\n        }, toServerObjectStoreMeta(meta));\n        const d = deferred();\n        const proms = [];\n        const db = new DataBuffer();\n        try {\n            const reader = rs ? rs.getReader() : null;\n            const sha = new SHA256();\n            while(true){\n                const { done , value  } = reader ? await reader.read() : {\n                    done: true,\n                    value: undefined\n                };\n                if (done) {\n                    if (db.size() > 0) {\n                        const payload = db.drain();\n                        sha.update(payload);\n                        info.chunks++;\n                        info.size += payload.length;\n                        info.mtime = new Date().toISOString();\n                        const digest = sha.digest(\"base64\");\n                        const pad = digest.length % 3;\n                        const padding = pad > 0 ? \"=\".repeat(pad) : \"\";\n                        info.digest = `sha-256=${digest}${padding}`;\n                        info.deleted = false;\n                        proms.push(this.js.publish(chunkSubj, payload));\n                    }\n                    const h = headers();\n                    h.set(JsHeaders.RollupHdr, JsHeaders.RollupValueSubject);\n                    proms.push(this.js.publish(metaSubj, JSONCodec().encode(info), {\n                        headers: h\n                    }));\n                    if (old) {\n                        proms.push(this.jsm.streams.purge(this.stream, {\n                            filter: `$O.${this.name}.C.${old.nuid}`\n                        }));\n                    }\n                    await Promise.all(proms);\n                    d.resolve(new ObjectInfoImpl(info));\n                    break;\n                }\n                if (value) {\n                    db.fill(value);\n                    while(db.size() > maxChunk){\n                        info.chunks++;\n                        info.size += maxChunk;\n                        const payload1 = db.drain(meta.options.max_chunk_size);\n                        sha.update(payload1);\n                        proms.push(this.js.publish(chunkSubj, payload1));\n                    }\n                }\n            }\n        } catch (err) {\n            await this.jsm.streams.purge(this.stream, {\n                filter: chunkSubj\n            });\n            d.reject(err);\n        }\n        return d;\n    }\n    async get(name) {\n        const info = await this.rawInfo(name);\n        if (info === null) {\n            return Promise.resolve(null);\n        }\n        if (info.options && info.options.link) {\n            const ln = info.options.link.name || \"\";\n            if (ln === \"\") {\n                throw new Error(\"link is a bucket\");\n            }\n            const os = await ObjectStoreImpl.create(this.js, info.options.link.bucket);\n            return os.get(ln);\n        }\n        const d = deferred();\n        const r = {\n            info: new ObjectInfoImpl(info),\n            error: d\n        };\n        if (info.size === 0) {\n            r.data = emptyReadableStream();\n            d.resolve(null);\n            return Promise.resolve(r);\n        }\n        let controller;\n        const oc = consumerOpts();\n        oc.orderedConsumer();\n        const sha = new SHA256();\n        const subj = `$O.${this.name}.C.${info.nuid}`;\n        const sub = await this.js.subscribe(subj, oc);\n        (async ()=>{\n            for await (const jm of sub){\n                if (jm.data.length > 0) {\n                    sha.update(jm.data);\n                    controller.enqueue(jm.data);\n                }\n                if (jm.info.pending === 0) {\n                    const hash = sha.digest(\"base64\");\n                    const pad = hash.length % 3;\n                    const padding = pad > 0 ? \"=\".repeat(pad) : \"\";\n                    const digest = `sha-256=${hash}${padding}`;\n                    if (digest !== info.digest) {\n                        controller.error(new Error(`received a corrupt object, digests do not match received: ${info.digest} calculated ${digest}`));\n                    } else {\n                        controller.close();\n                    }\n                    sub.unsubscribe();\n                }\n            }\n        })().then(()=>{\n            d.resolve();\n        }).catch((err)=>{\n            controller.error(err);\n            d.reject(err);\n        });\n        r.data = new ReadableStream({\n            start (c) {\n                controller = c;\n            },\n            cancel () {\n                sub.unsubscribe();\n            }\n        });\n        return r;\n    }\n    linkStore(name, bucket) {\n        if (!(bucket instanceof ObjectStoreImpl)) {\n            return Promise.reject(\"bucket required\");\n        }\n        const osi = bucket;\n        const { name: n , error  } = this._sanitizeName(name);\n        if (error) {\n            return Promise.reject(error);\n        }\n        const meta = {\n            name: n,\n            options: {\n                link: {\n                    bucket: osi.name\n                }\n            }\n        };\n        return this.put(meta, null);\n    }\n    async link(name, info) {\n        if (info.deleted) {\n            return Promise.reject(new Error(\"object is deleted\"));\n        }\n        const { name: n , error  } = this._sanitizeName(name);\n        if (error) {\n            return Promise.reject(error);\n        }\n        if (this.name === info.bucket) {\n            const copy = Object.assign({}, meta(info));\n            copy.name = n;\n            try {\n                await this.update(info.name, copy);\n                const ii = await this.info(n);\n                return ii;\n            } catch (err) {\n                return Promise.reject(err);\n            }\n        }\n        const link = {\n            bucket: info.bucket,\n            name: info.name\n        };\n        const mm = {\n            name: n,\n            options: {\n                link: link\n            }\n        };\n        return this.put(mm, null);\n    }\n    async delete(name) {\n        const info = await this.rawInfo(name);\n        if (info === null) {\n            return Promise.resolve({\n                purged: 0,\n                success: false\n            });\n        }\n        info.deleted = true;\n        info.size = 0;\n        info.chunks = 0;\n        info.digest = \"\";\n        const jc = JSONCodec();\n        const h = headers();\n        h.set(JsHeaders.RollupHdr, JsHeaders.RollupValueSubject);\n        await this.js.publish(this._metaSubject(info.name), jc.encode(info), {\n            headers: h\n        });\n        return this.jsm.streams.purge(this.stream, {\n            filter: this._chunkSubject(info.nuid)\n        });\n    }\n    async update(name, meta = {}) {\n        const info = await this.rawInfo(name);\n        if (info === null) {\n            return Promise.reject(new Error(\"object not found\"));\n        }\n        meta.name = meta.name ?? info.name;\n        const { name: n , error  } = this._sanitizeName(meta.name);\n        if (error) {\n            return Promise.reject(error);\n        }\n        meta.name = n;\n        const ii = Object.assign({}, info, toServerObjectStoreMeta(meta));\n        const jc = JSONCodec();\n        return this.js.publish(this._metaSubject(ii.name), jc.encode(ii));\n    }\n    async watch(opts = {}) {\n        opts.includeHistory = opts.includeHistory ?? false;\n        opts.ignoreDeletes = opts.ignoreDeletes ?? false;\n        let initialized = false;\n        const qi = new QueuedIteratorImpl();\n        const subj = this._metaSubjectAll();\n        try {\n            await this.jsm.streams.getMessage(this.stream, {\n                last_by_subj: subj\n            });\n        } catch (err) {\n            if (err.code === \"404\") {\n                qi.push(null);\n                initialized = true;\n            } else {\n                qi.stop(err);\n            }\n        }\n        const jc = JSONCodec();\n        const copts = consumerOpts();\n        copts.orderedConsumer();\n        if (opts.includeHistory) {\n            copts.deliverLastPerSubject();\n        } else {\n            initialized = true;\n            copts.deliverNew();\n        }\n        copts.callback((err, jm)=>{\n            if (err) {\n                qi.stop(err);\n                return;\n            }\n            if (jm !== null) {\n                const oi = jc.decode(jm.data);\n                if (oi.deleted && opts.ignoreDeletes === true) {} else {\n                    qi.push(oi);\n                }\n                if (jm.info?.pending === 0 && !initialized) {\n                    initialized = true;\n                    qi.push(null);\n                }\n            }\n        });\n        const sub = await this.js.subscribe(subj, copts);\n        qi._data = sub;\n        qi.iterClosed.then(()=>{\n            sub.unsubscribe();\n        });\n        sub.closed.then(()=>{\n            qi.stop();\n        }).catch((err)=>{\n            qi.stop(err);\n        });\n        return qi;\n    }\n    _chunkSubject(id) {\n        return `$O.${this.name}.C.${id}`;\n    }\n    _metaSubject(n) {\n        return `$O.${this.name}.M.${n}`;\n    }\n    _metaSubjectAll() {\n        return `$O.${this.name}.M.>`;\n    }\n    async init(opts = {}) {\n        try {\n            this.stream = objectStoreStreamName(this.name);\n        } catch (err) {\n            return Promise.reject(err);\n        }\n        const sc = Object.assign({}, opts);\n        sc.name = this.stream;\n        sc.allow_rollup_hdrs = true;\n        sc.discard = DiscardPolicy.New;\n        sc.subjects = [\n            `$O.${this.name}.C.>`,\n            `$O.${this.name}.M.>`\n        ];\n        if (opts.placement) {\n            sc.placement = opts.placement;\n        }\n        try {\n            await this.jsm.streams.info(sc.name);\n        } catch (err1) {\n            if (err1.message === \"stream not found\") {\n                await this.jsm.streams.add(sc);\n            }\n        }\n    }\n    static async create(js, name, opts = {}) {\n        if (typeof crypto?.subtle?.digest !== \"function\") {\n            return Promise.reject(new Error(\"objectstore: unable to calculate hashes - crypto.subtle.digest with sha256 support is required\"));\n        }\n        const jsi = js;\n        let jsopts = jsi.opts || {};\n        const to = jsopts.timeout || 2000;\n        jsopts = Object.assign(jsopts, {\n            timeout: to\n        });\n        const jsm = await jsi.nc.jetstreamManager(jsopts);\n        const os = new ObjectStoreImpl(name, jsm, js);\n        await os.init(opts);\n        return Promise.resolve(os);\n    }\n}\nclass ViewsImpl {\n    js;\n    constructor(js){\n        this.js = js;\n    }\n    kv(name, opts = {}) {\n        if (opts.bindOnly) {\n            return Bucket.bind(this.js, name);\n        }\n        return Bucket.create(this.js, name, opts);\n    }\n    os(name, opts = {}) {\n        jetstreamPreview(this.js.nc);\n        return ObjectStoreImpl.create(this.js, name, opts);\n    }\n}\nclass JetStreamClientImpl extends BaseApiClient {\n    api;\n    constructor(nc, opts){\n        super(nc, opts);\n        this.api = new ConsumerAPIImpl(nc, opts);\n    }\n    get views() {\n        return new ViewsImpl(this);\n    }\n    async publish(subj, data = Empty, opts) {\n        opts = opts || {};\n        opts.expect = opts.expect || {};\n        const mh = opts?.headers || headers();\n        if (opts) {\n            if (opts.msgID) {\n                mh.set(PubHeaders.MsgIdHdr, opts.msgID);\n            }\n            if (opts.expect.lastMsgID) {\n                mh.set(PubHeaders.ExpectedLastMsgIdHdr, opts.expect.lastMsgID);\n            }\n            if (opts.expect.streamName) {\n                mh.set(PubHeaders.ExpectedStreamHdr, opts.expect.streamName);\n            }\n            if (opts.expect.lastSequence) {\n                mh.set(PubHeaders.ExpectedLastSeqHdr, `${opts.expect.lastSequence}`);\n            }\n            if (opts.expect.lastSubjectSequence) {\n                mh.set(PubHeaders.ExpectedLastSubjectSequenceHdr, `${opts.expect.lastSubjectSequence}`);\n            }\n        }\n        const to = opts.timeout || this.timeout;\n        const ro = {};\n        if (to) {\n            ro.timeout = to;\n        }\n        if (opts) {\n            ro.headers = mh;\n        }\n        let { retries , retry_delay  } = opts;\n        retries = retries || 1;\n        retry_delay = retry_delay || 250;\n        let r;\n        for(let i = 0; i < retries; i++){\n            try {\n                r = await this.nc.request(subj, data, ro);\n                break;\n            } catch (err) {\n                const ne = err;\n                if (ne.code === \"503\" && i + 1 < retries) {\n                    await delay(retry_delay);\n                } else {\n                    throw err;\n                }\n            }\n        }\n        const pa = this.parseJsResponse(r);\n        if (pa.stream === \"\") {\n            throw NatsError.errorForCode(ErrorCode.JetStreamInvalidAck);\n        }\n        pa.duplicate = pa.duplicate ? pa.duplicate : false;\n        return pa;\n    }\n    async pull(stream, durable, expires = 0) {\n        validateStreamName(stream);\n        validateDurableName(durable);\n        let timeout = this.timeout;\n        if (expires > timeout) {\n            timeout = expires;\n        }\n        expires = expires < 0 ? 0 : nanos(expires);\n        const pullOpts = {\n            batch: 1,\n            no_wait: expires === 0,\n            expires\n        };\n        const msg = await this.nc.request(`${this.prefix}.CONSUMER.MSG.NEXT.${stream}.${durable}`, this.jc.encode(pullOpts), {\n            noMux: true,\n            timeout\n        });\n        const err = checkJsError(msg);\n        if (err) {\n            throw err;\n        }\n        return toJsMsg(msg);\n    }\n    fetch(stream, durable, opts = {}) {\n        validateStreamName(stream);\n        validateDurableName(durable);\n        let timer = null;\n        const trackBytes = (opts.max_bytes ?? 0) > 0;\n        let receivedBytes = 0;\n        const max_bytes = trackBytes ? opts.max_bytes : 0;\n        const args = {};\n        args.batch = opts.batch || 1;\n        if (max_bytes) {\n            const fv = this.nc.protocol.features.get(Feature.JS_PULL_MAX_BYTES);\n            if (!fv.ok) {\n                throw new Error(`max_bytes is only supported on servers ${fv.min} or better`);\n            }\n            args.max_bytes = max_bytes;\n        }\n        args.no_wait = opts.no_wait || false;\n        if (args.no_wait && args.expires) {\n            args.expires = 0;\n        }\n        const expires = opts.expires || 0;\n        if (expires) {\n            args.expires = nanos(expires);\n        }\n        if (expires === 0 && args.no_wait === false) {\n            throw new Error(\"expires or no_wait is required\");\n        }\n        const qi = new QueuedIteratorImpl();\n        const wants = args.batch;\n        let received = 0;\n        qi.dispatchedFn = (m)=>{\n            if (m) {\n                if (trackBytes) {\n                    receivedBytes += m.data.length;\n                }\n                received++;\n                if (timer && m.info.pending === 0) {\n                    return;\n                }\n                if (qi.getPending() === 1 && m.info.pending === 0 || wants === received || max_bytes > 0 && receivedBytes >= max_bytes) {\n                    qi.stop();\n                }\n            }\n        };\n        const inbox = createInbox(this.nc.options.inboxPrefix);\n        const sub = this.nc.subscribe(inbox, {\n            max: opts.batch,\n            callback: (err, msg)=>{\n                if (err === null) {\n                    err = checkJsError(msg);\n                }\n                if (err !== null) {\n                    if (timer) {\n                        timer.cancel();\n                        timer = null;\n                    }\n                    if (isNatsError(err)) {\n                        qi.stop(hideNonTerminalJsErrors(err) === null ? undefined : err);\n                    } else {\n                        qi.stop(err);\n                    }\n                } else {\n                    qi.received++;\n                    qi.push(toJsMsg(msg));\n                }\n            }\n        });\n        if (expires) {\n            timer = timeout(expires);\n            timer.catch(()=>{\n                if (!sub.isClosed()) {\n                    sub.drain();\n                    timer = null;\n                }\n            });\n        }\n        (async ()=>{\n            await sub.closed;\n            if (timer !== null) {\n                timer.cancel();\n                timer = null;\n            }\n            qi.stop();\n        })().catch();\n        this.nc.publish(`${this.prefix}.CONSUMER.MSG.NEXT.${stream}.${durable}`, this.jc.encode(args), {\n            reply: inbox\n        });\n        return qi;\n    }\n    async pullSubscribe(subject, opts = consumerOpts()) {\n        const cso = await this._processOptions(subject, opts);\n        if (cso.ordered) {\n            throw new Error(\"pull subscribers cannot be be ordered\");\n        }\n        if (!cso.attached) {\n            cso.config.filter_subject = subject;\n        }\n        if (cso.config.deliver_subject) {\n            throw new Error(\"consumer info specifies deliver_subject - pull consumers cannot have deliver_subject set\");\n        }\n        const ackPolicy = cso.config.ack_policy;\n        if (ackPolicy === AckPolicy.None || ackPolicy === AckPolicy.All) {\n            throw new Error(\"ack policy for pull consumers must be explicit\");\n        }\n        const so = this._buildTypedSubscriptionOpts(cso);\n        const sub = new JetStreamPullSubscriptionImpl(this, cso.deliver, so);\n        sub.info = cso;\n        try {\n            await this._maybeCreateConsumer(cso);\n        } catch (err) {\n            sub.unsubscribe();\n            throw err;\n        }\n        return sub;\n    }\n    async subscribe(subject, opts = consumerOpts()) {\n        const cso = await this._processOptions(subject, opts);\n        if (!cso.isBind && !cso.config.deliver_subject) {\n            throw new Error(\"push consumer requires deliver_subject\");\n        }\n        const so = this._buildTypedSubscriptionOpts(cso);\n        const sub = new JetStreamSubscriptionImpl(this, cso.deliver, so);\n        sub.info = cso;\n        try {\n            await this._maybeCreateConsumer(cso);\n        } catch (err) {\n            sub.unsubscribe();\n            throw err;\n        }\n        return sub;\n    }\n    async _processOptions(subject, opts = consumerOpts()) {\n        const jsi = isConsumerOptsBuilder(opts) ? opts.getOpts() : opts;\n        jsi.isBind = isConsumerOptsBuilder(opts) ? opts.isBind : false;\n        jsi.flow_control = {\n            heartbeat_count: 0,\n            fc_count: 0,\n            consumer_restarts: 0\n        };\n        if (jsi.ordered) {\n            jsi.ordered_consumer_sequence = {\n                stream_seq: 0,\n                delivery_seq: 0\n            };\n            if (jsi.config.ack_policy !== AckPolicy.NotSet && jsi.config.ack_policy !== AckPolicy.None) {\n                throw new NatsError(\"ordered consumer: ack_policy can only be set to 'none'\", ErrorCode.ApiError);\n            }\n            if (jsi.config.durable_name && jsi.config.durable_name.length > 0) {\n                throw new NatsError(\"ordered consumer: durable_name cannot be set\", ErrorCode.ApiError);\n            }\n            if (jsi.config.deliver_subject && jsi.config.deliver_subject.length > 0) {\n                throw new NatsError(\"ordered consumer: deliver_subject cannot be set\", ErrorCode.ApiError);\n            }\n            if (jsi.config.max_deliver !== undefined && jsi.config.max_deliver > 1) {\n                throw new NatsError(\"ordered consumer: max_deliver cannot be set\", ErrorCode.ApiError);\n            }\n            if (jsi.config.deliver_group && jsi.config.deliver_group.length > 0) {\n                throw new NatsError(\"ordered consumer: deliver_group cannot be set\", ErrorCode.ApiError);\n            }\n            jsi.config.deliver_subject = createInbox(this.nc.options.inboxPrefix);\n            jsi.config.ack_policy = AckPolicy.None;\n            jsi.config.max_deliver = 1;\n            jsi.config.flow_control = true;\n            jsi.config.idle_heartbeat = jsi.config.idle_heartbeat || nanos(5000);\n            jsi.config.ack_wait = nanos(22 * 60 * 60 * 1000);\n        }\n        if (jsi.config.ack_policy === AckPolicy.NotSet) {\n            jsi.config.ack_policy = AckPolicy.All;\n        }\n        jsi.api = this;\n        jsi.config = jsi.config || {};\n        jsi.stream = jsi.stream ? jsi.stream : await this.findStream(subject);\n        jsi.attached = false;\n        if (jsi.config.durable_name) {\n            try {\n                const info = await this.api.info(jsi.stream, jsi.config.durable_name);\n                if (info) {\n                    if (info.config.filter_subject && info.config.filter_subject !== subject) {\n                        throw new Error(\"subject does not match consumer\");\n                    }\n                    const qn = jsi.config.deliver_group ?? \"\";\n                    if (qn === \"\" && info.push_bound === true) {\n                        throw new Error(`duplicate subscription`);\n                    }\n                    const rqn = info.config.deliver_group ?? \"\";\n                    if (qn !== rqn) {\n                        if (rqn === \"\") {\n                            throw new Error(`durable requires no queue group`);\n                        } else {\n                            throw new Error(`durable requires queue group '${rqn}'`);\n                        }\n                    }\n                    jsi.last = info;\n                    jsi.config = info.config;\n                    jsi.attached = true;\n                    if (!jsi.config.durable_name) {\n                        jsi.name = info.name;\n                    }\n                }\n            } catch (err) {\n                if (err.code !== \"404\") {\n                    throw err;\n                }\n            }\n        }\n        if (!jsi.attached) {\n            jsi.config.filter_subject = subject;\n        }\n        jsi.deliver = jsi.config.deliver_subject || createInbox(this.nc.options.inboxPrefix);\n        return jsi;\n    }\n    _buildTypedSubscriptionOpts(jsi) {\n        const so = {};\n        so.adapter = msgAdapter(jsi.callbackFn === undefined);\n        so.ingestionFilterFn = JetStreamClientImpl.ingestionFn(jsi.ordered);\n        so.protocolFilterFn = (jm, ingest = false)=>{\n            const jsmi = jm;\n            if (isFlowControlMsg(jsmi.msg)) {\n                if (!ingest) {\n                    jsmi.msg.respond();\n                }\n                return false;\n            }\n            return true;\n        };\n        if (!jsi.mack && jsi.config.ack_policy !== AckPolicy.None) {\n            so.dispatchedFn = autoAckJsMsg;\n        }\n        if (jsi.callbackFn) {\n            so.callback = jsi.callbackFn;\n        }\n        so.max = jsi.max || 0;\n        so.queue = jsi.queue;\n        return so;\n    }\n    async _maybeCreateConsumer(jsi) {\n        if (jsi.attached) {\n            return;\n        }\n        if (jsi.isBind) {\n            throw new Error(`unable to bind - durable consumer ${jsi.config.durable_name} doesn't exist in ${jsi.stream}`);\n        }\n        jsi.config = Object.assign({\n            deliver_policy: DeliverPolicy.All,\n            ack_policy: AckPolicy.Explicit,\n            ack_wait: nanos(30 * 1000),\n            replay_policy: ReplayPolicy.Instant\n        }, jsi.config);\n        const ci = await this.api.add(jsi.stream, jsi.config);\n        jsi.name = ci.name;\n        jsi.config = ci.config;\n        jsi.last = ci;\n    }\n    static ingestionFn(ordered) {\n        return (jm, ctx)=>{\n            const jsub = ctx;\n            if (!jm) return {\n                ingest: false,\n                protocol: false\n            };\n            const jmi = jm;\n            if (isHeartbeatMsg(jmi.msg)) {\n                const ingest = ordered ? jsub._checkHbOrderConsumer(jmi.msg) : true;\n                if (!ordered) {\n                    jsub.info.flow_control.heartbeat_count++;\n                }\n                return {\n                    ingest,\n                    protocol: true\n                };\n            } else if (isFlowControlMsg(jmi.msg)) {\n                jsub.info.flow_control.fc_count++;\n                return {\n                    ingest: true,\n                    protocol: true\n                };\n            }\n            const ingest1 = ordered ? jsub._checkOrderedConsumer(jm) : true;\n            return {\n                ingest: ingest1,\n                protocol: false\n            };\n        };\n    }\n}\nclass NatsConnectionImpl {\n    options;\n    protocol;\n    draining;\n    listeners;\n    constructor(opts){\n        this.draining = false;\n        this.options = parseOptions(opts);\n        this.listeners = [];\n    }\n    static connect(opts = {}) {\n        return new Promise((resolve, reject)=>{\n            const nc = new NatsConnectionImpl(opts);\n            ProtocolHandler.connect(nc.options, nc).then((ph)=>{\n                nc.protocol = ph;\n                (async function() {\n                    for await (const s of ph.status()){\n                        nc.listeners.forEach((l)=>{\n                            l.push(s);\n                        });\n                    }\n                })();\n                resolve(nc);\n            }).catch((err)=>{\n                reject(err);\n            });\n        });\n    }\n    closed() {\n        return this.protocol.closed;\n    }\n    async close() {\n        await this.protocol.close();\n    }\n    _check(subject, sub, pub) {\n        if (this.isClosed()) {\n            throw NatsError.errorForCode(ErrorCode.ConnectionClosed);\n        }\n        if (sub && this.isDraining()) {\n            throw NatsError.errorForCode(ErrorCode.ConnectionDraining);\n        }\n        if (pub && this.protocol.noMorePublishing) {\n            throw NatsError.errorForCode(ErrorCode.ConnectionDraining);\n        }\n        subject = subject || \"\";\n        if (subject.length === 0) {\n            throw NatsError.errorForCode(ErrorCode.BadSubject);\n        }\n    }\n    publish(subject, data = Empty, options) {\n        this._check(subject, false, true);\n        if (data && !isUint8Array(data)) {\n            throw NatsError.errorForCode(ErrorCode.BadPayload);\n        }\n        this.protocol.publish(subject, data, options);\n    }\n    subscribe(subject, opts = {}) {\n        this._check(subject, true, false);\n        const sub = new SubscriptionImpl(this.protocol, subject, opts);\n        this.protocol.subscribe(sub);\n        return sub;\n    }\n    _resub(s, subject, max) {\n        this._check(subject, true, false);\n        const si = s;\n        si.max = max;\n        if (max) {\n            si.max = max + si.received;\n        }\n        this.protocol.resub(si, subject);\n    }\n    requestMany(subject, data = Empty, opts = {\n        maxWait: 1000,\n        maxMessages: -1\n    }) {\n        try {\n            this._check(subject, true, true);\n        } catch (err) {\n            return Promise.reject(err);\n        }\n        opts.strategy = opts.strategy || RequestStrategy.Timer;\n        opts.maxWait = opts.maxWait || 1000;\n        if (opts.maxWait < 1) {\n            return Promise.reject(new NatsError(\"timeout\", ErrorCode.InvalidOption));\n        }\n        const qi = new QueuedIteratorImpl();\n        function stop() {\n            qi.push(()=>{\n                qi.stop();\n            });\n        }\n        function callback(err, msg) {\n            if (err || msg === null) {\n                if (err !== null) {\n                    qi.push(err);\n                }\n                stop();\n            } else {\n                qi.push(msg);\n            }\n        }\n        if (opts.noMux) {\n            const stack = new Error().stack;\n            let max = typeof opts.maxMessages === \"number\" && opts.maxMessages > 0 ? opts.maxMessages : -1;\n            const sub = this.subscribe(createInbox(this.options.inboxPrefix), {\n                callback: (err, msg)=>{\n                    if (msg.data.length === 0 && msg?.headers?.status === ErrorCode.NoResponders) {\n                        err = NatsError.errorForCode(ErrorCode.NoResponders);\n                    }\n                    if (err) {\n                        err.stack += `\\n\\n${stack}`;\n                        cancel(err);\n                        return;\n                    }\n                    callback(null, msg);\n                    if (opts.strategy === RequestStrategy.Count) {\n                        max--;\n                        if (max === 0) {\n                            cancel();\n                        }\n                    }\n                    if (opts.strategy === RequestStrategy.JitterTimer) {\n                        clearTimers();\n                        timer = setTimeout(()=>{\n                            cancel();\n                        }, 300);\n                    }\n                    if (opts.strategy === RequestStrategy.SentinelMsg) {\n                        if (msg && msg.data.length === 0) {\n                            cancel();\n                        }\n                    }\n                }\n            });\n            sub.closed.then(()=>{\n                stop();\n            }).catch((err)=>{\n                qi.push(err);\n                stop();\n            });\n            const cancel = (err)=>{\n                if (err) {\n                    qi.push(err);\n                }\n                clearTimers();\n                sub.drain().then(()=>{\n                    stop();\n                }).catch((_err)=>{\n                    stop();\n                });\n            };\n            qi.iterClosed.then(()=>{\n                clearTimers();\n                sub?.unsubscribe();\n            }).catch((_err)=>{\n                clearTimers();\n                sub?.unsubscribe();\n            });\n            try {\n                this.publish(subject, Empty, {\n                    reply: sub.getSubject()\n                });\n            } catch (err1) {\n                cancel(err1);\n            }\n            let timer = setTimeout(()=>{\n                cancel();\n            }, opts.maxWait);\n            const clearTimers = ()=>{\n                if (timer) {\n                    clearTimeout(timer);\n                }\n            };\n        } else {\n            const rmo = opts;\n            rmo.callback = callback;\n            qi.iterClosed.then(()=>{\n                r.cancel();\n            }).catch((err)=>{\n                r.cancel(err);\n            });\n            const r = new RequestMany(this.protocol.muxSubscriptions, subject, rmo);\n            this.protocol.request(r);\n            try {\n                this.publish(subject, data, {\n                    reply: `${this.protocol.muxSubscriptions.baseInbox}${r.token}`,\n                    headers: opts.headers\n                });\n            } catch (err2) {\n                r.cancel(err2);\n            }\n        }\n        return Promise.resolve(qi);\n    }\n    request(subject, data = Empty, opts = {\n        timeout: 1000,\n        noMux: false\n    }) {\n        try {\n            this._check(subject, true, true);\n        } catch (err) {\n            return Promise.reject(err);\n        }\n        opts.timeout = opts.timeout || 1000;\n        if (opts.timeout < 1) {\n            return Promise.reject(new NatsError(\"timeout\", ErrorCode.InvalidOption));\n        }\n        if (!opts.noMux && opts.reply) {\n            return Promise.reject(new NatsError(\"reply can only be used with noMux\", ErrorCode.InvalidOption));\n        }\n        if (opts.noMux) {\n            const inbox = opts.reply ? opts.reply : createInbox(this.options.inboxPrefix);\n            const d = deferred();\n            const errCtx = new Error();\n            const sub = this.subscribe(inbox, {\n                max: 1,\n                timeout: opts.timeout,\n                callback: (err, msg)=>{\n                    if (err) {\n                        if (err.code !== ErrorCode.Timeout) {\n                            err.stack += `\\n\\n${errCtx.stack}`;\n                        }\n                        d.reject(err);\n                    } else {\n                        err = isRequestError(msg);\n                        if (err) {\n                            err.stack += `\\n\\n${errCtx.stack}`;\n                            d.reject(err);\n                        } else {\n                            d.resolve(msg);\n                        }\n                    }\n                }\n            });\n            sub.requestSubject = subject;\n            this.protocol.publish(subject, data, {\n                reply: inbox,\n                headers: opts.headers\n            });\n            return d;\n        } else {\n            const r = new RequestOne(this.protocol.muxSubscriptions, subject, opts);\n            this.protocol.request(r);\n            try {\n                this.publish(subject, data, {\n                    reply: `${this.protocol.muxSubscriptions.baseInbox}${r.token}`,\n                    headers: opts.headers\n                });\n            } catch (err1) {\n                r.cancel(err1);\n            }\n            const p = Promise.race([\n                r.timer,\n                r.deferred\n            ]);\n            p.catch(()=>{\n                r.cancel();\n            });\n            return p;\n        }\n    }\n    flush() {\n        if (this.isClosed()) {\n            return Promise.reject(NatsError.errorForCode(ErrorCode.ConnectionClosed));\n        }\n        return this.protocol.flush();\n    }\n    drain() {\n        if (this.isClosed()) {\n            return Promise.reject(NatsError.errorForCode(ErrorCode.ConnectionClosed));\n        }\n        if (this.isDraining()) {\n            return Promise.reject(NatsError.errorForCode(ErrorCode.ConnectionDraining));\n        }\n        this.draining = true;\n        return this.protocol.drain();\n    }\n    isClosed() {\n        return this.protocol.isClosed();\n    }\n    isDraining() {\n        return this.draining;\n    }\n    getServer() {\n        const srv = this.protocol.getServer();\n        return srv ? srv.listen : \"\";\n    }\n    status() {\n        const iter = new QueuedIteratorImpl();\n        this.listeners.push(iter);\n        return iter;\n    }\n    get info() {\n        return this.protocol.isClosed() ? undefined : this.protocol.info;\n    }\n    stats() {\n        return {\n            inBytes: this.protocol.inBytes,\n            outBytes: this.protocol.outBytes,\n            inMsgs: this.protocol.inMsgs,\n            outMsgs: this.protocol.outMsgs\n        };\n    }\n    async jetstreamManager(opts = {}) {\n        const adm = new JetStreamManagerImpl(this, opts);\n        try {\n            await adm.getAccountInfo();\n        } catch (err) {\n            const ne = err;\n            if (ne.code === ErrorCode.NoResponders) {\n                ne.code = ErrorCode.JetStreamNotEnabled;\n            }\n            throw ne;\n        }\n        return adm;\n    }\n    jetstream(opts = {}) {\n        return new JetStreamClientImpl(this, opts);\n    }\n    getServerVersion() {\n        const info = this.info;\n        return info ? parseSemVer(info.version) : undefined;\n    }\n    async rtt() {\n        if (!this.protocol._closed && !this.protocol.connected) {\n            throw NatsError.errorForCode(ErrorCode.Disconnect);\n        }\n        const start = Date.now();\n        await this.flush();\n        return Date.now() - start;\n    }\n}\nfunction checkOptions(info, options) {\n    const { proto , tls_required: tlsRequired , tls_available: tlsAvailable  } = info;\n    if ((proto === undefined || proto < 1) && options.noEcho) {\n        throw new NatsError(\"noEcho\", ErrorCode.ServerOptionNotAvailable);\n    }\n    const tls = tlsRequired || tlsAvailable || false;\n    if (options.tls && !tls) {\n        throw new NatsError(\"tls\", ErrorCode.ServerOptionNotAvailable);\n    }\n}\nclass JetStreamSubscriptionImpl extends TypedSubscription {\n    js;\n    constructor(js, subject, opts){\n        super(js.nc, subject, opts);\n        this.js = js;\n    }\n    set info(info) {\n        this.sub.info = info;\n    }\n    get info() {\n        return this.sub.info;\n    }\n    _resetOrderedConsumer(sseq) {\n        if (this.info === null || this.sub.isClosed()) {\n            return;\n        }\n        const newDeliver = createInbox(this.js.nc.options.inboxPrefix);\n        const nci = this.js.nc;\n        nci._resub(this.sub, newDeliver);\n        const info = this.info;\n        info.ordered_consumer_sequence.delivery_seq = 0;\n        info.flow_control.heartbeat_count = 0;\n        info.flow_control.fc_count = 0;\n        info.flow_control.consumer_restarts++;\n        info.deliver = newDeliver;\n        info.config.deliver_subject = newDeliver;\n        info.config.deliver_policy = DeliverPolicy.StartSequence;\n        info.config.opt_start_seq = sseq;\n        const subj = `${info.api.prefix}.CONSUMER.CREATE.${info.stream}`;\n        this.js._request(subj, this.info.config).catch((err)=>{\n            const nerr = new NatsError(`unable to recreate ordered consumer ${info.stream} at seq ${sseq}`, ErrorCode.RequestError, err);\n            this.sub.callback(nerr, {});\n        });\n    }\n    _checkHbOrderConsumer(msg) {\n        const rm = msg.headers.get(JsHeaders.ConsumerStalledHdr);\n        if (rm !== \"\") {\n            const nci = this.js.nc;\n            nci.publish(rm);\n        }\n        const lastDelivered = parseInt(msg.headers.get(JsHeaders.LastConsumerSeqHdr), 10);\n        const ordered = this.info.ordered_consumer_sequence;\n        this.info.flow_control.heartbeat_count++;\n        if (lastDelivered !== ordered.delivery_seq) {\n            this._resetOrderedConsumer(ordered.stream_seq + 1);\n        }\n        return false;\n    }\n    _checkOrderedConsumer(jm) {\n        const ordered = this.info.ordered_consumer_sequence;\n        const sseq = jm.info.streamSequence;\n        const dseq = jm.info.deliverySequence;\n        if (dseq != ordered.delivery_seq + 1) {\n            this._resetOrderedConsumer(ordered.stream_seq + 1);\n            return false;\n        }\n        ordered.delivery_seq = dseq;\n        ordered.stream_seq = sseq;\n        return true;\n    }\n    async destroy() {\n        if (!this.isClosed()) {\n            await this.drain();\n        }\n        const jinfo = this.sub.info;\n        const name = jinfo.config.durable_name || jinfo.name;\n        const subj = `${jinfo.api.prefix}.CONSUMER.DELETE.${jinfo.stream}.${name}`;\n        await jinfo.api._request(subj);\n    }\n    async consumerInfo() {\n        const jinfo = this.sub.info;\n        const name = jinfo.config.durable_name || jinfo.name;\n        const subj = `${jinfo.api.prefix}.CONSUMER.INFO.${jinfo.stream}.${name}`;\n        const ci = await jinfo.api._request(subj);\n        jinfo.last = ci;\n        return ci;\n    }\n}\nclass JetStreamPullSubscriptionImpl extends JetStreamSubscriptionImpl {\n    constructor(js, subject, opts){\n        super(js, subject, opts);\n    }\n    pull(opts = {\n        batch: 1\n    }) {\n        const { stream , config , name  } = this.sub.info;\n        const consumer = config.durable_name ?? name;\n        const args = {};\n        args.batch = opts.batch || 1;\n        args.no_wait = opts.no_wait || false;\n        if ((opts.max_bytes ?? 0) > 0) {\n            const fv = this.js.nc.protocol.features.get(Feature.JS_PULL_MAX_BYTES);\n            if (!fv.ok) {\n                throw new Error(`max_bytes is only supported on servers ${fv.min} or better`);\n            }\n            args.max_bytes = opts.max_bytes;\n        }\n        if (opts.expires && opts.expires > 0) {\n            args.expires = nanos(opts.expires);\n        }\n        if (this.info) {\n            const api = this.info.api;\n            const subj = `${api.prefix}.CONSUMER.MSG.NEXT.${stream}.${consumer}`;\n            const reply = this.sub.subject;\n            api.nc.publish(subj, api.jc.encode(args), {\n                reply: reply\n            });\n        }\n    }\n}\nfunction msgAdapter(iterator) {\n    if (iterator) {\n        return iterMsgAdapter;\n    } else {\n        return cbMsgAdapter;\n    }\n}\nfunction cbMsgAdapter(err, msg) {\n    if (err) {\n        return [\n            err,\n            null\n        ];\n    }\n    err = checkJsError(msg);\n    if (err) {\n        return [\n            err,\n            null\n        ];\n    }\n    return [\n        null,\n        toJsMsg(msg)\n    ];\n}\nfunction iterMsgAdapter(err, msg) {\n    if (err) {\n        return [\n            err,\n            null\n        ];\n    }\n    const ne = checkJsError(msg);\n    if (ne !== null) {\n        return [\n            hideNonTerminalJsErrors(ne),\n            null\n        ];\n    }\n    return [\n        null,\n        toJsMsg(msg)\n    ];\n}\nfunction hideNonTerminalJsErrors(ne) {\n    if (ne !== null) {\n        switch(ne.code){\n            case ErrorCode.JetStream404NoMessages:\n            case ErrorCode.JetStream408RequestTimeout:\n                return null;\n            case ErrorCode.JetStream409:\n                if (isTerminal409(ne)) {\n                    return ne;\n                }\n                return null;\n            default:\n                return ne;\n        }\n    }\n    return null;\n}\nfunction autoAckJsMsg(data) {\n    if (data) {\n        data.ack();\n    }\n}\nconst jetstreamPreview = (()=>{\n    let once = false;\n    return (nci)=>{\n        if (!once) {\n            once = true;\n            const { lang  } = nci?.protocol?.transport;\n            if (lang) {\n                console.log(`\\u001B[33m >> jetstream's materialized views object store functionality in ${lang} is beta functionality \\u001B[0m`);\n            } else {\n                console.log(`\\u001B[33m >> jetstream's materialized views object store functionality is beta functionality \\u001B[0m`);\n            }\n        }\n    };\n})();\nclass Base64Codec {\n    static encode(bytes) {\n        if (typeof bytes === \"string\") {\n            return btoa(bytes);\n        }\n        const a = Array.from(bytes);\n        return btoa(String.fromCharCode(...a));\n    }\n    static decode(s, binary = false) {\n        const bin = atob(s);\n        if (!binary) {\n            return bin;\n        }\n        const bytes = new Uint8Array(bin.length);\n        for(let i = 0; i < bin.length; i++){\n            bytes[i] = bin.charCodeAt(i);\n        }\n        return bytes;\n    }\n}\nclass Base64UrlCodec {\n    static encode(bytes) {\n        return Base64UrlCodec.toB64URLEncoding(Base64Codec.encode(bytes));\n    }\n    static decode(s, binary = false) {\n        return Base64Codec.decode(Base64UrlCodec.fromB64URLEncoding(s), binary);\n    }\n    static toB64URLEncoding(b64str) {\n        b64str = b64str.replace(/=/g, \"\");\n        b64str = b64str.replace(/\\+/g, \"-\");\n        return b64str.replace(/\\//g, \"_\");\n    }\n    static fromB64URLEncoding(b64str) {\n        b64str = b64str.replace(/_/g, \"/\");\n        b64str = b64str.replace(/-/g, \"+\");\n        return b64str;\n    }\n}\nconst VERSION = \"1.9.0\";\nconst LANG = \"nats.ws\";\nclass WsTransport {\n    version;\n    lang;\n    closeError;\n    connected;\n    done;\n    socket;\n    options;\n    socketClosed;\n    encrypted;\n    peeked;\n    yields;\n    signal;\n    closedNotification;\n    constructor(){\n        this.version = VERSION;\n        this.lang = LANG;\n        this.connected = false;\n        this.done = false;\n        this.socketClosed = false;\n        this.encrypted = false;\n        this.peeked = false;\n        this.yields = [];\n        this.signal = deferred();\n        this.closedNotification = deferred();\n    }\n    async connect(server, options) {\n        const connected = false;\n        const connLock = deferred();\n        if (options.tls) {\n            connLock.reject(new NatsError(\"tls\", ErrorCode.InvalidOption));\n            return connLock;\n        }\n        this.options = options;\n        const u = server.src;\n        if (options.wsFactory) {\n            const { socket , encrypted  } = await options.wsFactory(server.src, options);\n            this.socket = socket;\n            this.encrypted = encrypted;\n        } else {\n            this.encrypted = u.indexOf(\"wss://\") === 0;\n            this.socket = new WebSocket(u);\n        }\n        this.socket.binaryType = \"arraybuffer\";\n        this.socket.onopen = ()=>{};\n        this.socket.onmessage = (me)=>{\n            this.yields.push(new Uint8Array(me.data));\n            if (this.peeked) {\n                this.signal.resolve();\n                return;\n            }\n            const t = DataBuffer.concat(...this.yields);\n            const pm = extractProtocolMessage(t);\n            if (pm !== \"\") {\n                const m = INFO.exec(pm);\n                if (!m) {\n                    if (options.debug) {\n                        console.error(\"!!!\", render(t));\n                    }\n                    connLock.reject(new Error(\"unexpected response from server\"));\n                    return;\n                }\n                try {\n                    const info = JSON.parse(m[1]);\n                    checkOptions(info, this.options);\n                    this.peeked = true;\n                    this.connected = true;\n                    this.signal.resolve();\n                    connLock.resolve();\n                } catch (err) {\n                    connLock.reject(err);\n                    return;\n                }\n            }\n        };\n        this.socket.onclose = (evt)=>{\n            this.socketClosed = true;\n            let reason;\n            if (this.done) return;\n            if (!evt.wasClean) {\n                reason = new Error(evt.reason);\n            }\n            this._closed(reason);\n        };\n        this.socket.onerror = (e)=>{\n            const evt = e;\n            const err = new NatsError(evt.message, ErrorCode.Unknown, new Error(evt.error));\n            if (!connected) {\n                connLock.reject(err);\n            } else {\n                this._closed(err);\n            }\n        };\n        return connLock;\n    }\n    disconnect() {\n        this._closed(undefined, true);\n    }\n    async _closed(err, internal = true) {\n        if (!this.connected) return;\n        if (this.done) return;\n        this.closeError = err;\n        if (!err) {\n            while(!this.socketClosed && this.socket.bufferedAmount > 0){\n                console.log(this.socket.bufferedAmount);\n                await delay(100);\n            }\n        }\n        this.done = true;\n        try {\n            this.socket.close(err ? 1002 : 1000, err ? err.message : undefined);\n        } catch (err1) {}\n        if (internal) {\n            this.closedNotification.resolve(err);\n        }\n    }\n    get isClosed() {\n        return this.done;\n    }\n    [Symbol.asyncIterator]() {\n        return this.iterate();\n    }\n    async *iterate() {\n        while(true){\n            if (this.yields.length === 0) {\n                await this.signal;\n            }\n            const yields = this.yields;\n            this.yields = [];\n            for(let i = 0; i < yields.length; i++){\n                if (this.options.debug) {\n                    console.info(`> ${render(yields[i])}`);\n                }\n                yield yields[i];\n            }\n            if (this.done) {\n                break;\n            } else if (this.yields.length === 0) {\n                yields.length = 0;\n                this.yields = yields;\n                this.signal = deferred();\n            }\n        }\n    }\n    isEncrypted() {\n        return this.connected && this.encrypted;\n    }\n    send(frame) {\n        if (this.done) {\n            return;\n        }\n        try {\n            this.socket.send(frame.buffer);\n            if (this.options.debug) {\n                console.info(`< ${render(frame)}`);\n            }\n            return;\n        } catch (err) {\n            if (this.options.debug) {\n                console.error(`!!! ${render(frame)}: ${err}`);\n            }\n        }\n    }\n    close(err) {\n        return this._closed(err, false);\n    }\n    closed() {\n        return this.closedNotification;\n    }\n}\nfunction wsUrlParseFn(u) {\n    const ut = /^(.*:\\/\\/)(.*)/;\n    if (!ut.test(u)) {\n        u = `https://${u}`;\n    }\n    let url = new URL(u);\n    const srcProto = url.protocol.toLowerCase();\n    if (srcProto !== \"https:\" && srcProto !== \"http\") {\n        u = u.replace(/^(.*:\\/\\/)(.*)/gm, \"$2\");\n        url = new URL(`http://${u}`);\n    }\n    let protocol;\n    let port;\n    const host = url.hostname;\n    const path = url.pathname;\n    const search = url.search || \"\";\n    switch(srcProto){\n        case \"http:\":\n        case \"ws:\":\n        case \"nats:\":\n            port = url.port || \"80\";\n            protocol = \"ws:\";\n            break;\n        default:\n            port = url.port || \"443\";\n            protocol = \"wss:\";\n            break;\n    }\n    return `${protocol}//${host}:${port}${path}${search}`;\n}\nfunction connect(opts = {}) {\n    setTransportFactory({\n        defaultPort: 443,\n        urlParseFn: wsUrlParseFn,\n        factory: ()=>{\n            return new WsTransport();\n        }\n    });\n    return NatsConnectionImpl.connect(opts);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmF0cy53cy9lc20vbmF0cy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0Q0FBNEM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEVBQUU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsVUFBVTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQSxRQUFRLDhDQUE4QztBQUN0RDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSSxFQUFFLHVCQUF1QixFQUFFLG9CQUFvQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEdBQUc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaUNBQWlDLEVBQUUsUUFBUTtBQUM3RSxxQkFBcUI7QUFDckIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0EsYUFBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLE1BQU07QUFDNUU7QUFDQTtBQUNBLHNFQUFzRSxNQUFNO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHlCQUF5QjtBQUNsRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0JBQW9CO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxhQUFhLEVBQUUsV0FBVyxFQUFFLFFBQVEsRUFBRSxNQUFNO0FBQzdFLGNBQWM7QUFDZCxpQ0FBaUMsYUFBYSxFQUFFLFFBQVEsRUFBRSxNQUFNO0FBQ2hFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxjQUFjO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsTUFBTTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQix1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQix1QkFBdUIsUUFBUTtBQUMvQiwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QixtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQix1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsY0FBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQyw0R0FBNEc7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0M7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QkFBaUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQixRQUFRLFdBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLFFBQVEsV0FBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsVUFBVSxLQUFLLElBQUk7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDZFQUE2RSxJQUFJO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSx5QkFBeUIsbUJBQW1CLFdBQVc7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVMsSUFBSSxLQUFLLEdBQUcsS0FBSyxFQUFFLEtBQUssRUFBRSxPQUFPO0FBQ3hEO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQzhCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uYXRzLndzL2VzbS9uYXRzLmpzPzk0YzkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZGVuby1mbXQtaWdub3JlLWZpbGVcbi8vIGRlbm8tbGludC1pZ25vcmUtZmlsZVxuLy8gVGhpcyBjb2RlIHdhcyBidW5kbGVkIHVzaW5nIGBkZW5vIGJ1bmRsZWAgYW5kIGl0J3Mgbm90IHJlY29tbWVuZGVkIHRvIGVkaXQgaXQgbWFudWFsbHlcblxuY29uc3QgRW1wdHkgPSBuZXcgVWludDhBcnJheSgwKTtcbnZhciBFdmVudHM7XG4oZnVuY3Rpb24oRXZlbnRzKSB7XG4gICAgRXZlbnRzW1wiRGlzY29ubmVjdFwiXSA9IFwiZGlzY29ubmVjdFwiO1xuICAgIEV2ZW50c1tcIlJlY29ubmVjdFwiXSA9IFwicmVjb25uZWN0XCI7XG4gICAgRXZlbnRzW1wiVXBkYXRlXCJdID0gXCJ1cGRhdGVcIjtcbiAgICBFdmVudHNbXCJMRE1cIl0gPSBcImxkbVwiO1xuICAgIEV2ZW50c1tcIkVycm9yXCJdID0gXCJlcnJvclwiO1xufSkoRXZlbnRzIHx8IChFdmVudHMgPSB7fSkpO1xudmFyIERlYnVnRXZlbnRzO1xuKGZ1bmN0aW9uKERlYnVnRXZlbnRzKSB7XG4gICAgRGVidWdFdmVudHNbXCJSZWNvbm5lY3RpbmdcIl0gPSBcInJlY29ubmVjdGluZ1wiO1xuICAgIERlYnVnRXZlbnRzW1wiUGluZ1RpbWVyXCJdID0gXCJwaW5nVGltZXJcIjtcbiAgICBEZWJ1Z0V2ZW50c1tcIlN0YWxlQ29ubmVjdGlvblwiXSA9IFwic3RhbGVDb25uZWN0aW9uXCI7XG59KShEZWJ1Z0V2ZW50cyB8fCAoRGVidWdFdmVudHMgPSB7fSkpO1xuY29uc3QgREVGQVVMVF9IT1NUID0gXCIxMjcuMC4wLjFcIjtcbmNvbnN0IERFRkFVTFRfUkVDT05ORUNUX1RJTUVfV0FJVCA9IDIgKiAxMDAwO1xuY29uc3QgREVGQVVMVF9QSU5HX0lOVEVSVkFMID0gMiAqIDYwICogMTAwMDtcbmNvbnN0IERFRkFVTFRfTUFYX1BJTkdfT1VUID0gMjtcbnZhciBSZXF1ZXN0U3RyYXRlZ3k7XG4oZnVuY3Rpb24oUmVxdWVzdFN0cmF0ZWd5KSB7XG4gICAgUmVxdWVzdFN0cmF0ZWd5W1wiVGltZXJcIl0gPSBcInRpbWVyXCI7XG4gICAgUmVxdWVzdFN0cmF0ZWd5W1wiQ291bnRcIl0gPSBcImNvdW50XCI7XG4gICAgUmVxdWVzdFN0cmF0ZWd5W1wiSml0dGVyVGltZXJcIl0gPSBcImppdHRlclRpbWVyXCI7XG4gICAgUmVxdWVzdFN0cmF0ZWd5W1wiU2VudGluZWxNc2dcIl0gPSBcInNlbnRpbmVsTXNnXCI7XG59KShSZXF1ZXN0U3RyYXRlZ3kgfHwgKFJlcXVlc3RTdHJhdGVneSA9IHt9KSk7XG52YXIgQWR2aXNvcnlLaW5kO1xuKGZ1bmN0aW9uKEFkdmlzb3J5S2luZCkge1xuICAgIEFkdmlzb3J5S2luZFtcIkFQSVwiXSA9IFwiYXBpX2F1ZGl0XCI7XG4gICAgQWR2aXNvcnlLaW5kW1wiU3RyZWFtQWN0aW9uXCJdID0gXCJzdHJlYW1fYWN0aW9uXCI7XG4gICAgQWR2aXNvcnlLaW5kW1wiQ29uc3VtZXJBY3Rpb25cIl0gPSBcImNvbnN1bWVyX2FjdGlvblwiO1xuICAgIEFkdmlzb3J5S2luZFtcIlNuYXBzaG90Q3JlYXRlXCJdID0gXCJzbmFwc2hvdF9jcmVhdGVcIjtcbiAgICBBZHZpc29yeUtpbmRbXCJTbmFwc2hvdENvbXBsZXRlXCJdID0gXCJzbmFwc2hvdF9jb21wbGV0ZVwiO1xuICAgIEFkdmlzb3J5S2luZFtcIlJlc3RvcmVDcmVhdGVcIl0gPSBcInJlc3RvcmVfY3JlYXRlXCI7XG4gICAgQWR2aXNvcnlLaW5kW1wiUmVzdG9yZUNvbXBsZXRlXCJdID0gXCJyZXN0b3JlX2NvbXBsZXRlXCI7XG4gICAgQWR2aXNvcnlLaW5kW1wiTWF4RGVsaXZlclwiXSA9IFwibWF4X2RlbGl2ZXJcIjtcbiAgICBBZHZpc29yeUtpbmRbXCJUZXJtaW5hdGVkXCJdID0gXCJ0ZXJtaW5hdGVkXCI7XG4gICAgQWR2aXNvcnlLaW5kW1wiQWNrXCJdID0gXCJjb25zdW1lcl9hY2tcIjtcbiAgICBBZHZpc29yeUtpbmRbXCJTdHJlYW1MZWFkZXJFbGVjdGVkXCJdID0gXCJzdHJlYW1fbGVhZGVyX2VsZWN0ZWRcIjtcbiAgICBBZHZpc29yeUtpbmRbXCJTdHJlYW1RdW9ydW1Mb3N0XCJdID0gXCJzdHJlYW1fcXVvcnVtX2xvc3RcIjtcbiAgICBBZHZpc29yeUtpbmRbXCJDb25zdW1lckxlYWRlckVsZWN0ZWRcIl0gPSBcImNvbnN1bWVyX2xlYWRlcl9lbGVjdGVkXCI7XG4gICAgQWR2aXNvcnlLaW5kW1wiQ29uc3VtZXJRdW9ydW1Mb3N0XCJdID0gXCJjb25zdW1lcl9xdW9ydW1fbG9zdFwiO1xufSkoQWR2aXNvcnlLaW5kIHx8IChBZHZpc29yeUtpbmQgPSB7fSkpO1xudmFyIFJldGVudGlvblBvbGljeTtcbihmdW5jdGlvbihSZXRlbnRpb25Qb2xpY3kpIHtcbiAgICBSZXRlbnRpb25Qb2xpY3lbXCJMaW1pdHNcIl0gPSBcImxpbWl0c1wiO1xuICAgIFJldGVudGlvblBvbGljeVtcIkludGVyZXN0XCJdID0gXCJpbnRlcmVzdFwiO1xuICAgIFJldGVudGlvblBvbGljeVtcIldvcmtxdWV1ZVwiXSA9IFwid29ya3F1ZXVlXCI7XG59KShSZXRlbnRpb25Qb2xpY3kgfHwgKFJldGVudGlvblBvbGljeSA9IHt9KSk7XG52YXIgRGlzY2FyZFBvbGljeTtcbihmdW5jdGlvbihEaXNjYXJkUG9saWN5KSB7XG4gICAgRGlzY2FyZFBvbGljeVtcIk9sZFwiXSA9IFwib2xkXCI7XG4gICAgRGlzY2FyZFBvbGljeVtcIk5ld1wiXSA9IFwibmV3XCI7XG59KShEaXNjYXJkUG9saWN5IHx8IChEaXNjYXJkUG9saWN5ID0ge30pKTtcbnZhciBTdG9yYWdlVHlwZTtcbihmdW5jdGlvbihTdG9yYWdlVHlwZSkge1xuICAgIFN0b3JhZ2VUeXBlW1wiRmlsZVwiXSA9IFwiZmlsZVwiO1xuICAgIFN0b3JhZ2VUeXBlW1wiTWVtb3J5XCJdID0gXCJtZW1vcnlcIjtcbn0pKFN0b3JhZ2VUeXBlIHx8IChTdG9yYWdlVHlwZSA9IHt9KSk7XG52YXIgRGVsaXZlclBvbGljeTtcbihmdW5jdGlvbihEZWxpdmVyUG9saWN5KSB7XG4gICAgRGVsaXZlclBvbGljeVtcIkFsbFwiXSA9IFwiYWxsXCI7XG4gICAgRGVsaXZlclBvbGljeVtcIkxhc3RcIl0gPSBcImxhc3RcIjtcbiAgICBEZWxpdmVyUG9saWN5W1wiTmV3XCJdID0gXCJuZXdcIjtcbiAgICBEZWxpdmVyUG9saWN5W1wiU3RhcnRTZXF1ZW5jZVwiXSA9IFwiYnlfc3RhcnRfc2VxdWVuY2VcIjtcbiAgICBEZWxpdmVyUG9saWN5W1wiU3RhcnRUaW1lXCJdID0gXCJieV9zdGFydF90aW1lXCI7XG4gICAgRGVsaXZlclBvbGljeVtcIkxhc3RQZXJTdWJqZWN0XCJdID0gXCJsYXN0X3Blcl9zdWJqZWN0XCI7XG59KShEZWxpdmVyUG9saWN5IHx8IChEZWxpdmVyUG9saWN5ID0ge30pKTtcbnZhciBBY2tQb2xpY3k7XG4oZnVuY3Rpb24oQWNrUG9saWN5KSB7XG4gICAgQWNrUG9saWN5W1wiTm9uZVwiXSA9IFwibm9uZVwiO1xuICAgIEFja1BvbGljeVtcIkFsbFwiXSA9IFwiYWxsXCI7XG4gICAgQWNrUG9saWN5W1wiRXhwbGljaXRcIl0gPSBcImV4cGxpY2l0XCI7XG4gICAgQWNrUG9saWN5W1wiTm90U2V0XCJdID0gXCJcIjtcbn0pKEFja1BvbGljeSB8fCAoQWNrUG9saWN5ID0ge30pKTtcbnZhciBSZXBsYXlQb2xpY3k7XG4oZnVuY3Rpb24oUmVwbGF5UG9saWN5KSB7XG4gICAgUmVwbGF5UG9saWN5W1wiSW5zdGFudFwiXSA9IFwiaW5zdGFudFwiO1xuICAgIFJlcGxheVBvbGljeVtcIk9yaWdpbmFsXCJdID0gXCJvcmlnaW5hbFwiO1xufSkoUmVwbGF5UG9saWN5IHx8IChSZXBsYXlQb2xpY3kgPSB7fSkpO1xudmFyIEpzSGVhZGVycztcbihmdW5jdGlvbihKc0hlYWRlcnMpIHtcbiAgICBKc0hlYWRlcnNbXCJTdHJlYW1Tb3VyY2VIZHJcIl0gPSBcIk5hdHMtU3RyZWFtLVNvdXJjZVwiO1xuICAgIEpzSGVhZGVyc1tcIkxhc3RDb25zdW1lclNlcUhkclwiXSA9IFwiTmF0cy1MYXN0LUNvbnN1bWVyXCI7XG4gICAgSnNIZWFkZXJzW1wiTGFzdFN0cmVhbVNlcUhkclwiXSA9IFwiTmF0cy1MYXN0LVN0cmVhbVwiO1xuICAgIEpzSGVhZGVyc1tcIkNvbnN1bWVyU3RhbGxlZEhkclwiXSA9IFwiTmF0cy1Db25zdW1lci1TdGFsbGVkXCI7XG4gICAgSnNIZWFkZXJzW1wiTWVzc2FnZVNpemVIZHJcIl0gPSBcIk5hdHMtTXNnLVNpemVcIjtcbiAgICBKc0hlYWRlcnNbXCJSb2xsdXBIZHJcIl0gPSBcIk5hdHMtUm9sbHVwXCI7XG4gICAgSnNIZWFkZXJzW1wiUm9sbHVwVmFsdWVTdWJqZWN0XCJdID0gXCJzdWJcIjtcbiAgICBKc0hlYWRlcnNbXCJSb2xsdXBWYWx1ZUFsbFwiXSA9IFwiYWxsXCI7XG59KShKc0hlYWRlcnMgfHwgKEpzSGVhZGVycyA9IHt9KSk7XG52YXIgRGlyZWN0TXNnSGVhZGVycztcbihmdW5jdGlvbihEaXJlY3RNc2dIZWFkZXJzKSB7XG4gICAgRGlyZWN0TXNnSGVhZGVyc1tcIlN0cmVhbVwiXSA9IFwiTmF0cy1TdHJlYW1cIjtcbiAgICBEaXJlY3RNc2dIZWFkZXJzW1wiU2VxdWVuY2VcIl0gPSBcIk5hdHMtU2VxdWVuY2VcIjtcbiAgICBEaXJlY3RNc2dIZWFkZXJzW1wiVGltZVN0YW1wXCJdID0gXCJOYXRzLVRpbWUtU3RhbXBcIjtcbiAgICBEaXJlY3RNc2dIZWFkZXJzW1wiU3ViamVjdFwiXSA9IFwiTmF0cy1TdWJqZWN0XCI7XG59KShEaXJlY3RNc2dIZWFkZXJzIHx8IChEaXJlY3RNc2dIZWFkZXJzID0ge30pKTtcbnZhciBSZXB1Ymxpc2hIZWFkZXJzO1xuKGZ1bmN0aW9uKFJlcHVibGlzaEhlYWRlcnMpIHtcbiAgICBSZXB1Ymxpc2hIZWFkZXJzW1wiU3RyZWFtXCJdID0gXCJOYXRzLVN0cmVhbVwiO1xuICAgIFJlcHVibGlzaEhlYWRlcnNbXCJTdWJqZWN0XCJdID0gXCJOYXRzLVN1YmplY3RcIjtcbiAgICBSZXB1Ymxpc2hIZWFkZXJzW1wiU2VxdWVuY2VcIl0gPSBcIk5hdHMtU2VxdWVuY2VcIjtcbiAgICBSZXB1Ymxpc2hIZWFkZXJzW1wiTGFzdFNlcXVlbmNlXCJdID0gXCJOYXRzLUxhc3QtU2VxdWVuY2VcIjtcbiAgICBSZXB1Ymxpc2hIZWFkZXJzW1wiU2l6ZVwiXSA9IFwiTmF0cy1Nc2ctU2l6ZVwiO1xufSkoUmVwdWJsaXNoSGVhZGVycyB8fCAoUmVwdWJsaXNoSGVhZGVycyA9IHt9KSk7XG52YXIgRXJyb3JDb2RlO1xuKGZ1bmN0aW9uKEVycm9yQ29kZSkge1xuICAgIEVycm9yQ29kZVtcIkFwaUVycm9yXCJdID0gXCJCQUQgQVBJXCI7XG4gICAgRXJyb3JDb2RlW1wiQmFkQXV0aGVudGljYXRpb25cIl0gPSBcIkJBRF9BVVRIRU5USUNBVElPTlwiO1xuICAgIEVycm9yQ29kZVtcIkJhZENyZWRzXCJdID0gXCJCQURfQ1JFRFNcIjtcbiAgICBFcnJvckNvZGVbXCJCYWRIZWFkZXJcIl0gPSBcIkJBRF9IRUFERVJcIjtcbiAgICBFcnJvckNvZGVbXCJCYWRKc29uXCJdID0gXCJCQURfSlNPTlwiO1xuICAgIEVycm9yQ29kZVtcIkJhZFBheWxvYWRcIl0gPSBcIkJBRF9QQVlMT0FEXCI7XG4gICAgRXJyb3JDb2RlW1wiQmFkU3ViamVjdFwiXSA9IFwiQkFEX1NVQkpFQ1RcIjtcbiAgICBFcnJvckNvZGVbXCJDYW5jZWxsZWRcIl0gPSBcIkNBTkNFTExFRFwiO1xuICAgIEVycm9yQ29kZVtcIkNvbm5lY3Rpb25DbG9zZWRcIl0gPSBcIkNPTk5FQ1RJT05fQ0xPU0VEXCI7XG4gICAgRXJyb3JDb2RlW1wiQ29ubmVjdGlvbkRyYWluaW5nXCJdID0gXCJDT05ORUNUSU9OX0RSQUlOSU5HXCI7XG4gICAgRXJyb3JDb2RlW1wiQ29ubmVjdGlvblJlZnVzZWRcIl0gPSBcIkNPTk5FQ1RJT05fUkVGVVNFRFwiO1xuICAgIEVycm9yQ29kZVtcIkNvbm5lY3Rpb25UaW1lb3V0XCJdID0gXCJDT05ORUNUSU9OX1RJTUVPVVRcIjtcbiAgICBFcnJvckNvZGVbXCJEaXNjb25uZWN0XCJdID0gXCJESVNDT05ORUNUXCI7XG4gICAgRXJyb3JDb2RlW1wiSW52YWxpZE9wdGlvblwiXSA9IFwiSU5WQUxJRF9PUFRJT05cIjtcbiAgICBFcnJvckNvZGVbXCJJbnZhbGlkUGF5bG9hZFwiXSA9IFwiSU5WQUxJRF9QQVlMT0FEXCI7XG4gICAgRXJyb3JDb2RlW1wiTWF4UGF5bG9hZEV4Y2VlZGVkXCJdID0gXCJNQVhfUEFZTE9BRF9FWENFRURFRFwiO1xuICAgIEVycm9yQ29kZVtcIk5vUmVzcG9uZGVyc1wiXSA9IFwiNTAzXCI7XG4gICAgRXJyb3JDb2RlW1wiTm90RnVuY3Rpb25cIl0gPSBcIk5PVF9GVU5DXCI7XG4gICAgRXJyb3JDb2RlW1wiUmVxdWVzdEVycm9yXCJdID0gXCJSRVFVRVNUX0VSUk9SXCI7XG4gICAgRXJyb3JDb2RlW1wiU2VydmVyT3B0aW9uTm90QXZhaWxhYmxlXCJdID0gXCJTRVJWRVJfT1BUX05BXCI7XG4gICAgRXJyb3JDb2RlW1wiU3ViQ2xvc2VkXCJdID0gXCJTVUJfQ0xPU0VEXCI7XG4gICAgRXJyb3JDb2RlW1wiU3ViRHJhaW5pbmdcIl0gPSBcIlNVQl9EUkFJTklOR1wiO1xuICAgIEVycm9yQ29kZVtcIlRpbWVvdXRcIl0gPSBcIlRJTUVPVVRcIjtcbiAgICBFcnJvckNvZGVbXCJUbHNcIl0gPSBcIlRMU1wiO1xuICAgIEVycm9yQ29kZVtcIlVua25vd25cIl0gPSBcIlVOS05PV05fRVJST1JcIjtcbiAgICBFcnJvckNvZGVbXCJXc3NSZXF1aXJlZFwiXSA9IFwiV1NTX1JFUVVJUkVEXCI7XG4gICAgRXJyb3JDb2RlW1wiSmV0U3RyZWFtSW52YWxpZEFja1wiXSA9IFwiSkVTVFJFQU1fSU5WQUxJRF9BQ0tcIjtcbiAgICBFcnJvckNvZGVbXCJKZXRTdHJlYW00MDROb01lc3NhZ2VzXCJdID0gXCI0MDRcIjtcbiAgICBFcnJvckNvZGVbXCJKZXRTdHJlYW00MDhSZXF1ZXN0VGltZW91dFwiXSA9IFwiNDA4XCI7XG4gICAgRXJyb3JDb2RlW1wiSmV0U3RyZWFtNDA5TWF4QWNrUGVuZGluZ0V4Y2VlZGVkXCJdID0gXCI0MDlcIjtcbiAgICBFcnJvckNvZGVbXCJKZXRTdHJlYW00MDlcIl0gPSBcIjQwOVwiO1xuICAgIEVycm9yQ29kZVtcIkpldFN0cmVhbU5vdEVuYWJsZWRcIl0gPSBcIjUwM1wiO1xuICAgIEVycm9yQ29kZVtcIkF1dGhvcml6YXRpb25WaW9sYXRpb25cIl0gPSBcIkFVVEhPUklaQVRJT05fVklPTEFUSU9OXCI7XG4gICAgRXJyb3JDb2RlW1wiQXV0aGVudGljYXRpb25FeHBpcmVkXCJdID0gXCJBVVRIRU5USUNBVElPTl9FWFBJUkVEXCI7XG4gICAgRXJyb3JDb2RlW1wiUHJvdG9jb2xFcnJvclwiXSA9IFwiTkFUU19QUk9UT0NPTF9FUlJcIjtcbiAgICBFcnJvckNvZGVbXCJQZXJtaXNzaW9uc1Zpb2xhdGlvblwiXSA9IFwiUEVSTUlTU0lPTlNfVklPTEFUSU9OXCI7XG59KShFcnJvckNvZGUgfHwgKEVycm9yQ29kZSA9IHt9KSk7XG5jbGFzcyBNZXNzYWdlcyB7XG4gICAgbWVzc2FnZXM7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5tZXNzYWdlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlcy5zZXQoRXJyb3JDb2RlLkludmFsaWRQYXlsb2FkLCBcIkludmFsaWQgcGF5bG9hZCB0eXBlIC0gcGF5bG9hZHMgY2FuIGJlICdiaW5hcnknLCAnc3RyaW5nJywgb3IgJ2pzb24nXCIpO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzLnNldChFcnJvckNvZGUuQmFkSnNvbiwgXCJCYWQgSlNPTlwiKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlcy5zZXQoRXJyb3JDb2RlLldzc1JlcXVpcmVkLCBcIlRMUyBpcyByZXF1aXJlZCwgdGhlcmVmb3JlIGEgc2VjdXJlIHdlYnNvY2tldCBjb25uZWN0aW9uIGlzIGFsc28gcmVxdWlyZWRcIik7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRNZXNzYWdlKHMpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VzLmdldE1lc3NhZ2Uocyk7XG4gICAgfVxuICAgIGdldE1lc3NhZ2Uocykge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlcy5nZXQocykgfHwgcztcbiAgICB9XG59XG5jb25zdCBtZXNzYWdlcyA9IG5ldyBNZXNzYWdlcygpO1xuZnVuY3Rpb24gaXNOYXRzRXJyb3IoZXJyKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlcnIuY29kZSA9PT0gXCJzdHJpbmdcIjtcbn1cbmNsYXNzIE5hdHNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBuYW1lO1xuICAgIG1lc3NhZ2U7XG4gICAgY29kZTtcbiAgICBwZXJtaXNzaW9uQ29udGV4dDtcbiAgICBjaGFpbmVkRXJyb3I7XG4gICAgYXBpX2Vycm9yO1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvZGUsIGNoYWluZWRFcnJvcil7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIk5hdHNFcnJvclwiO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLmNoYWluZWRFcnJvciA9IGNoYWluZWRFcnJvcjtcbiAgICB9XG4gICAgc3RhdGljIGVycm9yRm9yQ29kZShjb2RlLCBjaGFpbmVkRXJyb3IpIHtcbiAgICAgICAgY29uc3QgbSA9IE1lc3NhZ2VzLmdldE1lc3NhZ2UoY29kZSk7XG4gICAgICAgIHJldHVybiBuZXcgTmF0c0Vycm9yKG0sIGNvZGUsIGNoYWluZWRFcnJvcik7XG4gICAgfVxuICAgIGlzQXV0aEVycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2RlID09PSBFcnJvckNvZGUuQXV0aGVudGljYXRpb25FeHBpcmVkIHx8IHRoaXMuY29kZSA9PT0gRXJyb3JDb2RlLkF1dGhvcml6YXRpb25WaW9sYXRpb247XG4gICAgfVxuICAgIGlzUGVybWlzc2lvbkVycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2RlID09PSBFcnJvckNvZGUuUGVybWlzc2lvbnNWaW9sYXRpb247XG4gICAgfVxuICAgIGlzUHJvdG9jb2xFcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZSA9PT0gRXJyb3JDb2RlLlByb3RvY29sRXJyb3I7XG4gICAgfVxuICAgIGlzSmV0U3RyZWFtRXJyb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwaV9lcnJvciAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBqc0Vycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcGlfZXJyb3IgPyB0aGlzLmFwaV9lcnJvciA6IG51bGw7XG4gICAgfVxufVxuY29uc3QgVEUgPSBuZXcgVGV4dEVuY29kZXIoKTtcbmNvbnN0IFREID0gbmV3IFRleHREZWNvZGVyKCk7XG5mdW5jdGlvbiBjb25jYXQoLi4uYnVmcykge1xuICAgIGxldCBtYXggPSAwO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBidWZzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgbWF4ICs9IGJ1ZnNbaV0ubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheShtYXgpO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgZm9yKGxldCBpMSA9IDA7IGkxIDwgYnVmcy5sZW5ndGg7IGkxKyspe1xuICAgICAgICBvdXQuc2V0KGJ1ZnNbaTFdLCBpbmRleCk7XG4gICAgICAgIGluZGV4ICs9IGJ1ZnNbaTFdLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIGVuY29kZSguLi5hKSB7XG4gICAgY29uc3QgYnVmcyA9IFtdO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgYnVmcy5wdXNoKFRFLmVuY29kZShhW2ldKSk7XG4gICAgfVxuICAgIGlmIChidWZzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gRW1wdHk7XG4gICAgfVxuICAgIGlmIChidWZzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gYnVmc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmNhdCguLi5idWZzKTtcbn1cbmZ1bmN0aW9uIGRlY29kZShhKSB7XG4gICAgaWYgKCFhIHx8IGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gVEQuZGVjb2RlKGEpO1xufVxuZnVuY3Rpb24gU3RyaW5nQ29kZWMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gVEUuZW5jb2RlKGQpO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUgKGEpIHtcbiAgICAgICAgICAgIHJldHVybiBURC5kZWNvZGUoYSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gSlNPTkNvZGVjKHJldml2ZXIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUgKGQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRFLmVuY29kZShKU09OLnN0cmluZ2lmeShkKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBOYXRzRXJyb3IuZXJyb3JGb3JDb2RlKEVycm9yQ29kZS5CYWRKc29uLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUgKGEpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoVEQuZGVjb2RlKGEpLCByZXZpdmVyKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRocm93IE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLkJhZEpzb24sIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBkaWdpdHMgPSBcIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlwiO1xuY29uc3QgYmFzZSA9IDM2O1xuY29uc3QgbWF4U2VxID0gMzY1NjE1ODQ0MDA2Mjk3NjtcbmNvbnN0IG1pbkluYyA9IDMzO1xuY29uc3QgbWF4SW5jID0gMzMzO1xuY29uc3QgdG90YWxMZW4gPSAxMiArIDEwO1xuZnVuY3Rpb24gX2dldFJhbmRvbVZhbHVlcyhhKSB7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspe1xuICAgICAgICBhW2ldID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU1KTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaWxsUmFuZG9tKGEpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcz8uY3J5cHRvPy5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgICAgZ2xvYmFsVGhpcy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF9nZXRSYW5kb21WYWx1ZXMoYSk7XG4gICAgfVxufVxuY2xhc3MgTnVpZCB7XG4gICAgYnVmO1xuICAgIHNlcTtcbiAgICBpbmM7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5idWYgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbik7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICB0aGlzLnNldFByZSgpO1xuICAgICAgICB0aGlzLmluaXRTZXFBbmRJbmMoKTtcbiAgICAgICAgdGhpcy5maWxsU2VxKCk7XG4gICAgfVxuICAgIGluaXRTZXFBbmRJbmMoKSB7XG4gICAgICAgIHRoaXMuc2VxID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbWF4U2VxKTtcbiAgICAgICAgdGhpcy5pbmMgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4SW5jIC0gbWluSW5jKSArIG1pbkluYyk7XG4gICAgfVxuICAgIHNldFByZSgpIHtcbiAgICAgICAgY29uc3QgY2J1ZiA9IG5ldyBVaW50OEFycmF5KDEyKTtcbiAgICAgICAgZmlsbFJhbmRvbShjYnVmKTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IDEyOyBpKyspe1xuICAgICAgICAgICAgY29uc3QgZGkgPSBjYnVmW2ldICUgMzY7XG4gICAgICAgICAgICB0aGlzLmJ1ZltpXSA9IGRpZ2l0cy5jaGFyQ29kZUF0KGRpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaWxsU2VxKCkge1xuICAgICAgICBsZXQgbiA9IHRoaXMuc2VxO1xuICAgICAgICBmb3IobGV0IGkgPSB0b3RhbExlbiAtIDE7IGkgPj0gMTI7IGktLSl7XG4gICAgICAgICAgICB0aGlzLmJ1ZltpXSA9IGRpZ2l0cy5jaGFyQ29kZUF0KG4gJSBiYXNlKTtcbiAgICAgICAgICAgIG4gPSBNYXRoLmZsb29yKG4gLyBiYXNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICB0aGlzLnNlcSArPSB0aGlzLmluYztcbiAgICAgICAgaWYgKHRoaXMuc2VxID4gMzY1NjE1ODQ0MDA2Mjk3Nikge1xuICAgICAgICAgICAgdGhpcy5zZXRQcmUoKTtcbiAgICAgICAgICAgIHRoaXMuaW5pdFNlcUFuZEluYygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlsbFNlcSgpO1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIHRoaXMuYnVmKTtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cbn1cbmNvbnN0IG51aWQgPSBuZXcgTnVpZCgpO1xuY2xhc3MgRGF0YUJ1ZmZlciB7XG4gICAgYnVmZmVycztcbiAgICBieXRlTGVuZ3RoO1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuYnVmZmVycyA9IFtdO1xuICAgICAgICB0aGlzLmJ5dGVMZW5ndGggPSAwO1xuICAgIH1cbiAgICBzdGF0aWMgY29uY2F0KC4uLmJ1ZnMpIHtcbiAgICAgICAgbGV0IG1heCA9IDA7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBidWZzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIG1heCArPSBidWZzW2ldLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheShtYXgpO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBmb3IobGV0IGkxID0gMDsgaTEgPCBidWZzLmxlbmd0aDsgaTErKyl7XG4gICAgICAgICAgICBvdXQuc2V0KGJ1ZnNbaTFdLCBpbmRleCk7XG4gICAgICAgICAgICBpbmRleCArPSBidWZzW2kxXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Bc2NpaShtKSB7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgbSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFRFLmVuY29kZShtKTtcbiAgICB9XG4gICAgc3RhdGljIHRvQXNjaWkoYSkge1xuICAgICAgICByZXR1cm4gVEQuZGVjb2RlKGEpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5idWZmZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuYnl0ZUxlbmd0aCA9IDA7XG4gICAgfVxuICAgIHBhY2soKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlcnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY29uc3QgdiA9IG5ldyBVaW50OEFycmF5KHRoaXMuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuYnVmZmVycy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgdi5zZXQodGhpcy5idWZmZXJzW2ldLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gdGhpcy5idWZmZXJzW2ldLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnVmZmVycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJzLnB1c2godik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2hpZnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBhID0gdGhpcy5idWZmZXJzLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoYSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnl0ZUxlbmd0aCAtPSBhLmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgfVxuICAgIGRyYWluKG4pIHtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucGFjaygpO1xuICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuYnVmZmVycy5wb3AoKTtcbiAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChuID09PSB1bmRlZmluZWQgfHwgbiA+IG1heCkge1xuICAgICAgICAgICAgICAgICAgICBuID0gbWF4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBkID0gdi5zdWJhcnJheSgwLCBuKTtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID4gbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcnMucHVzaCh2LnN1YmFycmF5KG4pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gbWF4IC0gbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgfVxuICAgIGZpbGwoYSwgLi4uYnVmcykge1xuICAgICAgICBpZiAoYSkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXJzLnB1c2goYSk7XG4gICAgICAgICAgICB0aGlzLmJ5dGVMZW5ndGggKz0gYS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGJ1ZnMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgaWYgKGJ1ZnNbaV0gJiYgYnVmc1tpXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcnMucHVzaChidWZzW2ldKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ5dGVMZW5ndGggKz0gYnVmc1tpXS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGVlaygpIHtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucGFjaygpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyc1swXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgfVxuICAgIHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVycy5sZW5ndGg7XG4gICAgfVxufVxuY29uc3QgQ1JfTEYgPSBcIlxcclxcblwiO1xuQ1JfTEYubGVuZ3RoO1xuY29uc3QgQ1JMRiA9IERhdGFCdWZmZXIuZnJvbUFzY2lpKENSX0xGKTtcbmNvbnN0IENSID0gbmV3IFVpbnQ4QXJyYXkoQ1JMRilbMF07XG5jb25zdCBMRiA9IG5ldyBVaW50OEFycmF5KENSTEYpWzFdO1xuZnVuY3Rpb24gaXNVaW50OEFycmF5KGEpIHtcbiAgICByZXR1cm4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG59XG5mdW5jdGlvbiBwcm90b0xlbihiYSkge1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBiYS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGNvbnN0IG4gPSBpICsgMTtcbiAgICAgICAgaWYgKGJhLmJ5dGVMZW5ndGggPiBuICYmIGJhW2ldID09PSBDUiAmJiBiYVtuXSA9PT0gTEYpIHtcbiAgICAgICAgICAgIHJldHVybiBuICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RQcm90b2NvbE1lc3NhZ2UoYSkge1xuICAgIGNvbnN0IGxlbiA9IHByb3RvTGVuKGEpO1xuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIGNvbnN0IGJhID0gbmV3IFVpbnQ4QXJyYXkoYSk7XG4gICAgICAgIGNvbnN0IG91dCA9IGJhLnNsaWNlKDAsIGxlbik7XG4gICAgICAgIHJldHVybiBURC5kZWNvZGUob3V0KTtcbiAgICB9XG4gICAgcmV0dXJuIFwiXCI7XG59XG5mdW5jdGlvbiBleHRlbmQoYSwgLi4uYikge1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgY29uc3QgbyA9IGJbaV07XG4gICAgICAgIE9iamVjdC5rZXlzKG8pLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgICAgICAgYVtrXSA9IG9ba107XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn1cbmZ1bmN0aW9uIHJlbmRlcihmcmFtZSkge1xuICAgIGNvbnN0IGNyID0gXCLikI1cIjtcbiAgICBjb25zdCBsZiA9IFwi4pCKXCI7XG4gICAgcmV0dXJuIFRELmRlY29kZShmcmFtZSkucmVwbGFjZSgvXFxuL2csIGxmKS5yZXBsYWNlKC9cXHIvZywgY3IpO1xufVxuZnVuY3Rpb24gdGltZW91dChtcykge1xuICAgIGNvbnN0IGVyciA9IE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLlRpbWVvdXQpO1xuICAgIGxldCBtZXRob2RzO1xuICAgIGxldCB0aW1lcjtcbiAgICBjb25zdCBwID0gbmV3IFByb21pc2UoKF9yZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgIGNvbnN0IGNhbmNlbCA9ICgpPT57XG4gICAgICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBtZXRob2RzID0ge1xuICAgICAgICAgICAgY2FuY2VsXG4gICAgICAgIH07XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0sIG1zKTtcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihwLCBtZXRob2RzKTtcbn1cbmZ1bmN0aW9uIGRlbGF5KG1zID0gMCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSk9PntcbiAgICAgICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9LCBtcyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBkZWZlcnJlZCgpIHtcbiAgICBsZXQgbWV0aG9kcyA9IHt9O1xuICAgIGNvbnN0IHAgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KT0+e1xuICAgICAgICBtZXRob2RzID0ge1xuICAgICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICAgIHJlamVjdFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHAsIG1ldGhvZHMpO1xufVxuZnVuY3Rpb24gc2h1ZmZsZShhKSB7XG4gICAgZm9yKGxldCBpID0gYS5sZW5ndGggLSAxOyBpID4gMDsgaS0tKXtcbiAgICAgICAgY29uc3QgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpO1xuICAgICAgICBbYVtpXSwgYVtqXV0gPSBbXG4gICAgICAgICAgICBhW2pdLFxuICAgICAgICAgICAgYVtpXVxuICAgICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn1cbmNsYXNzIFBlcmYge1xuICAgIHRpbWVycztcbiAgICBtZWFzdXJlcztcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLnRpbWVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5tZWFzdXJlcyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgbWFyayhrZXkpIHtcbiAgICAgICAgdGhpcy50aW1lcnMuc2V0KGtleSwgRGF0ZS5ub3coKSk7XG4gICAgfVxuICAgIG1lYXN1cmUoa2V5LCBzdGFydEtleSwgZW5kS2V5KSB7XG4gICAgICAgIGNvbnN0IHMgPSB0aGlzLnRpbWVycy5nZXQoc3RhcnRLZXkpO1xuICAgICAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7c3RhcnRLZXl9IGlzIG5vdCBkZWZpbmVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZSA9IHRoaXMudGltZXJzLmdldChlbmRLZXkpO1xuICAgICAgICBpZiAoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZW5kS2V5fSBpcyBub3QgZGVmaW5lZGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVhc3VyZXMuc2V0KGtleSwgZSAtIHMpO1xuICAgIH1cbiAgICBnZXRFbnRyaWVzKCkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5tZWFzdXJlcy5mb3JFYWNoKCh2LCBrKT0+e1xuICAgICAgICAgICAgdmFsdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IGssXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IHZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG59XG5mdW5jdGlvbiBjYW5vbmljYWxNSU1FSGVhZGVyS2V5KGspIHtcbiAgICBjb25zdCBkYXNoID0gNDU7XG4gICAgY29uc3QgdG9Mb3dlciA9IDk3IC0gNjU7XG4gICAgbGV0IHVwcGVyID0gdHJ1ZTtcbiAgICBjb25zdCBidWYgPSBuZXcgQXJyYXkoay5sZW5ndGgpO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgbGV0IGMgPSBrLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjID09PSA1OCB8fCBjIDwgMzMgfHwgYyA+IDEyNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5hdHNFcnJvcihgJyR7a1tpXX0nIGlzIG5vdCBhIHZhbGlkIGNoYXJhY3RlciBmb3IgYSBoZWFkZXIga2V5YCwgRXJyb3JDb2RlLkJhZEhlYWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwcGVyICYmIDk3IDw9IGMgJiYgYyA8PSAxMjIpIHtcbiAgICAgICAgICAgIGMgLT0gdG9Mb3dlcjtcbiAgICAgICAgfSBlbHNlIGlmICghdXBwZXIgJiYgNjUgPD0gYyAmJiBjIDw9IDkwKSB7XG4gICAgICAgICAgICBjICs9IHRvTG93ZXI7XG4gICAgICAgIH1cbiAgICAgICAgYnVmW2ldID0gYztcbiAgICAgICAgdXBwZXIgPSBjID09IGRhc2g7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLmJ1Zik7XG59XG5mdW5jdGlvbiBoZWFkZXJzKCkge1xuICAgIHJldHVybiBuZXcgTXNnSGRyc0ltcGwoKTtcbn1cbmNvbnN0IEhFQURFUiA9IFwiTkFUUy8xLjBcIjtcbnZhciBNYXRjaDtcbihmdW5jdGlvbihNYXRjaCkge1xuICAgIE1hdGNoW01hdGNoW1wiRXhhY3RcIl0gPSAwXSA9IFwiRXhhY3RcIjtcbiAgICBNYXRjaFtNYXRjaFtcIkNhbm9uaWNhbE1JTUVcIl0gPSAxXSA9IFwiQ2Fub25pY2FsTUlNRVwiO1xuICAgIE1hdGNoW01hdGNoW1wiSWdub3JlQ2FzZVwiXSA9IDJdID0gXCJJZ25vcmVDYXNlXCI7XG59KShNYXRjaCB8fCAoTWF0Y2ggPSB7fSkpO1xuY2xhc3MgTXNnSGRyc0ltcGwge1xuICAgIGNvZGU7XG4gICAgaGVhZGVycztcbiAgICBkZXNjcmlwdGlvbjtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLmNvZGUgPSAwO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBcIlwiO1xuICAgIH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVycy5lbnRyaWVzKCk7XG4gICAgfVxuICAgIHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYWRlcnMuc2l6ZTtcbiAgICB9XG4gICAgZXF1YWxzKG1oKSB7XG4gICAgICAgIGlmIChtaCAmJiB0aGlzLmhlYWRlcnMuc2l6ZSA9PT0gbWguaGVhZGVycy5zaXplICYmIHRoaXMuY29kZSA9PT0gbWguY29kZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgdGhpcy5oZWFkZXJzKXtcbiAgICAgICAgICAgICAgICBjb25zdCBhID0gbWgudmFsdWVzKGspO1xuICAgICAgICAgICAgICAgIGlmICh2Lmxlbmd0aCAhPT0gYS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB2diA9IFtcbiAgICAgICAgICAgICAgICAgICAgLi4udlxuICAgICAgICAgICAgICAgIF0uc29ydCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFhID0gW1xuICAgICAgICAgICAgICAgICAgICAuLi5hXG4gICAgICAgICAgICAgICAgXS5zb3J0KCk7XG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHZ2Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZ2W2ldICE9PSBhYVtpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzdGF0aWMgZGVjb2RlKGEpIHtcbiAgICAgICAgY29uc3QgbWggPSBuZXcgTXNnSGRyc0ltcGwoKTtcbiAgICAgICAgY29uc3QgcyA9IFRELmRlY29kZShhKTtcbiAgICAgICAgY29uc3QgbGluZXMgPSBzLnNwbGl0KFwiXFxyXFxuXCIpO1xuICAgICAgICBjb25zdCBoID0gbGluZXNbMF07XG4gICAgICAgIGlmIChoICE9PSBIRUFERVIpIHtcbiAgICAgICAgICAgIGxldCBzdHIgPSBoLnJlcGxhY2UoSEVBREVSLCBcIlwiKTtcbiAgICAgICAgICAgIG1oLmNvZGUgPSBwYXJzZUludChzdHIsIDEwKTtcbiAgICAgICAgICAgIGNvbnN0IHNjb2RlID0gbWguY29kZS50b1N0cmluZygpO1xuICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2Uoc2NvZGUsIFwiXCIpO1xuICAgICAgICAgICAgbWguZGVzY3JpcHRpb24gPSBzdHIudHJpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggPj0gMSkge1xuICAgICAgICAgICAgbGluZXMuc2xpY2UoMSkubWFwKChzKT0+e1xuICAgICAgICAgICAgICAgIGlmIChzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkeCA9IHMuaW5kZXhPZihcIjpcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgayA9IHMuc2xpY2UoMCwgaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBzLnNsaWNlKGlkeCArIDEpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1oLmFwcGVuZChrLCB2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLmhlYWRlcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHMgPSBIRUFERVI7XG4gICAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIHRoaXMuaGVhZGVycyl7XG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdi5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgcyA9IGAke3N9XFxyXFxuJHtrfTogJHt2W2ldfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3N9XFxyXFxuXFxyXFxuYDtcbiAgICB9XG4gICAgZW5jb2RlKCkge1xuICAgICAgICByZXR1cm4gVEUuZW5jb2RlKHRoaXMudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIHN0YXRpYyB2YWxpZEhlYWRlclZhbHVlKGspIHtcbiAgICAgICAgY29uc3QgaW52ID0gL1tcXHJcXG5dLztcbiAgICAgICAgaWYgKGludi50ZXN0KGspKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTmF0c0Vycm9yKFwiaW52YWxpZCBoZWFkZXIgdmFsdWUgLSBcXFxcciBhbmQgXFxcXG4gYXJlIG5vdCBhbGxvd2VkLlwiLCBFcnJvckNvZGUuQmFkSGVhZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gay50cmltKCk7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBzayBvZiB0aGlzLmhlYWRlcnMua2V5cygpKXtcbiAgICAgICAgICAgIGtleXMucHVzaChzayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfVxuICAgIGZpbmRLZXlzKGssIG1hdGNoID0gTWF0Y2guRXhhY3QpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IHRoaXMua2V5cygpO1xuICAgICAgICBzd2l0Y2gobWF0Y2gpe1xuICAgICAgICAgICAgY2FzZSBNYXRjaC5FeGFjdDpcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5maWx0ZXIoKHYpPT57XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2ID09PSBrO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSBNYXRjaC5DYW5vbmljYWxNSU1FOlxuICAgICAgICAgICAgICAgIGsgPSBjYW5vbmljYWxNSU1FSGVhZGVyS2V5KGspO1xuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzLmZpbHRlcigodik9PntcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHYgPT09IGs7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGNpID0gay50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5maWx0ZXIoKHYpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGNpID09PSB2LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQoaywgbWF0Y2ggPSBNYXRjaC5FeGFjdCkge1xuICAgICAgICBjb25zdCBrZXlzID0gdGhpcy5maW5kS2V5cyhrLCBtYXRjaCk7XG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuaGVhZGVycy5nZXQoa2V5c1swXSk7XG4gICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHYpID8gdlswXSA6IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGhhcyhrLCBtYXRjaCA9IE1hdGNoLkV4YWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRLZXlzKGssIG1hdGNoKS5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBzZXQoaywgdiwgbWF0Y2ggPSBNYXRjaC5FeGFjdCkge1xuICAgICAgICB0aGlzLmRlbGV0ZShrLCBtYXRjaCk7XG4gICAgICAgIHRoaXMuYXBwZW5kKGssIHYsIG1hdGNoKTtcbiAgICB9XG4gICAgYXBwZW5kKGssIHYsIG1hdGNoID0gTWF0Y2guRXhhY3QpIHtcbiAgICAgICAgY29uc3QgY2sgPSBjYW5vbmljYWxNSU1FSGVhZGVyS2V5KGspO1xuICAgICAgICBpZiAobWF0Y2ggPT09IE1hdGNoLkNhbm9uaWNhbE1JTUUpIHtcbiAgICAgICAgICAgIGsgPSBjaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlzID0gdGhpcy5maW5kS2V5cyhrLCBtYXRjaCk7XG4gICAgICAgIGsgPSBrZXlzLmxlbmd0aCA+IDAgPyBrZXlzWzBdIDogaztcbiAgICAgICAgY29uc3QgdmFsdWUgPSBNc2dIZHJzSW1wbC52YWxpZEhlYWRlclZhbHVlKHYpO1xuICAgICAgICBsZXQgYSA9IHRoaXMuaGVhZGVycy5nZXQoayk7XG4gICAgICAgIGlmICghYSkge1xuICAgICAgICAgICAgYSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzLnNldChrLCBhKTtcbiAgICAgICAgfVxuICAgICAgICBhLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICB2YWx1ZXMoaywgbWF0Y2ggPSBNYXRjaC5FeGFjdCkge1xuICAgICAgICBjb25zdCBidWYgPSBbXTtcbiAgICAgICAgY29uc3Qga2V5cyA9IHRoaXMuZmluZEtleXMoaywgbWF0Y2gpO1xuICAgICAgICBrZXlzLmZvckVhY2goKHYpPT57XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLmhlYWRlcnMuZ2V0KHYpO1xuICAgICAgICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAgICAgICAgIGJ1Zi5wdXNoKC4uLnZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgICBkZWxldGUoaywgbWF0Y2ggPSBNYXRjaC5FeGFjdCkge1xuICAgICAgICBjb25zdCBrZXlzID0gdGhpcy5maW5kS2V5cyhrLCBtYXRjaCk7XG4gICAgICAgIGtleXMuZm9yRWFjaCgodik9PntcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycy5kZWxldGUodik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgaGFzRXJyb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGUgPj0gMzAwO1xuICAgIH1cbiAgICBnZXQgc3RhdHVzKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5jb2RlfSAke3RoaXMuZGVzY3JpcHRpb259YC50cmltKCk7XG4gICAgfVxuICAgIHRvUmVjb3JkKCkge1xuICAgICAgICBjb25zdCBkYXRhID0ge307XG4gICAgICAgIHRoaXMua2V5cygpLmZvckVhY2goKHYpPT57XG4gICAgICAgICAgICBkYXRhW3ZdID0gdGhpcy52YWx1ZXModik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21SZWNvcmQocikge1xuICAgICAgICBjb25zdCBoID0gbmV3IE1zZ0hkcnNJbXBsKCk7XG4gICAgICAgIGZvcihjb25zdCBrIGluIHIpe1xuICAgICAgICAgICAgaC5oZWFkZXJzLnNldChrLCByW2tdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaDtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUR1cmFibGVOYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gdmFsaWRhdGVOYW1lKFwiZHVyYWJsZVwiLCBuYW1lKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlU3RyZWFtTmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlTmFtZShcInN0cmVhbVwiLCBuYW1lKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTmFtZShjb250ZXh0LCBuYW1lID0gXCJcIikge1xuICAgIGlmIChuYW1lID09PSBcIlwiKSB7XG4gICAgICAgIHRocm93IEVycm9yKGAke2NvbnRleHR9IG5hbWUgcmVxdWlyZWRgKTtcbiAgICB9XG4gICAgY29uc3QgYmFkID0gW1xuICAgICAgICBcIi5cIixcbiAgICAgICAgXCIqXCIsXG4gICAgICAgIFwiPlwiXG4gICAgXTtcbiAgICBiYWQuZm9yRWFjaCgodik9PntcbiAgICAgICAgaWYgKG5hbWUuaW5kZXhPZih2KSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBpbnZhbGlkICR7Y29udGV4dH0gbmFtZSAtICR7Y29udGV4dH0gbmFtZSBjYW5ub3QgY29udGFpbiAnJHt2fSdgKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gZGVmYXVsdENvbnN1bWVyKG5hbWUsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgZGVsaXZlcl9wb2xpY3k6IERlbGl2ZXJQb2xpY3kuQWxsLFxuICAgICAgICBhY2tfcG9saWN5OiBBY2tQb2xpY3kuRXhwbGljaXQsXG4gICAgICAgIGFja193YWl0OiBuYW5vcygzMCAqIDEwMDApLFxuICAgICAgICByZXBsYXlfcG9saWN5OiBSZXBsYXlQb2xpY3kuSW5zdGFudFxuICAgIH0sIG9wdHMpO1xufVxuZnVuY3Rpb24gbmFub3MobWlsbGlzKSB7XG4gICAgcmV0dXJuIG1pbGxpcyAqIDEwMDAwMDA7XG59XG5mdW5jdGlvbiBtaWxsaXMobnMpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihucyAvIDEwMDAwMDApO1xufVxuZnVuY3Rpb24gaXNGbG93Q29udHJvbE1zZyhtc2cpIHtcbiAgICBpZiAobXNnLmRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGggPSBtc2cuaGVhZGVycztcbiAgICBpZiAoIWgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaC5jb2RlID49IDEwMCAmJiBoLmNvZGUgPCAyMDA7XG59XG5mdW5jdGlvbiBpc0hlYXJ0YmVhdE1zZyhtc2cpIHtcbiAgICByZXR1cm4gaXNGbG93Q29udHJvbE1zZyhtc2cpICYmIG1zZy5oZWFkZXJzPy5kZXNjcmlwdGlvbiA9PT0gXCJJZGxlIEhlYXJ0YmVhdFwiO1xufVxuZnVuY3Rpb24gY2hlY2tKc0Vycm9yKG1zZykge1xuICAgIGlmIChtc2cuZGF0YS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGggPSBtc2cuaGVhZGVycztcbiAgICBpZiAoIWgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjaGVja0pzRXJyb3JDb2RlKGguY29kZSwgaC5kZXNjcmlwdGlvbik7XG59XG52YXIgSnM0MDlFcnJvcnM7XG4oZnVuY3Rpb24oSnM0MDlFcnJvcnMpIHtcbiAgICBKczQwOUVycm9yc1tcIk1heEJhdGNoRXhjZWVkZWRcIl0gPSBcImV4Y2VlZGVkIG1heHJlcXVlc3RiYXRjaCBvZlwiO1xuICAgIEpzNDA5RXJyb3JzW1wiTWF4RXhwaXJlc0V4Y2VlZGVkXCJdID0gXCJleGNlZWRlZCBtYXhyZXF1ZXN0ZXhwaXJlcyBvZlwiO1xuICAgIEpzNDA5RXJyb3JzW1wiTWF4Qnl0ZXNFeGNlZWRlZFwiXSA9IFwiZXhjZWVkZWQgbWF4cmVxdWVzdG1heGJ5dGVzIG9mXCI7XG4gICAgSnM0MDlFcnJvcnNbXCJNYXhNZXNzYWdlU2l6ZUV4Y2VlZGVkXCJdID0gXCJtZXNzYWdlIHNpemUgZXhjZWVkcyBtYXhieXRlc1wiO1xuICAgIEpzNDA5RXJyb3JzW1wiUHVzaENvbnN1bWVyXCJdID0gXCJjb25zdW1lciBpcyBwdXNoIGJhc2VkXCI7XG4gICAgSnM0MDlFcnJvcnNbXCJNYXhXYWl0aW5nRXhjZWVkZWRcIl0gPSBcImV4Y2VlZGVkIG1heHdhaXRpbmdcIjtcbn0pKEpzNDA5RXJyb3JzIHx8IChKczQwOUVycm9ycyA9IHt9KSk7XG5sZXQgTUFYX1dBSVRJTkdfRkFJTCA9IGZhbHNlO1xuZnVuY3Rpb24gaXNUZXJtaW5hbDQwOShlcnIpIHtcbiAgICBpZiAoZXJyLmNvZGUgIT09IEVycm9yQ29kZS5KZXRTdHJlYW00MDkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBmYXRhbCA9IFtcbiAgICAgICAgSnM0MDlFcnJvcnMuTWF4QmF0Y2hFeGNlZWRlZCxcbiAgICAgICAgSnM0MDlFcnJvcnMuTWF4RXhwaXJlc0V4Y2VlZGVkLFxuICAgICAgICBKczQwOUVycm9ycy5NYXhCeXRlc0V4Y2VlZGVkLFxuICAgICAgICBKczQwOUVycm9ycy5NYXhNZXNzYWdlU2l6ZUV4Y2VlZGVkLFxuICAgICAgICBKczQwOUVycm9ycy5QdXNoQ29uc3VtZXIsIFxuICAgIF07XG4gICAgaWYgKE1BWF9XQUlUSU5HX0ZBSUwpIHtcbiAgICAgICAgZmF0YWwucHVzaChKczQwOUVycm9ycy5NYXhXYWl0aW5nRXhjZWVkZWQpO1xuICAgIH1cbiAgICByZXR1cm4gZmF0YWwuZmluZCgocyk9PntcbiAgICAgICAgcmV0dXJuIGVyci5tZXNzYWdlLmluZGV4T2YocykgIT09IC0xO1xuICAgIH0pICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBjaGVja0pzRXJyb3JDb2RlKGNvZGUsIGRlc2NyaXB0aW9uID0gXCJcIikge1xuICAgIGlmIChjb2RlIDwgMzAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBkZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uLnRvTG93ZXJDYXNlKCk7XG4gICAgc3dpdGNoKGNvZGUpe1xuICAgICAgICBjYXNlIDQwNDpcbiAgICAgICAgICAgIHJldHVybiBuZXcgTmF0c0Vycm9yKGRlc2NyaXB0aW9uLCBFcnJvckNvZGUuSmV0U3RyZWFtNDA0Tm9NZXNzYWdlcyk7XG4gICAgICAgIGNhc2UgNDA4OlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOYXRzRXJyb3IoZGVzY3JpcHRpb24sIEVycm9yQ29kZS5KZXRTdHJlYW00MDhSZXF1ZXN0VGltZW91dCk7XG4gICAgICAgIGNhc2UgNDA5OlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOYXRzRXJyb3IoZGVzY3JpcHRpb24sIEVycm9yQ29kZS5KZXRTdHJlYW00MDkpO1xuICAgICAgICBjYXNlIDUwMzpcbiAgICAgICAgICAgIHJldHVybiBOYXRzRXJyb3IuZXJyb3JGb3JDb2RlKEVycm9yQ29kZS5KZXRTdHJlYW1Ob3RFbmFibGVkLCBuZXcgRXJyb3IoZGVzY3JpcHRpb24pKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdGlvbiA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gRXJyb3JDb2RlLlVua25vd247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5hdHNFcnJvcihkZXNjcmlwdGlvbiwgYCR7Y29kZX1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb25zdW1lck9wdHMob3B0cykge1xuICAgIHJldHVybiBuZXcgQ29uc3VtZXJPcHRzQnVpbGRlckltcGwob3B0cyk7XG59XG5jbGFzcyBDb25zdW1lck9wdHNCdWlsZGVySW1wbCB7XG4gICAgY29uZmlnO1xuICAgIG9yZGVyZWQ7XG4gICAgbWFjaztcbiAgICBzdHJlYW07XG4gICAgY2FsbGJhY2tGbjtcbiAgICBtYXg7XG4gICAgcW5hbWU7XG4gICAgaXNCaW5kO1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpe1xuICAgICAgICB0aGlzLnN0cmVhbSA9IFwiXCI7XG4gICAgICAgIHRoaXMubWFjayA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9yZGVyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBkZWZhdWx0Q29uc3VtZXIoXCJcIiwgb3B0cyB8fCB7fSk7XG4gICAgfVxuICAgIGdldE9wdHMoKSB7XG4gICAgICAgIGNvbnN0IG8gPSB7fTtcbiAgICAgICAgby5jb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgICAgby5tYWNrID0gdGhpcy5tYWNrO1xuICAgICAgICBvLnN0cmVhbSA9IHRoaXMuc3RyZWFtO1xuICAgICAgICBvLmNhbGxiYWNrRm4gPSB0aGlzLmNhbGxiYWNrRm47XG4gICAgICAgIG8ubWF4ID0gdGhpcy5tYXg7XG4gICAgICAgIG8ucXVldWUgPSB0aGlzLnFuYW1lO1xuICAgICAgICBvLm9yZGVyZWQgPSB0aGlzLm9yZGVyZWQ7XG4gICAgICAgIG8uY29uZmlnLmFja19wb2xpY3kgPSBvLm9yZGVyZWQgPyBBY2tQb2xpY3kuTm9uZSA6IG8uY29uZmlnLmFja19wb2xpY3k7XG4gICAgICAgIG8uaXNCaW5kID0gby5pc0JpbmQgfHwgZmFsc2U7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH1cbiAgICBkZXNjcmlwdGlvbihkZXNjcmlwdGlvbikge1xuICAgICAgICB0aGlzLmNvbmZpZy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVsaXZlclRvKHN1YmplY3QpIHtcbiAgICAgICAgdGhpcy5jb25maWcuZGVsaXZlcl9zdWJqZWN0ID0gc3ViamVjdDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGR1cmFibGUobmFtZSkge1xuICAgICAgICB2YWxpZGF0ZUR1cmFibGVOYW1lKG5hbWUpO1xuICAgICAgICB0aGlzLmNvbmZpZy5kdXJhYmxlX25hbWUgPSBuYW1lO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3RhcnRTZXF1ZW5jZShzZXEpIHtcbiAgICAgICAgaWYgKHNlcSA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzZXF1ZW5jZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29uZmlnLmRlbGl2ZXJfcG9saWN5ID0gRGVsaXZlclBvbGljeS5TdGFydFNlcXVlbmNlO1xuICAgICAgICB0aGlzLmNvbmZpZy5vcHRfc3RhcnRfc2VxID0gc2VxO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3RhcnRUaW1lKHRpbWUpIHtcbiAgICAgICAgdGhpcy5jb25maWcuZGVsaXZlcl9wb2xpY3kgPSBEZWxpdmVyUG9saWN5LlN0YXJ0VGltZTtcbiAgICAgICAgdGhpcy5jb25maWcub3B0X3N0YXJ0X3RpbWUgPSB0aW1lLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZWxpdmVyQWxsKCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5kZWxpdmVyX3BvbGljeSA9IERlbGl2ZXJQb2xpY3kuQWxsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVsaXZlckxhc3RQZXJTdWJqZWN0KCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5kZWxpdmVyX3BvbGljeSA9IERlbGl2ZXJQb2xpY3kuTGFzdFBlclN1YmplY3Q7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZWxpdmVyTGFzdCgpIHtcbiAgICAgICAgdGhpcy5jb25maWcuZGVsaXZlcl9wb2xpY3kgPSBEZWxpdmVyUG9saWN5Lkxhc3Q7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZWxpdmVyTmV3KCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5kZWxpdmVyX3BvbGljeSA9IERlbGl2ZXJQb2xpY3kuTmV3O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3RhcnRBdFRpbWVEZWx0YShtaWxsaXMpIHtcbiAgICAgICAgdGhpcy5zdGFydFRpbWUobmV3IERhdGUoRGF0ZS5ub3coKSAtIG1pbGxpcykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaGVhZGVyc09ubHkoKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmhlYWRlcnNfb25seSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhY2tOb25lKCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5hY2tfcG9saWN5ID0gQWNrUG9saWN5Lk5vbmU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhY2tBbGwoKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmFja19wb2xpY3kgPSBBY2tQb2xpY3kuQWxsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWNrRXhwbGljaXQoKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmFja19wb2xpY3kgPSBBY2tQb2xpY3kuRXhwbGljaXQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhY2tXYWl0KG1pbGxpcykge1xuICAgICAgICB0aGlzLmNvbmZpZy5hY2tfd2FpdCA9IG5hbm9zKG1pbGxpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBtYXhEZWxpdmVyKG1heCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5tYXhfZGVsaXZlciA9IG1heDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZpbHRlclN1YmplY3Qocykge1xuICAgICAgICB0aGlzLmNvbmZpZy5maWx0ZXJfc3ViamVjdCA9IHM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXBsYXlJbnN0YW50bHkoKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLnJlcGxheV9wb2xpY3kgPSBSZXBsYXlQb2xpY3kuSW5zdGFudDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlcGxheU9yaWdpbmFsKCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5yZXBsYXlfcG9saWN5ID0gUmVwbGF5UG9saWN5Lk9yaWdpbmFsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2FtcGxlKG4pIHtcbiAgICAgICAgbiA9IE1hdGgudHJ1bmMobik7XG4gICAgICAgIGlmIChuIDwgMCB8fCBuID4gMTAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHZhbHVlIG11c3QgYmUgYmV0d2VlbiAwLTEwMGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29uZmlnLnNhbXBsZV9mcmVxID0gYCR7bn0lYDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGxpbWl0KG4pIHtcbiAgICAgICAgdGhpcy5jb25maWcucmF0ZV9saW1pdF9icHMgPSBuO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbWF4V2FpdGluZyhtYXgpIHtcbiAgICAgICAgdGhpcy5jb25maWcubWF4X3dhaXRpbmcgPSBtYXg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBtYXhBY2tQZW5kaW5nKG1heCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5tYXhfYWNrX3BlbmRpbmcgPSBtYXg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZGxlSGVhcnRiZWF0KG1pbGxpcykge1xuICAgICAgICB0aGlzLmNvbmZpZy5pZGxlX2hlYXJ0YmVhdCA9IG5hbm9zKG1pbGxpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmbG93Q29udHJvbCgpIHtcbiAgICAgICAgdGhpcy5jb25maWcuZmxvd19jb250cm9sID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRlbGl2ZXJHcm91cChuYW1lKSB7XG4gICAgICAgIHRoaXMucXVldWUobmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBtYW51YWxBY2soKSB7XG4gICAgICAgIHRoaXMubWFjayA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBtYXhNZXNzYWdlcyhtYXgpIHtcbiAgICAgICAgdGhpcy5tYXggPSBtYXg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjYWxsYmFjayhmbikge1xuICAgICAgICB0aGlzLmNhbGxiYWNrRm4gPSBmbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHF1ZXVlKG4pIHtcbiAgICAgICAgdGhpcy5xbmFtZSA9IG47XG4gICAgICAgIHRoaXMuY29uZmlnLmRlbGl2ZXJfZ3JvdXAgPSBuO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb3JkZXJlZENvbnN1bWVyKCkge1xuICAgICAgICB0aGlzLm9yZGVyZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYmluZChzdHJlYW0sIGR1cmFibGUpIHtcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XG4gICAgICAgIHRoaXMuY29uZmlnLmR1cmFibGVfbmFtZSA9IGR1cmFibGU7XG4gICAgICAgIHRoaXMuaXNCaW5kID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGluYWN0aXZlRXBoZW1lcmFsVGhyZXNob2xkKG1pbGxpcykge1xuICAgICAgICB0aGlzLmNvbmZpZy5pbmFjdGl2ZV90aHJlc2hvbGQgPSBuYW5vcyhtaWxsaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbWF4UHVsbEJhdGNoKG4pIHtcbiAgICAgICAgdGhpcy5jb25maWcubWF4X2JhdGNoID0gbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG1heFB1bGxSZXF1ZXN0RXhwaXJlcyhtaWxsaXMpIHtcbiAgICAgICAgdGhpcy5jb25maWcubWF4X2V4cGlyZXMgPSBuYW5vcyhtaWxsaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbWVtb3J5KCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5tZW1fc3RvcmFnZSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBudW1SZXBsaWNhcyhuKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLm51bV9yZXBsaWNhcyA9IG47XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQ29uc3VtZXJPcHRzQnVpbGRlcihvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvLmdldE9wdHMgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmNsYXNzIFF1ZXVlZEl0ZXJhdG9ySW1wbCB7XG4gICAgaW5mbGlnaHQ7XG4gICAgcHJvY2Vzc2VkO1xuICAgIHJlY2VpdmVkO1xuICAgIG5vSXRlcmF0b3I7XG4gICAgaXRlckNsb3NlZDtcbiAgICBkb25lO1xuICAgIHNpZ25hbDtcbiAgICB5aWVsZHM7XG4gICAgZmlsdGVyZWQ7XG4gICAgcGVuZGluZ0ZpbHRlcmVkO1xuICAgIGluZ2VzdGlvbkZpbHRlckZuO1xuICAgIHByb3RvY29sRmlsdGVyRm47XG4gICAgZGlzcGF0Y2hlZEZuO1xuICAgIGN0eDtcbiAgICBfZGF0YTtcbiAgICBlcnI7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5pbmZsaWdodCA9IDA7XG4gICAgICAgIHRoaXMuZmlsdGVyZWQgPSAwO1xuICAgICAgICB0aGlzLnBlbmRpbmdGaWx0ZXJlZCA9IDA7XG4gICAgICAgIHRoaXMucHJvY2Vzc2VkID0gMDtcbiAgICAgICAgdGhpcy5yZWNlaXZlZCA9IDA7XG4gICAgICAgIHRoaXMubm9JdGVyYXRvciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaWduYWwgPSBkZWZlcnJlZCgpO1xuICAgICAgICB0aGlzLnlpZWxkcyA9IFtdO1xuICAgICAgICB0aGlzLml0ZXJDbG9zZWQgPSBkZWZlcnJlZCgpO1xuICAgIH1cbiAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRlKCk7XG4gICAgfVxuICAgIHB1c2godikge1xuICAgICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMueWllbGRzLnB1c2godik7XG4gICAgICAgICAgICB0aGlzLnNpZ25hbC5yZXNvbHZlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpbmdlc3QgLCBwcm90b2NvbCAgfSA9IHRoaXMuaW5nZXN0aW9uRmlsdGVyRm4gPyB0aGlzLmluZ2VzdGlvbkZpbHRlckZuKHYsIHRoaXMuY3R4IHx8IHRoaXMpIDoge1xuICAgICAgICAgICAgaW5nZXN0OiB0cnVlLFxuICAgICAgICAgICAgcHJvdG9jb2w6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGlmIChpbmdlc3QpIHtcbiAgICAgICAgICAgIGlmIChwcm90b2NvbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyZWQrKztcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdGaWx0ZXJlZCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy55aWVsZHMucHVzaCh2KTtcbiAgICAgICAgICAgIHRoaXMuc2lnbmFsLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyAqaXRlcmF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubm9JdGVyYXRvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5hdHNFcnJvcihcInVuc3VwcG9ydGVkIGl0ZXJhdG9yXCIsIEVycm9yQ29kZS5BcGlFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdoaWxlKHRydWUpe1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnlpZWxkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zaWduYWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVycikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeWllbGRzID0gdGhpcy55aWVsZHM7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmZsaWdodCA9IHlpZWxkcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdGhpcy55aWVsZHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgeWllbGRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB5aWVsZHNbaV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZm4gPSB5aWVsZHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvayA9IHRoaXMucHJvdG9jb2xGaWx0ZXJGbiA/IHRoaXMucHJvdG9jb2xGaWx0ZXJGbih5aWVsZHNbaV0pIDogdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NlZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlzcGF0Y2hlZEZuICYmIHlpZWxkc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hlZEZuKHlpZWxkc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdGaWx0ZXJlZC0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5mbGlnaHQtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMueWllbGRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZHMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55aWVsZHMgPSB5aWVsZHM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2lnbmFsID0gZGVmZXJyZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0b3AoZXJyKSB7XG4gICAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVyciA9IGVycjtcbiAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zaWduYWwucmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLml0ZXJDbG9zZWQucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBnZXRQcm9jZXNzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vSXRlcmF0b3IgPyB0aGlzLnJlY2VpdmVkIDogdGhpcy5wcm9jZXNzZWQ7XG4gICAgfVxuICAgIGdldFBlbmRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkcy5sZW5ndGggKyB0aGlzLmluZmxpZ2h0IC0gdGhpcy5wZW5kaW5nRmlsdGVyZWQ7XG4gICAgfVxuICAgIGdldFJlY2VpdmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWNlaXZlZCAtIHRoaXMuZmlsdGVyZWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0TGVuZ3RocyhiNjQpIHtcbiAgICBjb25zdCBsZW4gPSBiNjQubGVuZ3RoO1xuICAgIGxldCB2YWxpZExlbiA9IGI2NC5pbmRleE9mKFwiPVwiKTtcbiAgICBpZiAodmFsaWRMZW4gPT09IC0xKSB7XG4gICAgICAgIHZhbGlkTGVuID0gbGVuO1xuICAgIH1cbiAgICBjb25zdCBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuID8gMCA6IDQgLSB2YWxpZExlbiAlIDQ7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgdmFsaWRMZW4sXG4gICAgICAgIHBsYWNlSG9sZGVyc0xlblxuICAgIF07XG59XG5mdW5jdGlvbiBpbml0KGxvb2t1cCwgcmV2TG9va3VwLCB1cmxzYWZlID0gZmFsc2UpIHtcbiAgICBmdW5jdGlvbiBfYnl0ZUxlbmd0aCh2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCAtIHBsYWNlSG9sZGVyc0xlbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NChudW0pIHtcbiAgICAgICAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNmXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNmXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M2ZdICsgbG9va3VwW251bSAmIDB4M2ZdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmNvZGVDaHVuayhidWYsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gbmV3IEFycmF5KChlbmQgLSBzdGFydCkgLyAzKTtcbiAgICAgICAgZm9yKGxldCBpID0gc3RhcnQsIGN1clRyaXBsZXQgPSAwOyBpIDwgZW5kOyBpICs9IDMpe1xuICAgICAgICAgICAgb3V0W2N1clRyaXBsZXQrK10gPSB0cmlwbGV0VG9CYXNlNjQoKGJ1ZltpXSA8PCAxNikgKyAoYnVmW2kgKyAxXSA8PCA4KSArIGJ1ZltpICsgMl0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQuam9pbihcIlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYnl0ZUxlbmd0aCAoYjY0KSB7XG4gICAgICAgICAgICByZXR1cm4gX2J5dGVMZW5ndGguYXBwbHkobnVsbCwgZ2V0TGVuZ3RocyhiNjQpKTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9VaW50OEFycmF5IChiNjQpIHtcbiAgICAgICAgICAgIGNvbnN0IFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXSA9IGdldExlbmd0aHMoYjY0KTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KF9ieXRlTGVuZ3RoKHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA/IHZhbGlkTGVuIC0gNCA6IHZhbGlkTGVuO1xuICAgICAgICAgICAgbGV0IHRtcDtcbiAgICAgICAgICAgIGxldCBjdXJCeXRlID0gMDtcbiAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpe1xuICAgICAgICAgICAgICAgIHRtcCA9IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTggfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMiB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXTtcbiAgICAgICAgICAgICAgICBidWZbY3VyQnl0ZSsrXSA9IHRtcCA+PiAxNiAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgYnVmW2N1ckJ5dGUrK10gPSB0bXAgPj4gOCAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgYnVmW2N1ckJ5dGUrK10gPSB0bXAgJiAweGZmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgICAgICAgICAgICAgIHRtcCA9IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMiB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQ7XG4gICAgICAgICAgICAgICAgYnVmW2N1ckJ5dGUrK10gPSB0bXAgJiAweGZmO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0bXAgPSByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDI7XG4gICAgICAgICAgICAgICAgYnVmW2N1ckJ5dGUrK10gPSB0bXAgPj4gOCAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgYnVmW2N1ckJ5dGUrK10gPSB0bXAgJiAweGZmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICAgICAgfSxcbiAgICAgICAgZnJvbVVpbnQ4QXJyYXkgKGJ1Zikge1xuICAgICAgICAgICAgY29uc3QgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MztcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGJ1Zi5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBleHRyYUJ5dGVzID0gbGVuICUgMztcbiAgICAgICAgICAgIGNvbnN0IGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzO1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSBuZXcgQXJyYXkoTWF0aC5jZWlsKGxlbjIgLyAxNjM4MykgKyAoZXh0cmFCeXRlcyA/IDEgOiAwKSk7XG4gICAgICAgICAgICBsZXQgY3VyQ2h1bmsgPSAwO1xuICAgICAgICAgICAgbGV0IGNodW5rRW5kO1xuICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpe1xuICAgICAgICAgICAgICAgIGNodW5rRW5kID0gaSArIG1heENodW5rTGVuZ3RoO1xuICAgICAgICAgICAgICAgIHBhcnRzW2N1ckNodW5rKytdID0gZW5jb2RlQ2h1bmsoYnVmLCBpLCBjaHVua0VuZCA+IGxlbjIgPyBsZW4yIDogY2h1bmtFbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRtcDtcbiAgICAgICAgICAgIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdG1wID0gYnVmW2xlbjJdO1xuICAgICAgICAgICAgICAgIHBhcnRzW2N1ckNodW5rXSA9IGxvb2t1cFt0bXAgPj4gMl0gKyBsb29rdXBbdG1wIDw8IDQgJiAweDNmXTtcbiAgICAgICAgICAgICAgICBpZiAoIXVybHNhZmUpIHBhcnRzW2N1ckNodW5rXSArPSBcIj09XCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICAgICAgICAgICAgICB0bXAgPSBidWZbbGVuMl0gPDwgOCB8IGJ1ZltsZW4yICsgMV0gJiAweGZmO1xuICAgICAgICAgICAgICAgIHBhcnRzW2N1ckNodW5rXSA9IGxvb2t1cFt0bXAgPj4gMTBdICsgbG9va3VwW3RtcCA+PiA0ICYgMHgzZl0gKyBsb29rdXBbdG1wIDw8IDIgJiAweDNmXTtcbiAgICAgICAgICAgICAgICBpZiAoIXVybHNhZmUpIHBhcnRzW2N1ckNodW5rXSArPSBcIj1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJ0cy5qb2luKFwiXCIpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmNvbnN0IGxvb2t1cCA9IFtdO1xuY29uc3QgcmV2TG9va3VwID0gW107XG5jb25zdCBjb2RlID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fXCI7XG5mb3IobGV0IGkgPSAwLCBsID0gY29kZS5sZW5ndGg7IGkgPCBsOyArK2kpe1xuICAgIGxvb2t1cFtpXSA9IGNvZGVbaV07XG4gICAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpO1xufVxuY29uc3QgeyBieXRlTGVuZ3RoICwgdG9VaW50OEFycmF5ICwgZnJvbVVpbnQ4QXJyYXkgIH0gPSBpbml0KGxvb2t1cCwgcmV2TG9va3VwLCB0cnVlKTtcbmNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbmNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbmZ1bmN0aW9uIHRvSGV4U3RyaW5nKGJ1Zikge1xuICAgIHJldHVybiBidWYucmVkdWNlKChoZXgsIF9fYnl0ZSk9PmAke2hleH0ke19fYnl0ZSA8IDE2ID8gXCIwXCIgOiBcIlwifSR7X19ieXRlLnRvU3RyaW5nKDE2KX1gLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGZyb21IZXhTdHJpbmcoaGV4KSB7XG4gICAgY29uc3QgbGVuID0gaGV4Lmxlbmd0aDtcbiAgICBpZiAobGVuICUgMiB8fCAhL15bMC05YS1mQS1GXSskLy50ZXN0KGhleCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgaGV4IHN0cmluZy5cIik7XG4gICAgfVxuICAgIGhleCA9IGhleC50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KE1hdGguZmxvb3IobGVuIC8gMikpO1xuICAgIGNvbnN0IGVuZCA9IGxlbiAvIDI7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGVuZDsgKytpKXtcbiAgICAgICAgYnVmW2ldID0gcGFyc2VJbnQoaGV4LnN1YnN0cihpICogMiwgMiksIDE2KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1Zjtcbn1cbmZ1bmN0aW9uIGRlY29kZTEoYnVmLCBlbmNvZGluZyA9IFwidXRmOFwiKSB7XG4gICAgaWYgKC9edXRmLT84JC9pLnRlc3QoZW5jb2RpbmcpKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVyLmRlY29kZShidWYpO1xuICAgIH0gZWxzZSBpZiAoL15iYXNlNjQkL2kudGVzdChlbmNvZGluZykpIHtcbiAgICAgICAgcmV0dXJuIGZyb21VaW50OEFycmF5KGJ1Zik7XG4gICAgfSBlbHNlIGlmICgvXmhleCg/OmFkZWNpbWFsKT8kL2kudGVzdChlbmNvZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRvSGV4U3RyaW5nKGJ1Zik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuc3VwcG9ydGVkIHN0cmluZyBlbmNvZGluZy5cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gZW5jb2RlMShzdHIsIGVuY29kaW5nID0gXCJ1dGY4XCIpIHtcbiAgICBpZiAoL151dGYtPzgkL2kudGVzdChlbmNvZGluZykpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZXIuZW5jb2RlKHN0cik7XG4gICAgfSBlbHNlIGlmICgvXmJhc2U2NCQvaS50ZXN0KGVuY29kaW5nKSkge1xuICAgICAgICByZXR1cm4gdG9VaW50OEFycmF5KHN0cik7XG4gICAgfSBlbHNlIGlmICgvXmhleCg/OmFkZWNpbWFsKT8kL2kudGVzdChlbmNvZGluZykpIHtcbiAgICAgICAgcmV0dXJuIGZyb21IZXhTdHJpbmcoc3RyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5zdXBwb3J0ZWQgc3RyaW5nIGVuY29kaW5nLlwiKTtcbiAgICB9XG59XG5jbGFzcyBTSEEyNTYge1xuICAgIGhhc2hTaXplID0gMzI7XG4gICAgX2J1ZjtcbiAgICBfYnVmSWR4O1xuICAgIF9jb3VudDtcbiAgICBfSztcbiAgICBfSDtcbiAgICBfZmluYWxpemVkO1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuX2J1ZiA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgICAgICAgdGhpcy5fSyA9IG5ldyBVaW50MzJBcnJheShbXG4gICAgICAgICAgICAweDQyOGEyZjk4LFxuICAgICAgICAgICAgMHg3MTM3NDQ5MSxcbiAgICAgICAgICAgIDB4YjVjMGZiY2YsXG4gICAgICAgICAgICAweGU5YjVkYmE1LFxuICAgICAgICAgICAgMHgzOTU2YzI1YixcbiAgICAgICAgICAgIDB4NTlmMTExZjEsXG4gICAgICAgICAgICAweDkyM2Y4MmE0LFxuICAgICAgICAgICAgMHhhYjFjNWVkNSxcbiAgICAgICAgICAgIDB4ZDgwN2FhOTgsXG4gICAgICAgICAgICAweDEyODM1YjAxLFxuICAgICAgICAgICAgMHgyNDMxODViZSxcbiAgICAgICAgICAgIDB4NTUwYzdkYzMsXG4gICAgICAgICAgICAweDcyYmU1ZDc0LFxuICAgICAgICAgICAgMHg4MGRlYjFmZSxcbiAgICAgICAgICAgIDB4OWJkYzA2YTcsXG4gICAgICAgICAgICAweGMxOWJmMTc0LFxuICAgICAgICAgICAgMHhlNDliNjljMSxcbiAgICAgICAgICAgIDB4ZWZiZTQ3ODYsXG4gICAgICAgICAgICAweDBmYzE5ZGM2LFxuICAgICAgICAgICAgMHgyNDBjYTFjYyxcbiAgICAgICAgICAgIDB4MmRlOTJjNmYsXG4gICAgICAgICAgICAweDRhNzQ4NGFhLFxuICAgICAgICAgICAgMHg1Y2IwYTlkYyxcbiAgICAgICAgICAgIDB4NzZmOTg4ZGEsXG4gICAgICAgICAgICAweDk4M2U1MTUyLFxuICAgICAgICAgICAgMHhhODMxYzY2ZCxcbiAgICAgICAgICAgIDB4YjAwMzI3YzgsXG4gICAgICAgICAgICAweGJmNTk3ZmM3LFxuICAgICAgICAgICAgMHhjNmUwMGJmMyxcbiAgICAgICAgICAgIDB4ZDVhNzkxNDcsXG4gICAgICAgICAgICAweDA2Y2E2MzUxLFxuICAgICAgICAgICAgMHgxNDI5Mjk2NyxcbiAgICAgICAgICAgIDB4MjdiNzBhODUsXG4gICAgICAgICAgICAweDJlMWIyMTM4LFxuICAgICAgICAgICAgMHg0ZDJjNmRmYyxcbiAgICAgICAgICAgIDB4NTMzODBkMTMsXG4gICAgICAgICAgICAweDY1MGE3MzU0LFxuICAgICAgICAgICAgMHg3NjZhMGFiYixcbiAgICAgICAgICAgIDB4ODFjMmM5MmUsXG4gICAgICAgICAgICAweDkyNzIyYzg1LFxuICAgICAgICAgICAgMHhhMmJmZThhMSxcbiAgICAgICAgICAgIDB4YTgxYTY2NGIsXG4gICAgICAgICAgICAweGMyNGI4YjcwLFxuICAgICAgICAgICAgMHhjNzZjNTFhMyxcbiAgICAgICAgICAgIDB4ZDE5MmU4MTksXG4gICAgICAgICAgICAweGQ2OTkwNjI0LFxuICAgICAgICAgICAgMHhmNDBlMzU4NSxcbiAgICAgICAgICAgIDB4MTA2YWEwNzAsXG4gICAgICAgICAgICAweDE5YTRjMTE2LFxuICAgICAgICAgICAgMHgxZTM3NmMwOCxcbiAgICAgICAgICAgIDB4Mjc0ODc3NGMsXG4gICAgICAgICAgICAweDM0YjBiY2I1LFxuICAgICAgICAgICAgMHgzOTFjMGNiMyxcbiAgICAgICAgICAgIDB4NGVkOGFhNGEsXG4gICAgICAgICAgICAweDViOWNjYTRmLFxuICAgICAgICAgICAgMHg2ODJlNmZmMyxcbiAgICAgICAgICAgIDB4NzQ4ZjgyZWUsXG4gICAgICAgICAgICAweDc4YTU2MzZmLFxuICAgICAgICAgICAgMHg4NGM4NzgxNCxcbiAgICAgICAgICAgIDB4OGNjNzAyMDgsXG4gICAgICAgICAgICAweDkwYmVmZmZhLFxuICAgICAgICAgICAgMHhhNDUwNmNlYixcbiAgICAgICAgICAgIDB4YmVmOWEzZjcsXG4gICAgICAgICAgICAweGM2NzE3OGYyXG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5fSCA9IG5ldyBVaW50MzJBcnJheShbXG4gICAgICAgICAgICAweDZhMDllNjY3LFxuICAgICAgICAgICAgMHhiYjY3YWU4NSxcbiAgICAgICAgICAgIDB4M2M2ZWYzNzIsXG4gICAgICAgICAgICAweGE1NGZmNTNhLFxuICAgICAgICAgICAgMHg1MTBlNTI3ZixcbiAgICAgICAgICAgIDB4OWIwNTY4OGMsXG4gICAgICAgICAgICAweDFmODNkOWFiLFxuICAgICAgICAgICAgMHg1YmUwY2QxOVxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5fYnVmSWR4ID0gMDtcbiAgICAgICAgdGhpcy5fY291bnQgPSBuZXcgVWludDMyQXJyYXkoMik7XG4gICAgICAgIHRoaXMuX2J1Zi5maWxsKDApO1xuICAgICAgICB0aGlzLl9maW5hbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVwZGF0ZShtc2csIGlucHV0RW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKG1zZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm1zZyBtdXN0IGJlIGEgc3RyaW5nIG9yIFVpbnQ4QXJyYXkuXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBtc2cgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG1zZyA9IGVuY29kZTEobXNnLCBpbnB1dEVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IobGV0IGkgPSAwLCBsZW4gPSBtc2cubGVuZ3RoOyBpIDwgbGVuOyBpKyspe1xuICAgICAgICAgICAgdGhpcy5fYnVmW3RoaXMuX2J1ZklkeCsrXSA9IG1zZ1tpXTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9idWZJZHggPT09IDY0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYnVmSWR4ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjID0gdGhpcy5fY291bnQ7XG4gICAgICAgIGlmICgoY1swXSArPSBtc2cubGVuZ3RoIDw8IDMpIDwgbXNnLmxlbmd0aCA8PCAzKSB7XG4gICAgICAgICAgICBjWzFdKys7XG4gICAgICAgIH1cbiAgICAgICAgY1sxXSArPSBtc2cubGVuZ3RoID4+PiAyOTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdChvdXRwdXRFbmNvZGluZykge1xuICAgICAgICBpZiAodGhpcy5fZmluYWxpemVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaWdlc3QgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZpbmFsaXplZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IGIgPSB0aGlzLl9idWY7XG4gICAgICAgIGxldCBpZHggPSB0aGlzLl9idWZJZHg7XG4gICAgICAgIGJbaWR4KytdID0gMHg4MDtcbiAgICAgICAgd2hpbGUoaWR4ICE9PSA1Nil7XG4gICAgICAgICAgICBpZiAoaWR4ID09PSA2NCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybSgpO1xuICAgICAgICAgICAgICAgIGlkeCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiW2lkeCsrXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYyA9IHRoaXMuX2NvdW50O1xuICAgICAgICBiWzU2XSA9IGNbMV0gPj4+IDI0ICYgMHhmZjtcbiAgICAgICAgYls1N10gPSBjWzFdID4+PiAxNiAmIDB4ZmY7XG4gICAgICAgIGJbNThdID0gY1sxXSA+Pj4gOCAmIDB4ZmY7XG4gICAgICAgIGJbNTldID0gY1sxXSA+Pj4gMCAmIDB4ZmY7XG4gICAgICAgIGJbNjBdID0gY1swXSA+Pj4gMjQgJiAweGZmO1xuICAgICAgICBiWzYxXSA9IGNbMF0gPj4+IDE2ICYgMHhmZjtcbiAgICAgICAgYls2Ml0gPSBjWzBdID4+PiA4ICYgMHhmZjtcbiAgICAgICAgYls2M10gPSBjWzBdID4+PiAwICYgMHhmZjtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtKCk7XG4gICAgICAgIGNvbnN0IGhhc2ggPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCA4OyBpKyspe1xuICAgICAgICAgICAgaGFzaFsoaSA8PCAyKSArIDBdID0gdGhpcy5fSFtpXSA+Pj4gMjQgJiAweGZmO1xuICAgICAgICAgICAgaGFzaFsoaSA8PCAyKSArIDFdID0gdGhpcy5fSFtpXSA+Pj4gMTYgJiAweGZmO1xuICAgICAgICAgICAgaGFzaFsoaSA8PCAyKSArIDJdID0gdGhpcy5fSFtpXSA+Pj4gOCAmIDB4ZmY7XG4gICAgICAgICAgICBoYXNoWyhpIDw8IDIpICsgM10gPSB0aGlzLl9IW2ldID4+PiAwICYgMHhmZjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dEVuY29kaW5nID8gZGVjb2RlMShoYXNoLCBvdXRwdXRFbmNvZGluZykgOiBoYXNoO1xuICAgIH1cbiAgICBfdHJhbnNmb3JtKCkge1xuICAgICAgICBjb25zdCBoID0gdGhpcy5fSDtcbiAgICAgICAgbGV0IGgwID0gaFswXTtcbiAgICAgICAgbGV0IGgxID0gaFsxXTtcbiAgICAgICAgbGV0IGgyID0gaFsyXTtcbiAgICAgICAgbGV0IGgzID0gaFszXTtcbiAgICAgICAgbGV0IGg0ID0gaFs0XTtcbiAgICAgICAgbGV0IGg1ID0gaFs1XTtcbiAgICAgICAgbGV0IGg2ID0gaFs2XTtcbiAgICAgICAgbGV0IGg3ID0gaFs3XTtcbiAgICAgICAgY29uc3QgdyA9IG5ldyBVaW50MzJBcnJheSgxNik7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCAxNjsgaSsrKXtcbiAgICAgICAgICAgIHdbaV0gPSB0aGlzLl9idWZbKGkgPDwgMikgKyAzXSB8IHRoaXMuX2J1ZlsoaSA8PCAyKSArIDJdIDw8IDggfCB0aGlzLl9idWZbKGkgPDwgMikgKyAxXSA8PCAxNiB8IHRoaXMuX2J1ZltpIDw8IDJdIDw8IDI0O1xuICAgICAgICB9XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDY0OyBpKyspe1xuICAgICAgICAgICAgbGV0IHRtcDtcbiAgICAgICAgICAgIGlmIChpIDwgMTYpIHtcbiAgICAgICAgICAgICAgICB0bXAgPSB3W2ldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgYSA9IHdbaSArIDEgJiAxNV07XG4gICAgICAgICAgICAgICAgbGV0IGIgPSB3W2kgKyAxNCAmIDE1XTtcbiAgICAgICAgICAgICAgICB0bXAgPSB3W2kgJiAxNV0gPSAoYSA+Pj4gNyBeIGEgPj4+IDE4IF4gYSA+Pj4gMyBeIGEgPDwgMjUgXiBhIDw8IDE0KSArIChiID4+PiAxNyBeIGIgPj4+IDE5IF4gYiA+Pj4gMTAgXiBiIDw8IDE1IF4gYiA8PCAxMykgKyB3W2kgJiAxNV0gKyB3W2kgKyA5ICYgMTVdIHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRtcCA9IHRtcCArIGg3ICsgKGg0ID4+PiA2IF4gaDQgPj4+IDExIF4gaDQgPj4+IDI1IF4gaDQgPDwgMjYgXiBoNCA8PCAyMSBeIGg0IDw8IDcpICsgKGg2IF4gaDQgJiAoaDUgXiBoNikpICsgdGhpcy5fS1tpXSB8IDA7XG4gICAgICAgICAgICBoNyA9IGg2O1xuICAgICAgICAgICAgaDYgPSBoNTtcbiAgICAgICAgICAgIGg1ID0gaDQ7XG4gICAgICAgICAgICBoNCA9IGgzICsgdG1wO1xuICAgICAgICAgICAgaDMgPSBoMjtcbiAgICAgICAgICAgIGgyID0gaDE7XG4gICAgICAgICAgICBoMSA9IGgwO1xuICAgICAgICAgICAgaDAgPSB0bXAgKyAoaDEgJiBoMiBeIGgzICYgKGgxIF4gaDIpKSArIChoMSA+Pj4gMiBeIGgxID4+PiAxMyBeIGgxID4+PiAyMiBeIGgxIDw8IDMwIF4gaDEgPDwgMTkgXiBoMSA8PCAxMCkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIGhbMF0gPSBoWzBdICsgaDAgfCAwO1xuICAgICAgICBoWzFdID0gaFsxXSArIGgxIHwgMDtcbiAgICAgICAgaFsyXSA9IGhbMl0gKyBoMiB8IDA7XG4gICAgICAgIGhbM10gPSBoWzNdICsgaDMgfCAwO1xuICAgICAgICBoWzRdID0gaFs0XSArIGg0IHwgMDtcbiAgICAgICAgaFs1XSA9IGhbNV0gKyBoNSB8IDA7XG4gICAgICAgIGhbNl0gPSBoWzZdICsgaDYgfCAwO1xuICAgICAgICBoWzddID0gaFs3XSArIGg3IHwgMDtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZVNlbVZlcihzKSB7XG4gICAgY29uc3QgbSA9IHMubWF0Y2goLyhcXGQrKS4oXFxkKykuKFxcZCspLyk7XG4gICAgaWYgKG0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1ham9yOiBwYXJzZUludChtWzFdKSxcbiAgICAgICAgICAgIG1pbm9yOiBwYXJzZUludChtWzJdKSxcbiAgICAgICAgICAgIG1pY3JvOiBwYXJzZUludChtWzNdKVxuICAgICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7c30gaXMgbm90IGEgc2VtdmVyIHZhbHVlYCk7XG59XG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgICBpZiAoYS5tYWpvciA8IGIubWFqb3IpIHJldHVybiAtMTtcbiAgICBpZiAoYS5tYWpvciA+IGIubWFqb3IpIHJldHVybiAxO1xuICAgIGlmIChhLm1pbm9yIDwgYi5taW5vcikgcmV0dXJuIC0xO1xuICAgIGlmIChhLm1pbm9yID4gYi5taW5vcikgcmV0dXJuIDE7XG4gICAgaWYgKGEubWljcm8gPCBiLm1pY3JvKSByZXR1cm4gLTE7XG4gICAgaWYgKGEubWljcm8gPiBiLm1pY3JvKSByZXR1cm4gMTtcbiAgICByZXR1cm4gMDtcbn1cbnZhciBGZWF0dXJlO1xuKGZ1bmN0aW9uKEZlYXR1cmUpIHtcbiAgICBGZWF0dXJlW1wiSlNfUFVMTF9NQVhfQllURVNcIl0gPSBcImpzX3B1bGxfbWF4X2J5dGVzXCI7XG59KShGZWF0dXJlIHx8IChGZWF0dXJlID0ge30pKTtcbmNsYXNzIEZlYXR1cmVzIHtcbiAgICBzZXJ2ZXI7XG4gICAgZmVhdHVyZXM7XG4gICAgY29uc3RydWN0b3Iodil7XG4gICAgICAgIHRoaXMuZmVhdHVyZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc2VydmVyID0gdjtcbiAgICAgICAgdGhpcy5zZXQoRmVhdHVyZS5KU19QVUxMX01BWF9CWVRFUywgXCIyLjguM1wiKTtcbiAgICB9XG4gICAgc2V0KGYsIHJlcXVpcmVzKSB7XG4gICAgICAgIHRoaXMuZmVhdHVyZXMuc2V0KGYsIHtcbiAgICAgICAgICAgIG1pbjogcmVxdWlyZXMsXG4gICAgICAgICAgICBvazogY29tcGFyZSh0aGlzLnNlcnZlciwgcGFyc2VTZW1WZXIocmVxdWlyZXMpKSA+PSAwXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQoZikge1xuICAgICAgICByZXR1cm4gdGhpcy5mZWF0dXJlcy5nZXQoZikgfHwge1xuICAgICAgICAgICAgbWluOiBcInVua25vd25cIixcbiAgICAgICAgICAgIG9rOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdXBwb3J0cyhmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChmKS5vaztcbiAgICB9XG4gICAgcmVxdWlyZSh2KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdiA9IHBhcnNlU2VtVmVyKHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wYXJlKHRoaXMuc2VydmVyLCB2KSA+PSAwO1xuICAgIH1cbn1cbmNvbnN0IGRlZmF1bHRQcmVmaXggPSBcIiRKUy5BUElcIjtcbmZ1bmN0aW9uIGRlZmF1bHRKc09wdGlvbnMob3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIGlmIChvcHRzLmRvbWFpbikge1xuICAgICAgICBvcHRzLmFwaVByZWZpeCA9IGAkSlMuJHtvcHRzLmRvbWFpbn0uQVBJYDtcbiAgICAgICAgZGVsZXRlIG9wdHMuZG9tYWluO1xuICAgIH1cbiAgICByZXR1cm4gZXh0ZW5kKHtcbiAgICAgICAgYXBpUHJlZml4OiBkZWZhdWx0UHJlZml4LFxuICAgICAgICB0aW1lb3V0OiA1MDAwXG4gICAgfSwgb3B0cyk7XG59XG5jbGFzcyBCYXNlQXBpQ2xpZW50IHtcbiAgICBuYztcbiAgICBvcHRzO1xuICAgIHByZWZpeDtcbiAgICB0aW1lb3V0O1xuICAgIGpjO1xuICAgIGNvbnN0cnVjdG9yKG5jLCBvcHRzKXtcbiAgICAgICAgdGhpcy5uYyA9IG5jO1xuICAgICAgICB0aGlzLm9wdHMgPSBkZWZhdWx0SnNPcHRpb25zKG9wdHMpO1xuICAgICAgICB0aGlzLl9wYXJzZU9wdHMoKTtcbiAgICAgICAgdGhpcy5wcmVmaXggPSB0aGlzLm9wdHMuYXBpUHJlZml4O1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSB0aGlzLm9wdHMudGltZW91dDtcbiAgICAgICAgdGhpcy5qYyA9IEpTT05Db2RlYygpO1xuICAgIH1cbiAgICBfcGFyc2VPcHRzKCkge1xuICAgICAgICBsZXQgcHJlZml4ID0gdGhpcy5vcHRzLmFwaVByZWZpeDtcbiAgICAgICAgaWYgKCFwcmVmaXggfHwgcHJlZml4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBlbXB0eSBwcmVmaXhcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYyA9IHByZWZpeFtwcmVmaXgubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChjID09PSBcIi5cIikge1xuICAgICAgICAgICAgcHJlZml4ID0gcHJlZml4LnN1YnN0cigwLCBwcmVmaXgubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRzLmFwaVByZWZpeCA9IHByZWZpeDtcbiAgICB9XG4gICAgYXN5bmMgX3JlcXVlc3Qoc3ViaiwgZGF0YSA9IG51bGwsIG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIG9wdHMudGltZW91dCA9IHRoaXMudGltZW91dDtcbiAgICAgICAgbGV0IGEgPSBFbXB0eTtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIGEgPSB0aGlzLmpjLmVuY29kZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtID0gYXdhaXQgdGhpcy5uYy5yZXF1ZXN0KHN1YmosIGEsIG9wdHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUpzUmVzcG9uc2UobSk7XG4gICAgfVxuICAgIGFzeW5jIGZpbmRTdHJlYW0oc3ViamVjdCkge1xuICAgICAgICBjb25zdCBxID0ge1xuICAgICAgICAgICAgc3ViamVjdFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByID0gYXdhaXQgdGhpcy5fcmVxdWVzdChgJHt0aGlzLnByZWZpeH0uU1RSRUFNLk5BTUVTYCwgcSk7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gcjtcbiAgICAgICAgaWYgKCFuYW1lcy5zdHJlYW1zIHx8IG5hbWVzLnN0cmVhbXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBzdHJlYW0gbWF0Y2hlcyBzdWJqZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYW1lcy5zdHJlYW1zWzBdO1xuICAgIH1cbiAgICBwYXJzZUpzUmVzcG9uc2UobSkge1xuICAgICAgICBjb25zdCB2ID0gdGhpcy5qYy5kZWNvZGUobS5kYXRhKTtcbiAgICAgICAgY29uc3QgciA9IHY7XG4gICAgICAgIGlmIChyLmVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSBjaGVja0pzRXJyb3JDb2RlKHIuZXJyb3IuY29kZSwgci5lcnJvci5kZXNjcmlwdGlvbik7XG4gICAgICAgICAgICBpZiAoZXJyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZXJyLmFwaV9lcnJvciA9IHIuZXJyb3I7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbn1cbmNsYXNzIExpc3RlckltcGwge1xuICAgIGVycjtcbiAgICBvZmZzZXQ7XG4gICAgcGFnZUluZm87XG4gICAgc3ViamVjdDtcbiAgICBqc207XG4gICAgZmlsdGVyO1xuICAgIGNvbnN0cnVjdG9yKHN1YmplY3QsIGZpbHRlciwganNtKXtcbiAgICAgICAgaWYgKCFzdWJqZWN0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdWJqZWN0IGlzIHJlcXVpcmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3ViamVjdCA9IHN1YmplY3Q7XG4gICAgICAgIHRoaXMuanNtID0ganNtO1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMucGFnZUluZm8gPSB7fTtcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgfVxuICAgIGFzeW5jIG5leHQoKSB7XG4gICAgICAgIGlmICh0aGlzLmVycikge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhZ2VJbmZvICYmIHRoaXMub2Zmc2V0ID49IHRoaXMucGFnZUluZm8udG90YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvZmZzZXQgPSB7XG4gICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0XG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByID0gYXdhaXQgdGhpcy5qc20uX3JlcXVlc3QodGhpcy5zdWJqZWN0LCBvZmZzZXQsIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aGlzLmpzbS50aW1lb3V0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucGFnZUluZm8gPSByO1xuICAgICAgICAgICAgY29uc3QgYSA9IHRoaXMuZmlsdGVyKHIpO1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gYS5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmVyciA9IGVycjtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyAqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgbGV0IHBhZ2UgPSBhd2FpdCB0aGlzLm5leHQoKTtcbiAgICAgICAgd2hpbGUocGFnZS5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBwYWdlKXtcbiAgICAgICAgICAgICAgICB5aWVsZCBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFnZSA9IGF3YWl0IHRoaXMubmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgQ29uc3VtZXJBUElJbXBsIGV4dGVuZHMgQmFzZUFwaUNsaWVudCB7XG4gICAgY29uc3RydWN0b3IobmMsIG9wdHMpe1xuICAgICAgICBzdXBlcihuYywgb3B0cyk7XG4gICAgfVxuICAgIGFzeW5jIGFkZChzdHJlYW0sIGNmZykge1xuICAgICAgICB2YWxpZGF0ZVN0cmVhbU5hbWUoc3RyZWFtKTtcbiAgICAgICAgaWYgKGNmZy5kZWxpdmVyX2dyb3VwICYmIGNmZy5mbG93X2NvbnRyb2wpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImpldHN0cmVhbSBmbG93IGNvbnRyb2wgaXMgbm90IHN1cHBvcnRlZCB3aXRoIHF1ZXVlIGdyb3Vwc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ZnLmRlbGl2ZXJfZ3JvdXAgJiYgY2ZnLmlkbGVfaGVhcnRiZWF0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJqZXRzdHJlYW0gaWRsZSBoZWFydGJlYXQgaXMgbm90IHN1cHBvcnRlZCB3aXRoIHF1ZXVlIGdyb3Vwc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjciA9IHt9O1xuICAgICAgICBjci5jb25maWcgPSBjZmc7XG4gICAgICAgIGNyLnN0cmVhbV9uYW1lID0gc3RyZWFtO1xuICAgICAgICBpZiAoY3IuY29uZmlnLmR1cmFibGVfbmFtZSkge1xuICAgICAgICAgICAgdmFsaWRhdGVEdXJhYmxlTmFtZShjci5jb25maWcuZHVyYWJsZV9uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdWJqID0gY2ZnLmR1cmFibGVfbmFtZSA/IGAke3RoaXMucHJlZml4fS5DT05TVU1FUi5EVVJBQkxFLkNSRUFURS4ke3N0cmVhbX0uJHtjZmcuZHVyYWJsZV9uYW1lfWAgOiBgJHt0aGlzLnByZWZpeH0uQ09OU1VNRVIuQ1JFQVRFLiR7c3RyZWFtfWA7XG4gICAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLl9yZXF1ZXN0KHN1YmosIGNyKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZShzdHJlYW0sIGR1cmFibGUsIGNmZykge1xuICAgICAgICBjb25zdCBjaSA9IGF3YWl0IHRoaXMuaW5mbyhzdHJlYW0sIGR1cmFibGUpO1xuICAgICAgICBjb25zdCBjaGFuZ2FibGUgPSBjZmc7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChzdHJlYW0sIE9iamVjdC5hc3NpZ24oY2kuY29uZmlnLCBjaGFuZ2FibGUpKTtcbiAgICB9XG4gICAgYXN5bmMgaW5mbyhzdHJlYW0sIG5hbWUpIHtcbiAgICAgICAgdmFsaWRhdGVTdHJlYW1OYW1lKHN0cmVhbSk7XG4gICAgICAgIHZhbGlkYXRlRHVyYWJsZU5hbWUobmFtZSk7XG4gICAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLl9yZXF1ZXN0KGAke3RoaXMucHJlZml4fS5DT05TVU1FUi5JTkZPLiR7c3RyZWFtfS4ke25hbWV9YCk7XG4gICAgICAgIHJldHVybiByO1xuICAgIH1cbiAgICBhc3luYyBkZWxldGUoc3RyZWFtLCBuYW1lKSB7XG4gICAgICAgIHZhbGlkYXRlU3RyZWFtTmFtZShzdHJlYW0pO1xuICAgICAgICB2YWxpZGF0ZUR1cmFibGVOYW1lKG5hbWUpO1xuICAgICAgICBjb25zdCByID0gYXdhaXQgdGhpcy5fcmVxdWVzdChgJHt0aGlzLnByZWZpeH0uQ09OU1VNRVIuREVMRVRFLiR7c3RyZWFtfS4ke25hbWV9YCk7XG4gICAgICAgIGNvbnN0IGNyID0gcjtcbiAgICAgICAgcmV0dXJuIGNyLnN1Y2Nlc3M7XG4gICAgfVxuICAgIGxpc3Qoc3RyZWFtKSB7XG4gICAgICAgIHZhbGlkYXRlU3RyZWFtTmFtZShzdHJlYW0pO1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSAodik9PntcbiAgICAgICAgICAgIGNvbnN0IGNsciA9IHY7XG4gICAgICAgICAgICByZXR1cm4gY2xyLmNvbnN1bWVycztcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3ViaiA9IGAke3RoaXMucHJlZml4fS5DT05TVU1FUi5MSVNULiR7c3RyZWFtfWA7XG4gICAgICAgIHJldHVybiBuZXcgTGlzdGVySW1wbChzdWJqLCBmaWx0ZXIsIHRoaXMpO1xuICAgIH1cbn1cbmNsYXNzIEJhc2VSZXF1ZXN0IHtcbiAgICB0b2tlbjtcbiAgICByZWNlaXZlZDtcbiAgICBjdHg7XG4gICAgcmVxdWVzdFN1YmplY3Q7XG4gICAgbXV4O1xuICAgIGNvbnN0cnVjdG9yKG11eCwgcmVxdWVzdFN1YmplY3Qpe1xuICAgICAgICB0aGlzLm11eCA9IG11eDtcbiAgICAgICAgdGhpcy5yZXF1ZXN0U3ViamVjdCA9IHJlcXVlc3RTdWJqZWN0O1xuICAgICAgICB0aGlzLnJlY2VpdmVkID0gMDtcbiAgICAgICAgdGhpcy50b2tlbiA9IG51aWQubmV4dCgpO1xuICAgICAgICB0aGlzLmN0eCA9IG5ldyBFcnJvcigpO1xuICAgIH1cbn1cbmNsYXNzIFJlcXVlc3RNYW55IGV4dGVuZHMgQmFzZVJlcXVlc3Qge1xuICAgIGNhbGxiYWNrO1xuICAgIGRvbmU7XG4gICAgdGltZXI7XG4gICAgbWF4O1xuICAgIG9wdHM7XG4gICAgY29uc3RydWN0b3IobXV4LCByZXF1ZXN0U3ViamVjdCwgb3B0cyA9IHtcbiAgICAgICAgbWF4V2FpdDogMTAwMFxuICAgIH0pe1xuICAgICAgICBzdXBlcihtdXgsIHJlcXVlc3RTdWJqZWN0KTtcbiAgICAgICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdHMuY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FsbGJhY2sgaXMgcmVxdWlyZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IHRoaXMub3B0cy5jYWxsYmFjaztcbiAgICAgICAgdGhpcy5tYXggPSB0eXBlb2Ygb3B0cy5tYXhNZXNzYWdlcyA9PT0gXCJudW1iZXJcIiAmJiBvcHRzLm1heE1lc3NhZ2VzID4gMCA/IG9wdHMubWF4TWVzc2FnZXMgOiAtMTtcbiAgICAgICAgdGhpcy5kb25lID0gZGVmZXJyZWQoKTtcbiAgICAgICAgdGhpcy5kb25lLnRoZW4oKCk9PntcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sobnVsbCwgbnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgfSwgb3B0cy5tYXhXYWl0KTtcbiAgICB9XG4gICAgY2FuY2VsKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrKGVyciwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgICB0aGlzLm11eC5jYW5jZWwodGhpcyk7XG4gICAgICAgIHRoaXMuZG9uZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHJlc29sdmVyKGVyciwgbXNnKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGVyci5zdGFjayArPSBgXFxuXFxuJHt0aGlzLmN0eC5zdGFja31gO1xuICAgICAgICAgICAgdGhpcy5jYW5jZWwoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sobnVsbCwgbXNnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuc3RyYXRlZ3kgPT09IFJlcXVlc3RTdHJhdGVneS5Db3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWF4LS07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWF4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5zdHJhdGVneSA9PT0gUmVxdWVzdFN0cmF0ZWd5LkppdHRlclRpbWVyKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuc3RyYXRlZ3kgPT09IFJlcXVlc3RTdHJhdGVneS5TZW50aW5lbE1zZykge1xuICAgICAgICAgICAgICAgIGlmIChtc2cgJiYgbXNnLmRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgUmVxdWVzdE9uZSBleHRlbmRzIEJhc2VSZXF1ZXN0IHtcbiAgICBkZWZlcnJlZDtcbiAgICB0aW1lcjtcbiAgICBjb25zdHJ1Y3RvcihtdXgsIHJlcXVlc3RTdWJqZWN0LCBvcHRzID0ge1xuICAgICAgICB0aW1lb3V0OiAxMDAwXG4gICAgfSl7XG4gICAgICAgIHN1cGVyKG11eCwgcmVxdWVzdFN1YmplY3QpO1xuICAgICAgICB0aGlzLmRlZmVycmVkID0gZGVmZXJyZWQoKTtcbiAgICAgICAgdGhpcy50aW1lciA9IHRpbWVvdXQob3B0cy50aW1lb3V0KTtcbiAgICB9XG4gICAgcmVzb2x2ZXIoZXJyLCBtc2cpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMudGltZXIuY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgZXJyLnN0YWNrICs9IGBcXG5cXG4ke3RoaXMuY3R4LnN0YWNrfWA7XG4gICAgICAgICAgICB0aGlzLmRlZmVycmVkLnJlamVjdChlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWZlcnJlZC5yZXNvbHZlKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICB9XG4gICAgY2FuY2VsKGVycikge1xuICAgICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgICAgICAgdGhpcy50aW1lci5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm11eC5jYW5jZWwodGhpcyk7XG4gICAgICAgIHRoaXMuZGVmZXJyZWQucmVqZWN0KGVyciA/IGVyciA6IE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLkNhbmNlbGxlZCkpO1xuICAgIH1cbn1cbmNvbnN0IEFDSyA9IFVpbnQ4QXJyYXkub2YoNDMsIDY1LCA2NywgNzUpO1xuY29uc3QgTkFLID0gVWludDhBcnJheS5vZig0NSwgNzgsIDY1LCA3NSk7XG5jb25zdCBXUEkgPSBVaW50OEFycmF5Lm9mKDQzLCA4NywgODAsIDczKTtcbmNvbnN0IE5YVCA9IFVpbnQ4QXJyYXkub2YoNDMsIDc4LCA4OCwgODQpO1xuY29uc3QgVEVSTSA9IFVpbnQ4QXJyYXkub2YoNDMsIDg0LCA2OSwgODIsIDc3KTtcbmNvbnN0IFNQQUNFID0gVWludDhBcnJheS5vZigzMik7XG5mdW5jdGlvbiB0b0pzTXNnKG0pIHtcbiAgICByZXR1cm4gbmV3IEpzTXNnSW1wbChtKTtcbn1cbmZ1bmN0aW9uIHBhcnNlSW5mbyhzKSB7XG4gICAgY29uc3QgdG9rZW5zID0gcy5zcGxpdChcIi5cIik7XG4gICAgaWYgKHRva2Vucy5sZW5ndGggPT09IDkpIHtcbiAgICAgICAgdG9rZW5zLnNwbGljZSgyLCAwLCBcIl9cIiwgXCJcIik7XG4gICAgfVxuICAgIGlmICh0b2tlbnMubGVuZ3RoIDwgMTEgfHwgdG9rZW5zWzBdICE9PSBcIiRKU1wiIHx8IHRva2Vuc1sxXSAhPT0gXCJBQ0tcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vdCBqcyBtZXNzYWdlYCk7XG4gICAgfVxuICAgIGNvbnN0IGRpID0ge307XG4gICAgZGkuZG9tYWluID0gdG9rZW5zWzJdID09PSBcIl9cIiA/IFwiXCIgOiB0b2tlbnNbMl07XG4gICAgZGkuYWNjb3VudF9oYXNoID0gdG9rZW5zWzNdO1xuICAgIGRpLnN0cmVhbSA9IHRva2Vuc1s0XTtcbiAgICBkaS5jb25zdW1lciA9IHRva2Vuc1s1XTtcbiAgICBkaS5yZWRlbGl2ZXJ5Q291bnQgPSBwYXJzZUludCh0b2tlbnNbNl0sIDEwKTtcbiAgICBkaS5yZWRlbGl2ZXJlZCA9IGRpLnJlZGVsaXZlcnlDb3VudCA+IDE7XG4gICAgZGkuc3RyZWFtU2VxdWVuY2UgPSBwYXJzZUludCh0b2tlbnNbN10sIDEwKTtcbiAgICBkaS5kZWxpdmVyeVNlcXVlbmNlID0gcGFyc2VJbnQodG9rZW5zWzhdLCAxMCk7XG4gICAgZGkudGltZXN0YW1wTmFub3MgPSBwYXJzZUludCh0b2tlbnNbOV0sIDEwKTtcbiAgICBkaS5wZW5kaW5nID0gcGFyc2VJbnQodG9rZW5zWzEwXSwgMTApO1xuICAgIHJldHVybiBkaTtcbn1cbmNsYXNzIEpzTXNnSW1wbCB7XG4gICAgbXNnO1xuICAgIGRpO1xuICAgIGRpZEFjaztcbiAgICBjb25zdHJ1Y3Rvcihtc2cpe1xuICAgICAgICB0aGlzLm1zZyA9IG1zZztcbiAgICAgICAgdGhpcy5kaWRBY2sgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IHN1YmplY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1zZy5zdWJqZWN0O1xuICAgIH1cbiAgICBnZXQgc2lkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tc2cuc2lkO1xuICAgIH1cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXNnLmRhdGE7XG4gICAgfVxuICAgIGdldCBoZWFkZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tc2cuaGVhZGVycztcbiAgICB9XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIGlmICghdGhpcy5kaSkge1xuICAgICAgICAgICAgdGhpcy5kaSA9IHBhcnNlSW5mbyh0aGlzLnJlcGx5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kaTtcbiAgICB9XG4gICAgZ2V0IHJlZGVsaXZlcmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmZvLnJlZGVsaXZlcnlDb3VudCA+IDE7XG4gICAgfVxuICAgIGdldCByZXBseSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXNnLnJlcGx5IHx8IFwiXCI7XG4gICAgfVxuICAgIGdldCBzZXEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZm8uc3RyZWFtU2VxdWVuY2U7XG4gICAgfVxuICAgIGRvQWNrKHBheWxvYWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpZEFjaykge1xuICAgICAgICAgICAgdGhpcy5kaWRBY2sgPSAhdGhpcy5pc1dJUChwYXlsb2FkKTtcbiAgICAgICAgICAgIHRoaXMubXNnLnJlc3BvbmQocGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNXSVAocCkge1xuICAgICAgICByZXR1cm4gcC5sZW5ndGggPT09IDQgJiYgcFswXSA9PT0gV1BJWzBdICYmIHBbMV0gPT09IFdQSVsxXSAmJiBwWzJdID09PSBXUElbMl0gJiYgcFszXSA9PT0gV1BJWzNdO1xuICAgIH1cbiAgICBhc3luYyBhY2tBY2soKSB7XG4gICAgICAgIGlmICghdGhpcy5kaWRBY2spIHtcbiAgICAgICAgICAgIHRoaXMuZGlkQWNrID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1zZy5yZXBseSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pID0gdGhpcy5tc2c7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdG8gPSBtaS5wdWJsaXNoZXI7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IG5ldyBSZXF1ZXN0T25lKHByb3RvLm11eFN1YnNjcmlwdGlvbnMsIHRoaXMubXNnLnJlcGx5KTtcbiAgICAgICAgICAgICAgICBwcm90by5yZXF1ZXN0KHIpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3RvLnB1Ymxpc2godGhpcy5tc2cucmVwbHksIEFDSywge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHk6IGAke3Byb3RvLm11eFN1YnNjcmlwdGlvbnMuYmFzZUluYm94fSR7ci50b2tlbn1gXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByLmNhbmNlbChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgICAgICAgICAgICAgci50aW1lcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHIuZGVmZXJyZWRcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycjEpIHtcbiAgICAgICAgICAgICAgICAgICAgci5jYW5jZWwoZXJyMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYWNrKCkge1xuICAgICAgICB0aGlzLmRvQWNrKEFDSyk7XG4gICAgfVxuICAgIG5hayhtaWxsaXMpIHtcbiAgICAgICAgbGV0IHBheWxvYWQgPSBOQUs7XG4gICAgICAgIGlmIChtaWxsaXMpIHtcbiAgICAgICAgICAgIHBheWxvYWQgPSBTdHJpbmdDb2RlYygpLmVuY29kZShgLU5BSyAke0pTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBkZWxheTogbmFub3MobWlsbGlzKVxuICAgICAgICAgICAgfSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb0FjayhwYXlsb2FkKTtcbiAgICB9XG4gICAgd29ya2luZygpIHtcbiAgICAgICAgdGhpcy5kb0FjayhXUEkpO1xuICAgIH1cbiAgICBuZXh0KHN1YmosIG9wdHMgPSB7XG4gICAgICAgIGJhdGNoOiAxXG4gICAgfSkge1xuICAgICAgICBjb25zdCBhcmdzID0ge307XG4gICAgICAgIGFyZ3MuYmF0Y2ggPSBvcHRzLmJhdGNoIHx8IDE7XG4gICAgICAgIGFyZ3Mubm9fd2FpdCA9IG9wdHMubm9fd2FpdCB8fCBmYWxzZTtcbiAgICAgICAgaWYgKG9wdHMuZXhwaXJlcyAmJiBvcHRzLmV4cGlyZXMgPiAwKSB7XG4gICAgICAgICAgICBhcmdzLmV4cGlyZXMgPSBuYW5vcyhvcHRzLmV4cGlyZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBKU09OQ29kZWMoKS5lbmNvZGUoYXJncyk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBEYXRhQnVmZmVyLmNvbmNhdChOWFQsIFNQQUNFLCBkYXRhKTtcbiAgICAgICAgY29uc3QgcmVxT3B0cyA9IHN1YmogPyB7XG4gICAgICAgICAgICByZXBseTogc3VialxuICAgICAgICB9IDogdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm1zZy5yZXNwb25kKHBheWxvYWQsIHJlcU9wdHMpO1xuICAgIH1cbiAgICB0ZXJtKCkge1xuICAgICAgICB0aGlzLmRvQWNrKFRFUk0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrRm4oZm4sIG5hbWUsIHJlcXVpcmVkID0gZmFsc2UpIHtcbiAgICBpZiAocmVxdWlyZWQgPT09IHRydWUgJiYgIWZuKSB7XG4gICAgICAgIHRocm93IE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLkFwaUVycm9yLCBuZXcgRXJyb3IoYCR7bmFtZX0gaXMgbm90IGEgZnVuY3Rpb25gKSk7XG4gICAgfVxuICAgIGlmIChmbiAmJiB0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBOYXRzRXJyb3IuZXJyb3JGb3JDb2RlKEVycm9yQ29kZS5BcGlFcnJvciwgbmV3IEVycm9yKGAke25hbWV9IGlzIG5vdCBhIGZ1bmN0aW9uYCkpO1xuICAgIH1cbn1cbmNsYXNzIFR5cGVkU3Vic2NyaXB0aW9uIGV4dGVuZHMgUXVldWVkSXRlcmF0b3JJbXBsIHtcbiAgICBzdWI7XG4gICAgYWRhcHRlcjtcbiAgICBzdWJJdGVyRG9uZTtcbiAgICBjb25zdHJ1Y3RvcihuYywgc3ViamVjdCwgb3B0cyl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGNoZWNrRm4ob3B0cy5hZGFwdGVyLCBcImFkYXB0ZXJcIiwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuYWRhcHRlciA9IG9wdHMuYWRhcHRlcjtcbiAgICAgICAgaWYgKG9wdHMuY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNoZWNrRm4ob3B0cy5jYWxsYmFjaywgXCJjYWxsYmFja1wiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vSXRlcmF0b3IgPSB0eXBlb2Ygb3B0cy5jYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgICBpZiAob3B0cy5pbmdlc3Rpb25GaWx0ZXJGbikge1xuICAgICAgICAgICAgY2hlY2tGbihvcHRzLmluZ2VzdGlvbkZpbHRlckZuLCBcImluZ2VzdGlvbkZpbHRlckZuXCIpO1xuICAgICAgICAgICAgdGhpcy5pbmdlc3Rpb25GaWx0ZXJGbiA9IG9wdHMuaW5nZXN0aW9uRmlsdGVyRm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMucHJvdG9jb2xGaWx0ZXJGbikge1xuICAgICAgICAgICAgY2hlY2tGbihvcHRzLnByb3RvY29sRmlsdGVyRm4sIFwicHJvdG9jb2xGaWx0ZXJGblwiKTtcbiAgICAgICAgICAgIHRoaXMucHJvdG9jb2xGaWx0ZXJGbiA9IG9wdHMucHJvdG9jb2xGaWx0ZXJGbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5kaXNwYXRjaGVkRm4pIHtcbiAgICAgICAgICAgIGNoZWNrRm4ob3B0cy5kaXNwYXRjaGVkRm4sIFwiZGlzcGF0Y2hlZEZuXCIpO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaGVkRm4gPSBvcHRzLmRpc3BhdGNoZWRGbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5jbGVhbnVwRm4pIHtcbiAgICAgICAgICAgIGNoZWNrRm4ob3B0cy5jbGVhbnVwRm4sIFwiY2xlYW51cEZuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjYWxsYmFjayA9IChlcnIsIG1zZyk9PntcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2soZXJyLCBtc2cpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0cy5jYWxsYmFjaykge1xuICAgICAgICAgICAgY29uc3QgdWggPSBvcHRzLmNhbGxiYWNrO1xuICAgICAgICAgICAgY2FsbGJhY2sgPSAoZXJyLCBtc2cpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgW2plciwgdG1dID0gdGhpcy5hZGFwdGVyKGVyciwgbXNnKTtcbiAgICAgICAgICAgICAgICBpZiAoamVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHVoKGplciwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpbmdlc3QgIH0gPSB0aGlzLmluZ2VzdGlvbkZpbHRlckZuID8gdGhpcy5pbmdlc3Rpb25GaWx0ZXJGbih0bSwgdGhpcykgOiB7XG4gICAgICAgICAgICAgICAgICAgIGluZ2VzdDogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKGluZ2VzdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvayA9IHRoaXMucHJvdG9jb2xGaWx0ZXJGbiA/IHRoaXMucHJvdG9jb2xGaWx0ZXJGbih0bSkgOiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVoKGplciwgdG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlzcGF0Y2hlZEZuICYmIHRtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaGVkRm4odG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG1heCAsIHF1ZXVlICwgdGltZW91dCAgfSA9IG9wdHM7XG4gICAgICAgIGNvbnN0IHNvcHRzID0ge1xuICAgICAgICAgICAgcXVldWUsXG4gICAgICAgICAgICB0aW1lb3V0LFxuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG1heCAmJiBtYXggPiAwKSB7XG4gICAgICAgICAgICBzb3B0cy5tYXggPSBtYXg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWIgPSBuYy5zdWJzY3JpYmUoc3ViamVjdCwgc29wdHMpO1xuICAgICAgICBpZiAob3B0cy5jbGVhbnVwRm4pIHtcbiAgICAgICAgICAgIHRoaXMuc3ViLmNsZWFudXBGbiA9IG9wdHMuY2xlYW51cEZuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5ub0l0ZXJhdG9yKSB7XG4gICAgICAgICAgICB0aGlzLml0ZXJDbG9zZWQudGhlbigoKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3ViSXRlckRvbmUgPSBkZWZlcnJlZCgpO1xuICAgICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICB0aGlzLnN1Yi5jbG9zZWQsXG4gICAgICAgICAgICB0aGlzLml0ZXJDbG9zZWRcbiAgICAgICAgXSkudGhlbigoKT0+e1xuICAgICAgICAgICAgdGhpcy5zdWJJdGVyRG9uZS5yZXNvbHZlKCk7XG4gICAgICAgIH0pLmNhdGNoKCgpPT57XG4gICAgICAgICAgICB0aGlzLnN1Ykl0ZXJEb25lLnJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIChhc3luYyAocyk9PntcbiAgICAgICAgICAgIGF3YWl0IHMuY2xvc2VkO1xuICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIH0pKHRoaXMuc3ViKS50aGVuKCkuY2F0Y2goKTtcbiAgICB9XG4gICAgdW5zdWJzY3JpYmUobWF4KSB7XG4gICAgICAgIHRoaXMuc3ViLnVuc3Vic2NyaWJlKG1heCk7XG4gICAgfVxuICAgIGRyYWluKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWIuZHJhaW4oKTtcbiAgICB9XG4gICAgaXNEcmFpbmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViLmlzRHJhaW5pbmcoKTtcbiAgICB9XG4gICAgaXNDbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1Yi5pc0Nsb3NlZCgpO1xuICAgIH1cbiAgICBjYWxsYmFjayhlLCBtc2cpIHtcbiAgICAgICAgdGhpcy5zdWIuY2FuY2VsVGltZW91dCgpO1xuICAgICAgICBjb25zdCBbZXJyLCB0bV0gPSB0aGlzLmFkYXB0ZXIoZSwgbXNnKTtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgdGhpcy5zdG9wKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRtKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2godG0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFN1YmplY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1Yi5nZXRTdWJqZWN0KCk7XG4gICAgfVxuICAgIGdldFJlY2VpdmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWIuZ2V0UmVjZWl2ZWQoKTtcbiAgICB9XG4gICAgZ2V0UHJvY2Vzc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWIuZ2V0UHJvY2Vzc2VkKCk7XG4gICAgfVxuICAgIGdldFBlbmRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1Yi5nZXRQZW5kaW5nKCk7XG4gICAgfVxuICAgIGdldElEKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWIuZ2V0SUQoKTtcbiAgICB9XG4gICAgZ2V0TWF4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWIuZ2V0TWF4KCk7XG4gICAgfVxuICAgIGdldCBjbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1Yi5jbG9zZWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNSZXF1ZXN0RXJyb3IobXNnKSB7XG4gICAgaWYgKG1zZyAmJiBtc2cuZGF0YS5sZW5ndGggPT09IDAgJiYgbXNnLmhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG1zZy5oZWFkZXJzO1xuICAgICAgICBpZiAoaGVhZGVycy5oYXNFcnJvcikge1xuICAgICAgICAgICAgaWYgKGhlYWRlcnMuY29kZSA9PT0gNTAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLk5vUmVzcG9uZGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5jbGFzcyBNc2dJbXBsIHtcbiAgICBfaGVhZGVycztcbiAgICBfbXNnO1xuICAgIF9yZGF0YTtcbiAgICBfcmVwbHk7XG4gICAgX3N1YmplY3Q7XG4gICAgcHVibGlzaGVyO1xuICAgIGNvbnN0cnVjdG9yKG1zZywgZGF0YSwgcHVibGlzaGVyKXtcbiAgICAgICAgdGhpcy5fbXNnID0gbXNnO1xuICAgICAgICB0aGlzLl9yZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMucHVibGlzaGVyID0gcHVibGlzaGVyO1xuICAgIH1cbiAgICBnZXQgc3ViamVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N1YmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdWJqZWN0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N1YmplY3QgPSBURC5kZWNvZGUodGhpcy5fbXNnLnN1YmplY3QpO1xuICAgICAgICByZXR1cm4gdGhpcy5fc3ViamVjdDtcbiAgICB9XG4gICAgZ2V0IHJlcGx5KCkge1xuICAgICAgICBpZiAodGhpcy5fcmVwbHkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXBseTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXBseSA9IFRELmRlY29kZSh0aGlzLl9tc2cucmVwbHkpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVwbHk7XG4gICAgfVxuICAgIGdldCBzaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tc2cuc2lkO1xuICAgIH1cbiAgICBnZXQgaGVhZGVycygpIHtcbiAgICAgICAgaWYgKHRoaXMuX21zZy5oZHIgPiAtMSAmJiAhdGhpcy5faGVhZGVycykge1xuICAgICAgICAgICAgY29uc3QgYnVmID0gdGhpcy5fcmRhdGEuc3ViYXJyYXkoMCwgdGhpcy5fbXNnLmhkcik7XG4gICAgICAgICAgICB0aGlzLl9oZWFkZXJzID0gTXNnSGRyc0ltcGwuZGVjb2RlKGJ1Zik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWRlcnM7XG4gICAgfVxuICAgIGdldCBkYXRhKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3JkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX21zZy5oZHIgPiAtMSA/IHRoaXMuX3JkYXRhLnN1YmFycmF5KHRoaXMuX21zZy5oZHIpIDogdGhpcy5fcmRhdGE7XG4gICAgfVxuICAgIHJlc3BvbmQoZGF0YSA9IEVtcHR5LCBvcHRzKSB7XG4gICAgICAgIGlmICh0aGlzLnJlcGx5KSB7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2hlci5wdWJsaXNoKHRoaXMucmVwbHksIGRhdGEsIG9wdHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmxldCB0cmFuc3BvcnRDb25maWc7XG5mdW5jdGlvbiBzZXRUcmFuc3BvcnRGYWN0b3J5KGNvbmZpZykge1xuICAgIHRyYW5zcG9ydENvbmZpZyA9IGNvbmZpZztcbn1cbmZ1bmN0aW9uIGRlZmF1bHRQb3J0KCkge1xuICAgIHJldHVybiB0cmFuc3BvcnRDb25maWcgIT09IHVuZGVmaW5lZCAmJiB0cmFuc3BvcnRDb25maWcuZGVmYXVsdFBvcnQgIT09IHVuZGVmaW5lZCA/IHRyYW5zcG9ydENvbmZpZy5kZWZhdWx0UG9ydCA6IDQyMjI7XG59XG5mdW5jdGlvbiBnZXRVcmxQYXJzZUZuKCkge1xuICAgIHJldHVybiB0cmFuc3BvcnRDb25maWcgIT09IHVuZGVmaW5lZCAmJiB0cmFuc3BvcnRDb25maWcudXJsUGFyc2VGbiA/IHRyYW5zcG9ydENvbmZpZy51cmxQYXJzZUZuIDogdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gbmV3VHJhbnNwb3J0KCkge1xuICAgIGlmICghdHJhbnNwb3J0Q29uZmlnIHx8IHR5cGVvZiB0cmFuc3BvcnRDb25maWcuZmFjdG9yeSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyYW5zcG9ydCBmbiBpcyBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNwb3J0Q29uZmlnLmZhY3RvcnkoKTtcbn1cbmZ1bmN0aW9uIGdldFJlc29sdmVGbigpIHtcbiAgICByZXR1cm4gdHJhbnNwb3J0Q29uZmlnICE9PSB1bmRlZmluZWQgJiYgdHJhbnNwb3J0Q29uZmlnLmRuc1Jlc29sdmVGbiA/IHRyYW5zcG9ydENvbmZpZy5kbnNSZXNvbHZlRm4gOiB1bmRlZmluZWQ7XG59XG5jb25zdCBJUHY0TEVOID0gNDtcbmNvbnN0IEFTQ0lJMCA9IDQ4O1xuY29uc3QgQVNDSUlBID0gNjU7XG5jb25zdCBBU0NJSWEgPSA5NztcbmZ1bmN0aW9uIGlwVjQoYSwgYiwgYywgZCkge1xuICAgIGNvbnN0IGlwID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgIGNvbnN0IHByZWZpeCA9IFtcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMHhmZixcbiAgICAgICAgMHhmZlxuICAgIF07XG4gICAgcHJlZml4LmZvckVhY2goKHYsIGlkeCk9PntcbiAgICAgICAgaXBbaWR4XSA9IHY7XG4gICAgfSk7XG4gICAgaXBbMTJdID0gYTtcbiAgICBpcFsxM10gPSBiO1xuICAgIGlwWzE0XSA9IGM7XG4gICAgaXBbMTVdID0gZDtcbiAgICByZXR1cm4gaXA7XG59XG5mdW5jdGlvbiBpc0lQKGgpIHtcbiAgICByZXR1cm4gcGFyc2VJUChoKSAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gcGFyc2VJUChoKSB7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGgubGVuZ3RoOyBpKyspe1xuICAgICAgICBzd2l0Y2goaFtpXSl7XG4gICAgICAgICAgICBjYXNlIFwiLlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUlQdjQoaCk7XG4gICAgICAgICAgICBjYXNlIFwiOlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUlQdjYoaCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xufVxuZnVuY3Rpb24gcGFyc2VJUHY0KHMpIHtcbiAgICBjb25zdCBpcCA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCA0OyBpKyspe1xuICAgICAgICBpZiAocy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBpZiAoc1swXSAhPT0gXCIuXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcyA9IHMuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbiAsIGMgLCBvayAgfSA9IGR0b2kocyk7XG4gICAgICAgIGlmICghb2sgfHwgbiA+IDB4RkYpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcyA9IHMuc3Vic3RyaW5nKGMpO1xuICAgICAgICBpcFtpXSA9IG47XG4gICAgfVxuICAgIHJldHVybiBpcFY0KGlwWzBdLCBpcFsxXSwgaXBbMl0sIGlwWzNdKTtcbn1cbmZ1bmN0aW9uIHBhcnNlSVB2NihzKSB7XG4gICAgY29uc3QgaXAgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgbGV0IGVsbGlwc2lzID0gLTE7XG4gICAgaWYgKHMubGVuZ3RoID49IDIgJiYgc1swXSA9PT0gXCI6XCIgJiYgc1sxXSA9PT0gXCI6XCIpIHtcbiAgICAgICAgZWxsaXBzaXMgPSAwO1xuICAgICAgICBzID0gcy5zdWJzdHJpbmcoMik7XG4gICAgICAgIGlmIChzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGlwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZShpIDwgMTYpe1xuICAgICAgICBjb25zdCB7IG4gLCBjICwgb2sgIH0gPSB4dG9pKHMpO1xuICAgICAgICBpZiAoIW9rIHx8IG4gPiAweEZGRkYpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPCBzLmxlbmd0aCAmJiBzW2NdID09PSBcIi5cIikge1xuICAgICAgICAgICAgaWYgKGVsbGlwc2lzIDwgMCAmJiBpICE9IDE2IC0gNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSArIDQgPiAxNikge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpcDQgPSBwYXJzZUlQdjQocyk7XG4gICAgICAgICAgICBpZiAoaXA0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXBbaV0gPSBpcDRbMTJdO1xuICAgICAgICAgICAgaXBbaSArIDFdID0gaXA0WzEzXTtcbiAgICAgICAgICAgIGlwW2kgKyAyXSA9IGlwNFsxNF07XG4gICAgICAgICAgICBpcFtpICsgM10gPSBpcDRbMTVdO1xuICAgICAgICAgICAgcyA9IFwiXCI7XG4gICAgICAgICAgICBpICs9IElQdjRMRU47XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpcFtpXSA9IG4gPj4gODtcbiAgICAgICAgaXBbaSArIDFdID0gbjtcbiAgICAgICAgaSArPSAyO1xuICAgICAgICBzID0gcy5zdWJzdHJpbmcoYyk7XG4gICAgICAgIGlmIChzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNbMF0gIT09IFwiOlwiIHx8IHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcyA9IHMuc3Vic3RyaW5nKDEpO1xuICAgICAgICBpZiAoc1swXSA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAgIGlmIChlbGxpcHNpcyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsbGlwc2lzID0gaTtcbiAgICAgICAgICAgIHMgPSBzLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIGlmIChzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoaSA8IDE2KSB7XG4gICAgICAgIGlmIChlbGxpcHNpcyA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbjEgPSAxNiAtIGk7XG4gICAgICAgIGZvcihsZXQgaiA9IGkgLSAxOyBqID49IGVsbGlwc2lzOyBqLS0pe1xuICAgICAgICAgICAgaXBbaiArIG4xXSA9IGlwW2pdO1xuICAgICAgICB9XG4gICAgICAgIGZvcihsZXQgajEgPSBlbGxpcHNpcyArIG4xIC0gMTsgajEgPj0gZWxsaXBzaXM7IGoxLS0pe1xuICAgICAgICAgICAgaXBbajFdID0gMDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWxsaXBzaXMgPj0gMCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gaXA7XG59XG5mdW5jdGlvbiBkdG9pKHMpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IG4gPSAwO1xuICAgIGZvcihpID0gMDsgaSA8IHMubGVuZ3RoICYmIDQ4IDw9IHMuY2hhckNvZGVBdChpKSAmJiBzLmNoYXJDb2RlQXQoaSkgPD0gNTc7IGkrKyl7XG4gICAgICAgIG4gPSBuICogMTAgKyAocy5jaGFyQ29kZUF0KGkpIC0gQVNDSUkwKTtcbiAgICAgICAgaWYgKG4gPj0gMHhGRkZGRkYpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbjogMHhGRkZGRkYsXG4gICAgICAgICAgICAgICAgYzogaSxcbiAgICAgICAgICAgICAgICBvazogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG46IDAsXG4gICAgICAgICAgICBjOiAwLFxuICAgICAgICAgICAgb2s6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG46IG4sXG4gICAgICAgIGM6IGksXG4gICAgICAgIG9rOiB0cnVlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHh0b2kocykge1xuICAgIGxldCBuID0gMDtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yKGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGlmICg0OCA8PSBzLmNoYXJDb2RlQXQoaSkgJiYgcy5jaGFyQ29kZUF0KGkpIDw9IDU3KSB7XG4gICAgICAgICAgICBuICo9IDE2O1xuICAgICAgICAgICAgbiArPSBzLmNoYXJDb2RlQXQoaSkgLSBBU0NJSTA7XG4gICAgICAgIH0gZWxzZSBpZiAoOTcgPD0gcy5jaGFyQ29kZUF0KGkpICYmIHMuY2hhckNvZGVBdChpKSA8PSAxMDIpIHtcbiAgICAgICAgICAgIG4gKj0gMTY7XG4gICAgICAgICAgICBuICs9IHMuY2hhckNvZGVBdChpKSAtIEFTQ0lJYSArIDEwO1xuICAgICAgICB9IGVsc2UgaWYgKDY1IDw9IHMuY2hhckNvZGVBdChpKSAmJiBzLmNoYXJDb2RlQXQoaSkgPD0gNzApIHtcbiAgICAgICAgICAgIG4gKj0gMTY7XG4gICAgICAgICAgICBuICs9IHMuY2hhckNvZGVBdChpKSAtIEFTQ0lJQSArIDEwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4gPj0gMHhGRkZGRkYpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbjogMCxcbiAgICAgICAgICAgICAgICBjOiBpLFxuICAgICAgICAgICAgICAgIG9rOiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbjogMCxcbiAgICAgICAgICAgIGM6IGksXG4gICAgICAgICAgICBvazogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbjogbixcbiAgICAgICAgYzogaSxcbiAgICAgICAgb2s6IHRydWVcbiAgICB9O1xufVxuZnVuY3Rpb24gaXNJUFY0T3JIb3N0bmFtZShocCkge1xuICAgIGlmIChocC5pbmRleE9mKFwiLlwiKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChocC5pbmRleE9mKFwiW1wiKSAhPT0gLTEgfHwgaHAuaW5kZXhPZihcIjo6XCIpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChocC5zcGxpdChcIjpcIikubGVuZ3RoIDw9IDIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzSVBWNihocCkge1xuICAgIHJldHVybiAhaXNJUFY0T3JIb3N0bmFtZShocCk7XG59XG5mdW5jdGlvbiBob3N0UG9ydCh1KSB7XG4gICAgdSA9IHUudHJpbSgpO1xuICAgIGlmICh1Lm1hdGNoKC9eKC4qOlxcL1xcLykoLiopL20pKSB7XG4gICAgICAgIHUgPSB1LnJlcGxhY2UoL14oLio6XFwvXFwvKSguKikvZ20sIFwiJDJcIik7XG4gICAgfVxuICAgIGlmIChpc0lQVjYodSkgJiYgdS5pbmRleE9mKFwiW1wiKSA9PT0gLTEpIHtcbiAgICAgICAgdSA9IGBbJHt1fV1gO1xuICAgIH1cbiAgICBjb25zdCBvcCA9IGlzSVBWNih1KSA/IHUubWF0Y2goLyhdOikoXFxkKykvKSA6IHUubWF0Y2goLyg6KShcXGQrKS8pO1xuICAgIGNvbnN0IHBvcnQgPSBvcCAmJiBvcC5sZW5ndGggPT09IDMgJiYgb3BbMV0gJiYgb3BbMl0gPyBwYXJzZUludChvcFsyXSkgOiA0MjIyO1xuICAgIGNvbnN0IHByb3RvY29sID0gcG9ydCA9PT0gODAgPyBcImh0dHBzXCIgOiBcImh0dHBcIjtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGAke3Byb3RvY29sfTovLyR7dX1gKTtcbiAgICB1cmwucG9ydCA9IGAke3BvcnR9YDtcbiAgICBsZXQgaG9zdG5hbWUgPSB1cmwuaG9zdG5hbWU7XG4gICAgaWYgKGhvc3RuYW1lLmNoYXJBdCgwKSA9PT0gXCJbXCIpIHtcbiAgICAgICAgaG9zdG5hbWUgPSBob3N0bmFtZS5zdWJzdHJpbmcoMSwgaG9zdG5hbWUubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIGNvbnN0IGxpc3RlbiA9IHVybC5ob3N0O1xuICAgIHJldHVybiB7XG4gICAgICAgIGxpc3RlbixcbiAgICAgICAgaG9zdG5hbWUsXG4gICAgICAgIHBvcnRcbiAgICB9O1xufVxuY2xhc3MgU2VydmVySW1wbCB7XG4gICAgc3JjO1xuICAgIGxpc3RlbjtcbiAgICBob3N0bmFtZTtcbiAgICBwb3J0O1xuICAgIGRpZENvbm5lY3Q7XG4gICAgcmVjb25uZWN0cztcbiAgICBsYXN0Q29ubmVjdDtcbiAgICBnb3NzaXBlZDtcbiAgICB0bHNOYW1lO1xuICAgIHJlc29sdmVzO1xuICAgIGNvbnN0cnVjdG9yKHUsIGdvc3NpcGVkID0gZmFsc2Upe1xuICAgICAgICB0aGlzLnNyYyA9IHU7XG4gICAgICAgIHRoaXMudGxzTmFtZSA9IFwiXCI7XG4gICAgICAgIGNvbnN0IHYgPSBob3N0UG9ydCh1KTtcbiAgICAgICAgdGhpcy5saXN0ZW4gPSB2Lmxpc3RlbjtcbiAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHYuaG9zdG5hbWU7XG4gICAgICAgIHRoaXMucG9ydCA9IHYucG9ydDtcbiAgICAgICAgdGhpcy5kaWRDb25uZWN0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVjb25uZWN0cyA9IDA7XG4gICAgICAgIHRoaXMubGFzdENvbm5lY3QgPSAwO1xuICAgICAgICB0aGlzLmdvc3NpcGVkID0gZ29zc2lwZWQ7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW47XG4gICAgfVxuICAgIGFzeW5jIHJlc29sdmUob3B0cykge1xuICAgICAgICBpZiAoIW9wdHMuZm4pIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWYgPSBbXTtcbiAgICAgICAgaWYgKGlzSVAodGhpcy5ob3N0bmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGlwcyA9IGF3YWl0IG9wdHMuZm4odGhpcy5ob3N0bmFtZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlwIG9mIGlwcyl7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdG8gPSB0aGlzLnBvcnQgPT09IDgwID8gXCJodHRwc1wiIDogXCJodHRwXCI7XG4gICAgICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChgJHtwcm90b306Ly8ke2lzSVBWNihpcCkgPyBcIltcIiArIGlwICsgXCJdXCIgOiBpcH1gKTtcbiAgICAgICAgICAgICAgICB1cmwucG9ydCA9IGAke3RoaXMucG9ydH1gO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNzID0gbmV3IFNlcnZlckltcGwodXJsLmhvc3QsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBzcy50bHNOYW1lID0gdGhpcy5ob3N0bmFtZTtcbiAgICAgICAgICAgICAgICBidWYucHVzaChzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMucmFuZG9taXplKSB7XG4gICAgICAgICAgICBzaHVmZmxlKGJ1Zik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNvbHZlcyA9IGJ1ZjtcbiAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG59XG5jbGFzcyBTZXJ2ZXJzIHtcbiAgICBmaXJzdFNlbGVjdDtcbiAgICBzZXJ2ZXJzO1xuICAgIGN1cnJlbnRTZXJ2ZXI7XG4gICAgdGxzTmFtZTtcbiAgICByYW5kb21pemU7XG4gICAgY29uc3RydWN0b3IobGlzdGVucyA9IFtdLCBvcHRzID0ge30pe1xuICAgICAgICB0aGlzLmZpcnN0U2VsZWN0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZXJ2ZXJzID0gW107XG4gICAgICAgIHRoaXMudGxzTmFtZSA9IFwiXCI7XG4gICAgICAgIHRoaXMucmFuZG9taXplID0gb3B0cy5yYW5kb21pemUgfHwgZmFsc2U7XG4gICAgICAgIGNvbnN0IHVybFBhcnNlRm4gPSBnZXRVcmxQYXJzZUZuKCk7XG4gICAgICAgIGlmIChsaXN0ZW5zKSB7XG4gICAgICAgICAgICBsaXN0ZW5zLmZvckVhY2goKGhwKT0+e1xuICAgICAgICAgICAgICAgIGhwID0gdXJsUGFyc2VGbiA/IHVybFBhcnNlRm4oaHApIDogaHA7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZXJzLnB1c2gobmV3IFNlcnZlckltcGwoaHApKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMucmFuZG9taXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZXJzID0gc2h1ZmZsZSh0aGlzLnNlcnZlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNlcnZlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFNlcnZlcihgJHtERUZBVUxUX0hPU1R9OiR7ZGVmYXVsdFBvcnQoKX1gLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50U2VydmVyID0gdGhpcy5zZXJ2ZXJzWzBdO1xuICAgIH1cbiAgICB1cGRhdGVUTFNOYW1lKCkge1xuICAgICAgICBjb25zdCBjcyA9IHRoaXMuZ2V0Q3VycmVudFNlcnZlcigpO1xuICAgICAgICBpZiAoIWlzSVAoY3MuaG9zdG5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLnRsc05hbWUgPSBjcy5ob3N0bmFtZTtcbiAgICAgICAgICAgIHRoaXMuc2VydmVycy5mb3JFYWNoKChzKT0+e1xuICAgICAgICAgICAgICAgIGlmIChzLmdvc3NpcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHMudGxzTmFtZSA9IHRoaXMudGxzTmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRDdXJyZW50U2VydmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50U2VydmVyO1xuICAgIH1cbiAgICBhZGRTZXJ2ZXIodSwgaW1wbGljaXQgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCB1cmxQYXJzZUZuID0gZ2V0VXJsUGFyc2VGbigpO1xuICAgICAgICB1ID0gdXJsUGFyc2VGbiA/IHVybFBhcnNlRm4odSkgOiB1O1xuICAgICAgICBjb25zdCBzID0gbmV3IFNlcnZlckltcGwodSwgaW1wbGljaXQpO1xuICAgICAgICBpZiAoaXNJUChzLmhvc3RuYW1lKSkge1xuICAgICAgICAgICAgcy50bHNOYW1lID0gdGhpcy50bHNOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VydmVycy5wdXNoKHMpO1xuICAgIH1cbiAgICBzZWxlY3RTZXJ2ZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLmZpcnN0U2VsZWN0KSB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0U2VsZWN0ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50U2VydmVyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLnNlcnZlcnMuc2hpZnQoKTtcbiAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VydmVycy5wdXNoKHQpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2VydmVyID0gdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9XG4gICAgcmVtb3ZlQ3VycmVudFNlcnZlcigpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVTZXJ2ZXIodGhpcy5jdXJyZW50U2VydmVyKTtcbiAgICB9XG4gICAgcmVtb3ZlU2VydmVyKHNlcnZlcikge1xuICAgICAgICBpZiAoc2VydmVyKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuc2VydmVycy5pbmRleE9mKHNlcnZlcik7XG4gICAgICAgICAgICB0aGlzLnNlcnZlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcnZlcnMubGVuZ3RoO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2ZXJzLmxlbmd0aCA/IHRoaXMuc2VydmVyc1swXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0U2VydmVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VydmVycztcbiAgICB9XG4gICAgdXBkYXRlKGluZm8pIHtcbiAgICAgICAgY29uc3QgYWRkZWQgPSBbXTtcbiAgICAgICAgbGV0IGRlbGV0ZWQgPSBbXTtcbiAgICAgICAgY29uc3QgdXJsUGFyc2VGbiA9IGdldFVybFBhcnNlRm4oKTtcbiAgICAgICAgY29uc3QgZGlzY292ZXJlZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKGluZm8uY29ubmVjdF91cmxzICYmIGluZm8uY29ubmVjdF91cmxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGluZm8uY29ubmVjdF91cmxzLmZvckVhY2goKGhwKT0+e1xuICAgICAgICAgICAgICAgIGhwID0gdXJsUGFyc2VGbiA/IHVybFBhcnNlRm4oaHApIDogaHA7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IG5ldyBTZXJ2ZXJJbXBsKGhwLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBkaXNjb3ZlcmVkLnNldChocCwgcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b0RlbGV0ZSA9IFtdO1xuICAgICAgICB0aGlzLnNlcnZlcnMuZm9yRWFjaCgocywgaW5kZXgpPT57XG4gICAgICAgICAgICBjb25zdCB1ID0gcy5saXN0ZW47XG4gICAgICAgICAgICBpZiAocy5nb3NzaXBlZCAmJiB0aGlzLmN1cnJlbnRTZXJ2ZXIubGlzdGVuICE9PSB1ICYmIGRpc2NvdmVyZWQuZ2V0KHUpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0b0RlbGV0ZS5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc2NvdmVyZWQuZGVsZXRlKHUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdG9EZWxldGUucmV2ZXJzZSgpO1xuICAgICAgICB0b0RlbGV0ZS5mb3JFYWNoKChpbmRleCk9PntcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWQgPSB0aGlzLnNlcnZlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIGRlbGV0ZWQgPSBkZWxldGVkLmNvbmNhdChyZW1vdmVkWzBdLmxpc3Rlbik7XG4gICAgICAgIH0pO1xuICAgICAgICBkaXNjb3ZlcmVkLmZvckVhY2goKHYsIGspPT57XG4gICAgICAgICAgICB0aGlzLnNlcnZlcnMucHVzaCh2KTtcbiAgICAgICAgICAgIGFkZGVkLnB1c2goayk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkZWQsXG4gICAgICAgICAgICBkZWxldGVkXG4gICAgICAgIH07XG4gICAgfVxufVxuY2xhc3MgU3Vic2NyaXB0aW9uSW1wbCBleHRlbmRzIFF1ZXVlZEl0ZXJhdG9ySW1wbCB7XG4gICAgc2lkO1xuICAgIHF1ZXVlO1xuICAgIGRyYWluaW5nO1xuICAgIG1heDtcbiAgICBzdWJqZWN0O1xuICAgIGRyYWluZWQ7XG4gICAgcHJvdG9jb2w7XG4gICAgdGltZXI7XG4gICAgaW5mbztcbiAgICBjbGVhbnVwRm47XG4gICAgY2xvc2VkO1xuICAgIHJlcXVlc3RTdWJqZWN0O1xuICAgIGNvbnN0cnVjdG9yKHByb3RvY29sLCBzdWJqZWN0LCBvcHRzID0ge30pe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBleHRlbmQodGhpcywgb3B0cyk7XG4gICAgICAgIHRoaXMucHJvdG9jb2wgPSBwcm90b2NvbDtcbiAgICAgICAgdGhpcy5zdWJqZWN0ID0gc3ViamVjdDtcbiAgICAgICAgdGhpcy5kcmFpbmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5vSXRlcmF0b3IgPSB0eXBlb2Ygb3B0cy5jYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGRlZmVycmVkKCk7XG4gICAgICAgIGlmIChvcHRzLnRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRoaXMudGltZXIgPSB0aW1lb3V0KG9wdHMudGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLnRpbWVyLnRoZW4oKCk9PntcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3AoZXJyKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ub0l0ZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2soZXJyLCB7fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm5vSXRlcmF0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuaXRlckNsb3NlZC50aGVuKCgpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFByZVBvc3RIYW5kbGVycyhvcHRzKSB7XG4gICAgICAgIGlmICh0aGlzLm5vSXRlcmF0b3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHVjID0gdGhpcy5jYWxsYmFjaztcbiAgICAgICAgICAgIGNvbnN0IGluZ2VzdGlvbiA9IG9wdHMuaW5nZXN0aW9uRmlsdGVyRm4gPyBvcHRzLmluZ2VzdGlvbkZpbHRlckZuIDogKCk9PntcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpbmdlc3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHByb3RvY29sOiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyID0gb3B0cy5wcm90b2NvbEZpbHRlckZuID8gb3B0cy5wcm90b2NvbEZpbHRlckZuIDogKCk9PntcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBkaXNwYXRjaGVkID0gb3B0cy5kaXNwYXRjaGVkRm4gPyBvcHRzLmRpc3BhdGNoZWRGbiA6ICgpPT57fTtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sgPSAoZXJyLCBtc2cpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpbmdlc3QgIH0gPSBpbmdlc3Rpb24obXNnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWluZ2VzdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIobXNnKSkge1xuICAgICAgICAgICAgICAgICAgICB1YyhlcnIsIG1zZyk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoZWQobXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wcm90b2NvbEZpbHRlckZuID0gb3B0cy5wcm90b2NvbEZpbHRlckZuO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaGVkRm4gPSBvcHRzLmRpc3BhdGNoZWRGbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYWxsYmFjayhlcnIsIG1zZykge1xuICAgICAgICB0aGlzLmNhbmNlbFRpbWVvdXQoKTtcbiAgICAgICAgZXJyID8gdGhpcy5zdG9wKGVycikgOiB0aGlzLnB1c2gobXNnKTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0Nsb3NlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbFRpbWVvdXQoKTtcbiAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2xlYW51cEZuKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhbnVwRm4odGhpcywgdGhpcy5pbmZvKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChfZXJyKSB7fVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jbG9zZWQucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlKG1heCkge1xuICAgICAgICB0aGlzLnByb3RvY29sLnVuc3Vic2NyaWJlKHRoaXMsIG1heCk7XG4gICAgfVxuICAgIGNhbmNlbFRpbWVvdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVyLmNhbmNlbCgpO1xuICAgICAgICAgICAgdGhpcy50aW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkcmFpbigpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvdG9jb2wuaXNDbG9zZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLkNvbm5lY3Rpb25DbG9zZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0Nsb3NlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoTmF0c0Vycm9yLmVycm9yRm9yQ29kZShFcnJvckNvZGUuU3ViQ2xvc2VkKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmRyYWluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucHJvdG9jb2wudW5zdWIodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmRyYWluZWQgPSB0aGlzLnByb3RvY29sLmZsdXNoKGRlZmVycmVkKCkpO1xuICAgICAgICAgICAgdGhpcy5kcmFpbmVkLnRoZW4oKCk9PntcbiAgICAgICAgICAgICAgICB0aGlzLnByb3RvY29sLnN1YnNjcmlwdGlvbnMuY2FuY2VsKHRoaXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhaW5lZDtcbiAgICB9XG4gICAgaXNEcmFpbmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhaW5pbmc7XG4gICAgfVxuICAgIGlzQ2xvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb25lO1xuICAgIH1cbiAgICBnZXRTdWJqZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJqZWN0O1xuICAgIH1cbiAgICBnZXRNYXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1heDtcbiAgICB9XG4gICAgZ2V0SUQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpZDtcbiAgICB9XG59XG5jbGFzcyBTdWJzY3JpcHRpb25zIHtcbiAgICBtdXg7XG4gICAgc3VicztcbiAgICBzaWRDb3VudGVyO1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuc2lkQ291bnRlciA9IDA7XG4gICAgICAgIHRoaXMubXV4ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdWJzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJzLnNpemU7XG4gICAgfVxuICAgIGFkZChzKSB7XG4gICAgICAgIHRoaXMuc2lkQ291bnRlcisrO1xuICAgICAgICBzLnNpZCA9IHRoaXMuc2lkQ291bnRlcjtcbiAgICAgICAgdGhpcy5zdWJzLnNldChzLnNpZCwgcyk7XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICBzZXRNdXgocykge1xuICAgICAgICB0aGlzLm11eCA9IHM7XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICBnZXRNdXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm11eDtcbiAgICB9XG4gICAgZ2V0KHNpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJzLmdldChzaWQpO1xuICAgIH1cbiAgICByZXN1YihzKSB7XG4gICAgICAgIHRoaXMuc2lkQ291bnRlcisrO1xuICAgICAgICB0aGlzLnN1YnMuZGVsZXRlKHMuc2lkKTtcbiAgICAgICAgcy5zaWQgPSB0aGlzLnNpZENvdW50ZXI7XG4gICAgICAgIHRoaXMuc3Vicy5zZXQocy5zaWQsIHMpO1xuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgYWxsKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnN1YnMudmFsdWVzKCkpO1xuICAgIH1cbiAgICBjYW5jZWwocykge1xuICAgICAgICBpZiAocykge1xuICAgICAgICAgICAgcy5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5zdWJzLmRlbGV0ZShzLnNpZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlRXJyb3IoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgJiYgZXJyLnBlcm1pc3Npb25Db250ZXh0KSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSBlcnIucGVybWlzc2lvbkNvbnRleHQ7XG4gICAgICAgICAgICBjb25zdCBzdWJzID0gdGhpcy5hbGwoKTtcbiAgICAgICAgICAgIGxldCBzdWI7XG4gICAgICAgICAgICBpZiAoY3R4Lm9wZXJhdGlvbiA9PT0gXCJzdWJzY3JpcHRpb25cIikge1xuICAgICAgICAgICAgICAgIHN1YiA9IHN1YnMuZmluZCgocyk9PntcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMuc3ViamVjdCA9PT0gY3R4LnN1YmplY3Q7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3R4Lm9wZXJhdGlvbiA9PT0gXCJwdWJsaXNoXCIpIHtcbiAgICAgICAgICAgICAgICBzdWIgPSBzdWJzLmZpbmQoKHMpPT57XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzLnJlcXVlc3RTdWJqZWN0ID09PSBjdHguc3ViamVjdDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdWIpIHtcbiAgICAgICAgICAgICAgICBzdWIuY2FsbGJhY2soZXJyLCB7fSk7XG4gICAgICAgICAgICAgICAgc3ViLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YiAhPT0gdGhpcy5tdXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5zdWJzLmZvckVhY2goKHN1Yik9PntcbiAgICAgICAgICAgIHN1Yi5jbG9zZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBIZWFydGJlYXQge1xuICAgIHBoO1xuICAgIGludGVydmFsO1xuICAgIG1heE91dDtcbiAgICB0aW1lcjtcbiAgICBwZW5kaW5ncztcbiAgICBjb25zdHJ1Y3RvcihwaCwgaW50ZXJ2YWwsIG1heE91dCl7XG4gICAgICAgIHRoaXMucGggPSBwaDtcbiAgICAgICAgdGhpcy5pbnRlcnZhbCA9IGludGVydmFsO1xuICAgICAgICB0aGlzLm1heE91dCA9IG1heE91dDtcbiAgICAgICAgdGhpcy5wZW5kaW5ncyA9IFtdO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGUoKTtcbiAgICB9XG4gICAgY2FuY2VsKHN0YWxlKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgICAgICB0aGlzLnRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICAgIGlmIChzdGFsZSkge1xuICAgICAgICAgICAgdGhpcy5waC5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3NjaGVkdWxlKCkge1xuICAgICAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgdGhpcy5waC5kaXNwYXRjaFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgdHlwZTogRGVidWdFdmVudHMuUGluZ1RpbWVyLFxuICAgICAgICAgICAgICAgIGRhdGE6IGAke3RoaXMucGVuZGluZ3MubGVuZ3RoICsgMX1gXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdzLmxlbmd0aCA9PT0gdGhpcy5tYXhPdXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbCh0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwaW5nID0gZGVmZXJyZWQoKTtcbiAgICAgICAgICAgIHRoaXMucGguZmx1c2gocGluZykudGhlbigoKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICAgICAgICB9KS5jYXRjaCgoKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ3MucHVzaChwaW5nKTtcbiAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlKCk7XG4gICAgICAgIH0sIHRoaXMuaW50ZXJ2YWwpO1xuICAgIH1cbiAgICBfcmVzZXQoKSB7XG4gICAgICAgIHRoaXMucGVuZGluZ3MgPSB0aGlzLnBlbmRpbmdzLmZpbHRlcigocCk9PntcbiAgICAgICAgICAgIGNvbnN0IGQgPSBwO1xuICAgICAgICAgICAgZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIEFzc2VydGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1zZyl7XG4gICAgICAgIHN1cGVyKG1zZyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiQXNzZXJ0aW9uRXJyb3JcIjtcbiAgICB9XG59XG5mdW5jdGlvbiBhc3NlcnQoY29uZCwgbXNnID0gXCJBc3NlcnRpb24gZmFpbGVkLlwiKSB7XG4gICAgaWYgKCFjb25kKSB7XG4gICAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihtc2cpO1xuICAgIH1cbn1cbmNvbnN0IE1JTl9SRUFEID0gMzIgKiAxMDI0O1xuY29uc3QgTUFYX1NJWkUgPSAyICoqIDMyIC0gMjtcbmZ1bmN0aW9uIGNvcHkoc3JjLCBkc3QsIG9mZiA9IDApIHtcbiAgICBjb25zdCByID0gZHN0LmJ5dGVMZW5ndGggLSBvZmY7XG4gICAgaWYgKHNyYy5ieXRlTGVuZ3RoID4gcikge1xuICAgICAgICBzcmMgPSBzcmMuc3ViYXJyYXkoMCwgcik7XG4gICAgfVxuICAgIGRzdC5zZXQoc3JjLCBvZmYpO1xuICAgIHJldHVybiBzcmMuYnl0ZUxlbmd0aDtcbn1cbmNsYXNzIERlbm9CdWZmZXIge1xuICAgIF9idWY7XG4gICAgX29mZjtcbiAgICBjb25zdHJ1Y3RvcihhYil7XG4gICAgICAgIHRoaXMuX29mZiA9IDA7XG4gICAgICAgIGlmIChhYiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9idWYgPSBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9idWYgPSBuZXcgVWludDhBcnJheShhYik7XG4gICAgfVxuICAgIGJ5dGVzKG9wdGlvbnMgPSB7XG4gICAgICAgIGNvcHk6IHRydWVcbiAgICB9KSB7XG4gICAgICAgIGlmIChvcHRpb25zLmNvcHkgPT09IGZhbHNlKSByZXR1cm4gdGhpcy5fYnVmLnN1YmFycmF5KHRoaXMuX29mZik7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWYuc2xpY2UodGhpcy5fb2ZmKTtcbiAgICB9XG4gICAgZW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWYuYnl0ZUxlbmd0aCA8PSB0aGlzLl9vZmY7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWYuYnl0ZUxlbmd0aCAtIHRoaXMuX29mZjtcbiAgICB9XG4gICAgZ2V0IGNhcGFjaXR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnVmLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICB0cnVuY2F0ZShuKSB7XG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4gPCAwIHx8IG4gPiB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJieXRlcy5CdWZmZXI6IHRydW5jYXRpb24gb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jlc2xpY2UodGhpcy5fb2ZmICsgbik7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLl9yZXNsaWNlKDApO1xuICAgICAgICB0aGlzLl9vZmYgPSAwO1xuICAgIH1cbiAgICBfdHJ5R3Jvd0J5UmVzbGljZShuKSB7XG4gICAgICAgIGNvbnN0IGwgPSB0aGlzLl9idWYuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKG4gPD0gdGhpcy5jYXBhY2l0eSAtIGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2xpY2UobCArIG4pO1xuICAgICAgICAgICAgcmV0dXJuIGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBfcmVzbGljZShsZW4pIHtcbiAgICAgICAgYXNzZXJ0KGxlbiA8PSB0aGlzLl9idWYuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB0aGlzLl9idWYgPSBuZXcgVWludDhBcnJheSh0aGlzLl9idWYuYnVmZmVyLCAwLCBsZW4pO1xuICAgIH1cbiAgICByZWFkQnl0ZSgpIHtcbiAgICAgICAgY29uc3QgYSA9IG5ldyBVaW50OEFycmF5KDEpO1xuICAgICAgICBpZiAodGhpcy5yZWFkKGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gYVswXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmVhZChwKSB7XG4gICAgICAgIGlmICh0aGlzLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIGlmIChwLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5yZWFkID0gY29weSh0aGlzLl9idWYuc3ViYXJyYXkodGhpcy5fb2ZmKSwgcCk7XG4gICAgICAgIHRoaXMuX29mZiArPSBucmVhZDtcbiAgICAgICAgcmV0dXJuIG5yZWFkO1xuICAgIH1cbiAgICB3cml0ZUJ5dGUobikge1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZShVaW50OEFycmF5Lm9mKG4pKTtcbiAgICB9XG4gICAgd3JpdGVTdHJpbmcocykge1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZShURS5lbmNvZGUocykpO1xuICAgIH1cbiAgICB3cml0ZShwKSB7XG4gICAgICAgIGNvbnN0IG0gPSB0aGlzLl9ncm93KHAuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiBjb3B5KHAsIHRoaXMuX2J1ZiwgbSk7XG4gICAgfVxuICAgIF9ncm93KG4pIHtcbiAgICAgICAgY29uc3QgbSA9IHRoaXMubGVuZ3RoO1xuICAgICAgICBpZiAobSA9PT0gMCAmJiB0aGlzLl9vZmYgIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpID0gdGhpcy5fdHJ5R3Jvd0J5UmVzbGljZShuKTtcbiAgICAgICAgaWYgKGkgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYyA9IHRoaXMuY2FwYWNpdHk7XG4gICAgICAgIGlmIChuIDw9IE1hdGguZmxvb3IoYyAvIDIpIC0gbSkge1xuICAgICAgICAgICAgY29weSh0aGlzLl9idWYuc3ViYXJyYXkodGhpcy5fb2ZmKSwgdGhpcy5fYnVmKTtcbiAgICAgICAgfSBlbHNlIGlmIChjICsgbiA+IE1BWF9TSVpFKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYnVmZmVyIGNhbm5vdCBiZSBncm93biBiZXlvbmQgdGhlIG1heGltdW0gc2l6ZS5cIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShNYXRoLm1pbigyICogYyArIG4sIE1BWF9TSVpFKSk7XG4gICAgICAgICAgICBjb3B5KHRoaXMuX2J1Zi5zdWJhcnJheSh0aGlzLl9vZmYpLCBidWYpO1xuICAgICAgICAgICAgdGhpcy5fYnVmID0gYnVmO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29mZiA9IDA7XG4gICAgICAgIHRoaXMuX3Jlc2xpY2UoTWF0aC5taW4obSArIG4sIE1BWF9TSVpFKSk7XG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cbiAgICBncm93KG4pIHtcbiAgICAgICAgaWYgKG4gPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkJ1ZmZlci5fZ3JvdzogbmVnYXRpdmUgY291bnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbSA9IHRoaXMuX2dyb3cobik7XG4gICAgICAgIHRoaXMuX3Jlc2xpY2UobSk7XG4gICAgfVxuICAgIHJlYWRGcm9tKHIpIHtcbiAgICAgICAgbGV0IG4gPSAwO1xuICAgICAgICBjb25zdCB0bXAgPSBuZXcgVWludDhBcnJheShNSU5fUkVBRCk7XG4gICAgICAgIHdoaWxlKHRydWUpe1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkR3JvdyA9IHRoaXMuY2FwYWNpdHkgLSB0aGlzLmxlbmd0aCA8IE1JTl9SRUFEO1xuICAgICAgICAgICAgY29uc3QgYnVmID0gc2hvdWxkR3JvdyA/IHRtcCA6IG5ldyBVaW50OEFycmF5KHRoaXMuX2J1Zi5idWZmZXIsIHRoaXMubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IG5yZWFkID0gci5yZWFkKGJ1Zik7XG4gICAgICAgICAgICBpZiAobnJlYWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaG91bGRHcm93KSB0aGlzLndyaXRlKGJ1Zi5zdWJhcnJheSgwLCBucmVhZCkpO1xuICAgICAgICAgICAgZWxzZSB0aGlzLl9yZXNsaWNlKHRoaXMubGVuZ3RoICsgbnJlYWQpO1xuICAgICAgICAgICAgbiArPSBucmVhZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbnZhciBLaW5kO1xuKGZ1bmN0aW9uKEtpbmQpIHtcbiAgICBLaW5kW0tpbmRbXCJPS1wiXSA9IDBdID0gXCJPS1wiO1xuICAgIEtpbmRbS2luZFtcIkVSUlwiXSA9IDFdID0gXCJFUlJcIjtcbiAgICBLaW5kW0tpbmRbXCJNU0dcIl0gPSAyXSA9IFwiTVNHXCI7XG4gICAgS2luZFtLaW5kW1wiSU5GT1wiXSA9IDNdID0gXCJJTkZPXCI7XG4gICAgS2luZFtLaW5kW1wiUElOR1wiXSA9IDRdID0gXCJQSU5HXCI7XG4gICAgS2luZFtLaW5kW1wiUE9OR1wiXSA9IDVdID0gXCJQT05HXCI7XG59KShLaW5kIHx8IChLaW5kID0ge30pKTtcbmZ1bmN0aW9uIG5ld01zZ0FyZygpIHtcbiAgICBjb25zdCBtYSA9IHt9O1xuICAgIG1hLnNpZCA9IC0xO1xuICAgIG1hLmhkciA9IC0xO1xuICAgIG1hLnNpemUgPSAtMTtcbiAgICByZXR1cm4gbWE7XG59XG5jb25zdCBBU0NJSV8wID0gNDg7XG5jbGFzcyBQYXJzZXIge1xuICAgIGRpc3BhdGNoZXI7XG4gICAgc3RhdGU7XG4gICAgYXM7XG4gICAgZHJvcDtcbiAgICBoZHI7XG4gICAgbWE7XG4gICAgYXJnQnVmO1xuICAgIG1zZ0J1ZjtcbiAgICBjb25zdHJ1Y3RvcihkaXNwYXRjaGVyKXtcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyID0gZGlzcGF0Y2hlcjtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX1NUQVJUO1xuICAgICAgICB0aGlzLmFzID0gMDtcbiAgICAgICAgdGhpcy5kcm9wID0gMDtcbiAgICAgICAgdGhpcy5oZHIgPSAwO1xuICAgIH1cbiAgICBwYXJzZShidWYpIHtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBjb25zdCBiID0gYnVmW2ldO1xuICAgICAgICAgICAgc3dpdGNoKHRoaXMuc3RhdGUpe1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfU1RBUlQ6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaChiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuTTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MubTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfTTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhkciA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWEgPSBuZXdNc2dBcmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuSDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuaDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfSDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhkciA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYSA9IG5ld01zZ0FyZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5QOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5wOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9QO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5QTFVTOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9QTFVTO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5NSU5VUzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfTUlOVVM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLkk6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLmk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX0k7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChidWYuc3ViYXJyYXkoaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfSDpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5NOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5tOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9NO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmZhaWwoYnVmLnN1YmFycmF5KGkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLk9QX006XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaChiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuUzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfTVM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChidWYuc3ViYXJyYXkoaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfTVM6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaChiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuRzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuZzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfTVNHO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmZhaWwoYnVmLnN1YmFycmF5KGkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLk9QX01TRzpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5TUEFDRTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuVEFCOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9NU0dfU1BDO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmZhaWwoYnVmLnN1YmFycmF5KGkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLk9QX01TR19TUEM6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaChiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuU1BBQ0U6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLlRBQjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk1TR19BUkc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcyA9IGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5NU0dfQVJHOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goYil7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLkNSOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLk5MOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJnID0gdGhpcy5hcmdCdWYgPyB0aGlzLmFyZ0J1Zi5ieXRlcygpIDogYnVmLnN1YmFycmF5KHRoaXMuYXMsIGkgLSB0aGlzLmRyb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NNc2dBcmdzKGFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXMgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk1TR19QQVlMT0FEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gdGhpcy5hcyArIHRoaXMubWEuc2l6ZSAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXJnQnVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXJnQnVmLndyaXRlQnl0ZShiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5NU0dfUEFZTE9BRDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubXNnQnVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tc2dCdWYubGVuZ3RoID49IHRoaXMubWEuc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLm1zZ0J1Zi5ieXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHk6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaGVyLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBLaW5kLk1TRyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXNnOiB0aGlzLm1hLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcmdCdWYgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tc2dCdWYgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk1TR19FTkQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0b0NvcHkgPSB0aGlzLm1hLnNpemUgLSB0aGlzLm1zZ0J1Zi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXZhaWwgPSBidWYubGVuZ3RoIC0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXZhaWwgPCB0b0NvcHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9Db3B5ID0gYXZhaWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b0NvcHkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubXNnQnVmLndyaXRlKGJ1Zi5zdWJhcnJheShpLCBpICsgdG9Db3B5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBpICsgdG9Db3B5IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1zZ0J1Zi53cml0ZUJ5dGUoYik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgLSB0aGlzLmFzID49IHRoaXMubWEuc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaGVyLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEtpbmQuTVNHLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1zZzogdGhpcy5tYSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBidWYuc3ViYXJyYXkodGhpcy5hcywgaSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcmdCdWYgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1zZ0J1ZiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5NU0dfRU5EO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuTVNHX0VORDpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5OTDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3AgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXMgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfU1RBUlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfUExVUzpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5POlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5vOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9QTFVTX087XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChidWYuc3ViYXJyYXkoaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfUExVU19POlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goYil7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLks6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLms6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX1BMVVNfT0s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChidWYuc3ViYXJyYXkoaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfUExVU19PSzpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5OTDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoZXIucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEtpbmQuT0tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3AgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9TVEFSVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLk9QX01JTlVTOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goYil7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLkU6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLmU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX01JTlVTX0U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChidWYuc3ViYXJyYXkoaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfTUlOVVNfRTpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5SOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5yOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9NSU5VU19FUjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGJ1Zi5zdWJhcnJheShpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5PUF9NSU5VU19FUjpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5SOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5yOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9NSU5VU19FUlI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChidWYuc3ViYXJyYXkoaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfTUlOVVNfRVJSOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goYil7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLlNQQUNFOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5UQUI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX01JTlVTX0VSUl9TUEM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChidWYuc3ViYXJyYXkoaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfTUlOVVNfRVJSX1NQQzpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5TUEFDRTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuVEFCOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuTUlOVVNfRVJSX0FSRztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFzID0gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLk1JTlVTX0VSUl9BUkc6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaChiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuQ1I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuTkw6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYXJnMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXJnQnVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcxID0gdGhpcy5hcmdCdWYuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXJnQnVmID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnMSA9IGJ1Zi5zdWJhcnJheSh0aGlzLmFzLCBpIC0gdGhpcy5kcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoZXIucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBLaW5kLkVSUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGFyZzFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXMgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX1NUQVJUO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFyZ0J1Zikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFyZ0J1Zi53cml0ZShVaW50OEFycmF5Lm9mKGIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5PUF9QOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goYil7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLkk6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLmk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX1BJO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5POlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5vOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9QTztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGJ1Zi5zdWJhcnJheShpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5PUF9QTzpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5OOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5uOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9QT047XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChidWYuc3ViYXJyYXkoaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfUE9OOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goYil7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLkc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLmc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX1BPTkc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChidWYuc3ViYXJyYXkoaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfUE9ORzpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5OTDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoZXIucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEtpbmQuUE9OR1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX1NUQVJUO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfUEk6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaChiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuTjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MubjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfUElOO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmZhaWwoYnVmLnN1YmFycmF5KGkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLk9QX1BJTjpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5HOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9QSU5HO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmZhaWwoYnVmLnN1YmFycmF5KGkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLk9QX1BJTkc6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaChiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuTkw6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaGVyLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBLaW5kLlBJTkdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3AgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9TVEFSVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLk9QX0k6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaChiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuTjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MubjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfSU47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChidWYuc3ViYXJyYXkoaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfSU46XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaChiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuRjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuZjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfSU5GO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmZhaWwoYnVmLnN1YmFycmF5KGkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLk9QX0lORjpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5POlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5vOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9JTkZPO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmZhaWwoYnVmLnN1YmFycmF5KGkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLk9QX0lORk86XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaChiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuU1BBQ0U6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLlRBQjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfSU5GT19TUEM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChidWYuc3ViYXJyYXkoaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfSU5GT19TUEM6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaChiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuU1BBQ0U6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLlRBQjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklORk9fQVJHO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXMgPSBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuSU5GT19BUkc6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaChiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuQ1I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuTkw6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYXJnMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXJnQnVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcyID0gdGhpcy5hcmdCdWYuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXJnQnVmID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnMiA9IGJ1Zi5zdWJhcnJheSh0aGlzLmFzLCBpIC0gdGhpcy5kcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoZXIucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBLaW5kLklORk8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBhcmcyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3AgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFzID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9TVEFSVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hcmdCdWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcmdCdWYud3JpdGVCeXRlKGIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmZhaWwoYnVmLnN1YmFycmF5KGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoKHRoaXMuc3RhdGUgPT09IFN0YXRlLk1TR19BUkcgfHwgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuTUlOVVNfRVJSX0FSRyB8fCB0aGlzLnN0YXRlID09PSBTdGF0ZS5JTkZPX0FSRykgJiYgIXRoaXMuYXJnQnVmKSB7XG4gICAgICAgICAgICB0aGlzLmFyZ0J1ZiA9IG5ldyBEZW5vQnVmZmVyKGJ1Zi5zdWJhcnJheSh0aGlzLmFzLCBpIC0gdGhpcy5kcm9wKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLk1TR19QQVlMT0FEICYmICF0aGlzLm1zZ0J1Zikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFyZ0J1Zikge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvbmVNc2dBcmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubXNnQnVmID0gbmV3IERlbm9CdWZmZXIoYnVmLnN1YmFycmF5KHRoaXMuYXMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbG9uZU1zZ0FyZygpIHtcbiAgICAgICAgY29uc3QgcyA9IHRoaXMubWEuc3ViamVjdC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHIgPSB0aGlzLm1hLnJlcGx5ID8gdGhpcy5tYS5yZXBseS5sZW5ndGggOiAwO1xuICAgICAgICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShzICsgcik7XG4gICAgICAgIGJ1Zi5zZXQodGhpcy5tYS5zdWJqZWN0KTtcbiAgICAgICAgaWYgKHRoaXMubWEucmVwbHkpIHtcbiAgICAgICAgICAgIGJ1Zi5zZXQodGhpcy5tYS5yZXBseSwgcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcmdCdWYgPSBuZXcgRGVub0J1ZmZlcihidWYpO1xuICAgICAgICB0aGlzLm1hLnN1YmplY3QgPSBidWYuc3ViYXJyYXkoMCwgcyk7XG4gICAgICAgIGlmICh0aGlzLm1hLnJlcGx5KSB7XG4gICAgICAgICAgICB0aGlzLm1hLnJlcGx5ID0gYnVmLnN1YmFycmF5KHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3NNc2dBcmdzKGFyZykge1xuICAgICAgICBpZiAodGhpcy5oZHIgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc0hlYWRlck1zZ0FyZ3MoYXJnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcmdzID0gW107XG4gICAgICAgIGxldCBzdGFydCA9IC0xO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgYXJnLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGNvbnN0IGIgPSBhcmdbaV07XG4gICAgICAgICAgICBzd2l0Y2goYil7XG4gICAgICAgICAgICAgICAgY2FzZSBjYy5TUEFDRTpcbiAgICAgICAgICAgICAgICBjYXNlIGNjLlRBQjpcbiAgICAgICAgICAgICAgICBjYXNlIGNjLkNSOlxuICAgICAgICAgICAgICAgIGNhc2UgY2MuTkw6XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goYXJnLnN1YmFycmF5KHN0YXJ0LCBpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA+PSAwKSB7XG4gICAgICAgICAgICBhcmdzLnB1c2goYXJnLnN1YmFycmF5KHN0YXJ0KSk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoKGFyZ3MubGVuZ3RoKXtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICB0aGlzLm1hLnN1YmplY3QgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIHRoaXMubWEuc2lkID0gdGhpcy5wcm90b1BhcnNlSW50KGFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgIHRoaXMubWEucmVwbHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5tYS5zaXplID0gdGhpcy5wcm90b1BhcnNlSW50KGFyZ3NbMl0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHRoaXMubWEuc3ViamVjdCA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgdGhpcy5tYS5zaWQgPSB0aGlzLnByb3RvUGFyc2VJbnQoYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYS5yZXBseSA9IGFyZ3NbMl07XG4gICAgICAgICAgICAgICAgdGhpcy5tYS5zaXplID0gdGhpcy5wcm90b1BhcnNlSW50KGFyZ3NbM10pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmZhaWwoYXJnLCBcInByb2Nlc3NNc2dBcmdzIFBhcnNlIEVycm9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hLnNpZCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChhcmcsIFwicHJvY2Vzc01zZ0FyZ3MgQmFkIG9yIE1pc3NpbmcgU2lkIEVycm9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hLnNpemUgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmZhaWwoYXJnLCBcInByb2Nlc3NNc2dBcmdzIEJhZCBvciBNaXNzaW5nIFNpemUgRXJyb3JcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmFpbChkYXRhLCBsYWJlbCA9IFwiXCIpIHtcbiAgICAgICAgaWYgKCFsYWJlbCkge1xuICAgICAgICAgICAgbGFiZWwgPSBgcGFyc2UgZXJyb3IgWyR7dGhpcy5zdGF0ZX1dYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhYmVsID0gYCR7bGFiZWx9IFske3RoaXMuc3RhdGV9XWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgJHtsYWJlbH06ICR7VEQuZGVjb2RlKGRhdGEpfWApO1xuICAgIH1cbiAgICBwcm9jZXNzSGVhZGVyTXNnQXJncyhhcmcpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IFtdO1xuICAgICAgICBsZXQgc3RhcnQgPSAtMTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGFyZy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBjb25zdCBiID0gYXJnW2ldO1xuICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgIGNhc2UgY2MuU1BBQ0U6XG4gICAgICAgICAgICAgICAgY2FzZSBjYy5UQUI6XG4gICAgICAgICAgICAgICAgY2FzZSBjYy5DUjpcbiAgICAgICAgICAgICAgICBjYXNlIGNjLk5MOlxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGFyZy5zdWJhcnJheShzdGFydCwgaSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgYXJncy5wdXNoKGFyZy5zdWJhcnJheShzdGFydCkpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaChhcmdzLmxlbmd0aCl7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgdGhpcy5tYS5zdWJqZWN0ID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hLnNpZCA9IHRoaXMucHJvdG9QYXJzZUludChhcmdzWzFdKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hLnJlcGx5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMubWEuaGRyID0gdGhpcy5wcm90b1BhcnNlSW50KGFyZ3NbMl0pO1xuICAgICAgICAgICAgICAgIHRoaXMubWEuc2l6ZSA9IHRoaXMucHJvdG9QYXJzZUludChhcmdzWzNdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICB0aGlzLm1hLnN1YmplY3QgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIHRoaXMubWEuc2lkID0gdGhpcy5wcm90b1BhcnNlSW50KGFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgIHRoaXMubWEucmVwbHkgPSBhcmdzWzJdO1xuICAgICAgICAgICAgICAgIHRoaXMubWEuaGRyID0gdGhpcy5wcm90b1BhcnNlSW50KGFyZ3NbM10pO1xuICAgICAgICAgICAgICAgIHRoaXMubWEuc2l6ZSA9IHRoaXMucHJvdG9QYXJzZUludChhcmdzWzRdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGFyZywgXCJwcm9jZXNzSGVhZGVyTXNnQXJncyBQYXJzZSBFcnJvclwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYS5zaWQgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmZhaWwoYXJnLCBcInByb2Nlc3NIZWFkZXJNc2dBcmdzIEJhZCBvciBNaXNzaW5nIFNpZCBFcnJvclwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYS5oZHIgPCAwIHx8IHRoaXMubWEuaGRyID4gdGhpcy5tYS5zaXplKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmZhaWwoYXJnLCBcInByb2Nlc3NIZWFkZXJNc2dBcmdzIEJhZCBvciBNaXNzaW5nIEhlYWRlciBTaXplIEVycm9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hLnNpemUgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmZhaWwoYXJnLCBcInByb2Nlc3NIZWFkZXJNc2dBcmdzIEJhZCBvciBNaXNzaW5nIFNpemUgRXJyb3JcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvdG9QYXJzZUludChhKSB7XG4gICAgICAgIGlmIChhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuID0gMDtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgaWYgKGFbaV0gPCA0OCB8fCBhW2ldID4gNTcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuID0gbiAqIDEwICsgKGFbaV0gLSBBU0NJSV8wKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG59XG52YXIgU3RhdGU7XG4oZnVuY3Rpb24oU3RhdGUpIHtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX1NUQVJUXCJdID0gMF0gPSBcIk9QX1NUQVJUXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJPUF9QTFVTXCJdID0gMV0gPSBcIk9QX1BMVVNcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX1BMVVNfT1wiXSA9IDJdID0gXCJPUF9QTFVTX09cIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX1BMVVNfT0tcIl0gPSAzXSA9IFwiT1BfUExVU19PS1wiO1xuICAgIFN0YXRlW1N0YXRlW1wiT1BfTUlOVVNcIl0gPSA0XSA9IFwiT1BfTUlOVVNcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX01JTlVTX0VcIl0gPSA1XSA9IFwiT1BfTUlOVVNfRVwiO1xuICAgIFN0YXRlW1N0YXRlW1wiT1BfTUlOVVNfRVJcIl0gPSA2XSA9IFwiT1BfTUlOVVNfRVJcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX01JTlVTX0VSUlwiXSA9IDddID0gXCJPUF9NSU5VU19FUlJcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX01JTlVTX0VSUl9TUENcIl0gPSA4XSA9IFwiT1BfTUlOVVNfRVJSX1NQQ1wiO1xuICAgIFN0YXRlW1N0YXRlW1wiTUlOVVNfRVJSX0FSR1wiXSA9IDldID0gXCJNSU5VU19FUlJfQVJHXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJPUF9NXCJdID0gMTBdID0gXCJPUF9NXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJPUF9NU1wiXSA9IDExXSA9IFwiT1BfTVNcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX01TR1wiXSA9IDEyXSA9IFwiT1BfTVNHXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJPUF9NU0dfU1BDXCJdID0gMTNdID0gXCJPUF9NU0dfU1BDXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJNU0dfQVJHXCJdID0gMTRdID0gXCJNU0dfQVJHXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJNU0dfUEFZTE9BRFwiXSA9IDE1XSA9IFwiTVNHX1BBWUxPQURcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk1TR19FTkRcIl0gPSAxNl0gPSBcIk1TR19FTkRcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX0hcIl0gPSAxN10gPSBcIk9QX0hcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX1BcIl0gPSAxOF0gPSBcIk9QX1BcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX1BJXCJdID0gMTldID0gXCJPUF9QSVwiO1xuICAgIFN0YXRlW1N0YXRlW1wiT1BfUElOXCJdID0gMjBdID0gXCJPUF9QSU5cIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX1BJTkdcIl0gPSAyMV0gPSBcIk9QX1BJTkdcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX1BPXCJdID0gMjJdID0gXCJPUF9QT1wiO1xuICAgIFN0YXRlW1N0YXRlW1wiT1BfUE9OXCJdID0gMjNdID0gXCJPUF9QT05cIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX1BPTkdcIl0gPSAyNF0gPSBcIk9QX1BPTkdcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX0lcIl0gPSAyNV0gPSBcIk9QX0lcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX0lOXCJdID0gMjZdID0gXCJPUF9JTlwiO1xuICAgIFN0YXRlW1N0YXRlW1wiT1BfSU5GXCJdID0gMjddID0gXCJPUF9JTkZcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX0lORk9cIl0gPSAyOF0gPSBcIk9QX0lORk9cIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX0lORk9fU1BDXCJdID0gMjldID0gXCJPUF9JTkZPX1NQQ1wiO1xuICAgIFN0YXRlW1N0YXRlW1wiSU5GT19BUkdcIl0gPSAzMF0gPSBcIklORk9fQVJHXCI7XG59KShTdGF0ZSB8fCAoU3RhdGUgPSB7fSkpO1xudmFyIGNjO1xuKGZ1bmN0aW9uKGNjKSB7XG4gICAgY2NbY2NbXCJDUlwiXSA9IFwiXFxyXCIuY2hhckNvZGVBdCgwKV0gPSBcIkNSXCI7XG4gICAgY2NbY2NbXCJFXCJdID0gXCJFXCIuY2hhckNvZGVBdCgwKV0gPSBcIkVcIjtcbiAgICBjY1tjY1tcImVcIl0gPSBcImVcIi5jaGFyQ29kZUF0KDApXSA9IFwiZVwiO1xuICAgIGNjW2NjW1wiRlwiXSA9IFwiRlwiLmNoYXJDb2RlQXQoMCldID0gXCJGXCI7XG4gICAgY2NbY2NbXCJmXCJdID0gXCJmXCIuY2hhckNvZGVBdCgwKV0gPSBcImZcIjtcbiAgICBjY1tjY1tcIkdcIl0gPSBcIkdcIi5jaGFyQ29kZUF0KDApXSA9IFwiR1wiO1xuICAgIGNjW2NjW1wiZ1wiXSA9IFwiZ1wiLmNoYXJDb2RlQXQoMCldID0gXCJnXCI7XG4gICAgY2NbY2NbXCJIXCJdID0gXCJIXCIuY2hhckNvZGVBdCgwKV0gPSBcIkhcIjtcbiAgICBjY1tjY1tcImhcIl0gPSBcImhcIi5jaGFyQ29kZUF0KDApXSA9IFwiaFwiO1xuICAgIGNjW2NjW1wiSVwiXSA9IFwiSVwiLmNoYXJDb2RlQXQoMCldID0gXCJJXCI7XG4gICAgY2NbY2NbXCJpXCJdID0gXCJpXCIuY2hhckNvZGVBdCgwKV0gPSBcImlcIjtcbiAgICBjY1tjY1tcIktcIl0gPSBcIktcIi5jaGFyQ29kZUF0KDApXSA9IFwiS1wiO1xuICAgIGNjW2NjW1wia1wiXSA9IFwia1wiLmNoYXJDb2RlQXQoMCldID0gXCJrXCI7XG4gICAgY2NbY2NbXCJNXCJdID0gXCJNXCIuY2hhckNvZGVBdCgwKV0gPSBcIk1cIjtcbiAgICBjY1tjY1tcIm1cIl0gPSBcIm1cIi5jaGFyQ29kZUF0KDApXSA9IFwibVwiO1xuICAgIGNjW2NjW1wiTUlOVVNcIl0gPSBcIi1cIi5jaGFyQ29kZUF0KDApXSA9IFwiTUlOVVNcIjtcbiAgICBjY1tjY1tcIk5cIl0gPSBcIk5cIi5jaGFyQ29kZUF0KDApXSA9IFwiTlwiO1xuICAgIGNjW2NjW1wiblwiXSA9IFwiblwiLmNoYXJDb2RlQXQoMCldID0gXCJuXCI7XG4gICAgY2NbY2NbXCJOTFwiXSA9IFwiXFxuXCIuY2hhckNvZGVBdCgwKV0gPSBcIk5MXCI7XG4gICAgY2NbY2NbXCJPXCJdID0gXCJPXCIuY2hhckNvZGVBdCgwKV0gPSBcIk9cIjtcbiAgICBjY1tjY1tcIm9cIl0gPSBcIm9cIi5jaGFyQ29kZUF0KDApXSA9IFwib1wiO1xuICAgIGNjW2NjW1wiUFwiXSA9IFwiUFwiLmNoYXJDb2RlQXQoMCldID0gXCJQXCI7XG4gICAgY2NbY2NbXCJwXCJdID0gXCJwXCIuY2hhckNvZGVBdCgwKV0gPSBcInBcIjtcbiAgICBjY1tjY1tcIlBMVVNcIl0gPSBcIitcIi5jaGFyQ29kZUF0KDApXSA9IFwiUExVU1wiO1xuICAgIGNjW2NjW1wiUlwiXSA9IFwiUlwiLmNoYXJDb2RlQXQoMCldID0gXCJSXCI7XG4gICAgY2NbY2NbXCJyXCJdID0gXCJyXCIuY2hhckNvZGVBdCgwKV0gPSBcInJcIjtcbiAgICBjY1tjY1tcIlNcIl0gPSBcIlNcIi5jaGFyQ29kZUF0KDApXSA9IFwiU1wiO1xuICAgIGNjW2NjW1wic1wiXSA9IFwic1wiLmNoYXJDb2RlQXQoMCldID0gXCJzXCI7XG4gICAgY2NbY2NbXCJTUEFDRVwiXSA9IFwiIFwiLmNoYXJDb2RlQXQoMCldID0gXCJTUEFDRVwiO1xuICAgIGNjW2NjW1wiVEFCXCJdID0gXCJcXHRcIi5jaGFyQ29kZUF0KDApXSA9IFwiVEFCXCI7XG59KShjYyB8fCAoY2MgPSB7fSkpO1xuY29uc3QgRkxVU0hfVEhSRVNIT0xEID0gMTAyNCAqIDMyO1xuY29uc3QgSU5GTyA9IC9eSU5GT1xccysoW15cXHJcXG5dKylcXHJcXG4vaTtcbmZ1bmN0aW9uIGNyZWF0ZUluYm94KHByZWZpeCA9IFwiXCIpIHtcbiAgICBwcmVmaXggPSBwcmVmaXggfHwgXCJfSU5CT1hcIjtcbiAgICBpZiAodHlwZW9mIHByZWZpeCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcmVmaXggbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGAke3ByZWZpeH0uJHtudWlkLm5leHQoKX1gO1xufVxuY2xhc3MgTXV4U3Vic2NyaXB0aW9uIHtcbiAgICBiYXNlSW5ib3g7XG4gICAgcmVxcztcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLnJlcXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXMuc2l6ZTtcbiAgICB9XG4gICAgaW5pdChwcmVmaXgpIHtcbiAgICAgICAgdGhpcy5iYXNlSW5ib3ggPSBgJHtjcmVhdGVJbmJveChwcmVmaXgpfS5gO1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNlSW5ib3g7XG4gICAgfVxuICAgIGFkZChyKSB7XG4gICAgICAgIGlmICghaXNOYU4oci5yZWNlaXZlZCkpIHtcbiAgICAgICAgICAgIHIucmVjZWl2ZWQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVxcy5zZXQoci50b2tlbiwgcik7XG4gICAgfVxuICAgIGdldCh0b2tlbikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXFzLmdldCh0b2tlbik7XG4gICAgfVxuICAgIGNhbmNlbChyKSB7XG4gICAgICAgIHRoaXMucmVxcy5kZWxldGUoci50b2tlbik7XG4gICAgfVxuICAgIGdldFRva2VuKG0pIHtcbiAgICAgICAgY29uc3QgcyA9IG0uc3ViamVjdCB8fCBcIlwiO1xuICAgICAgICBpZiAocy5pbmRleE9mKHRoaXMuYmFzZUluYm94KSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHMuc3Vic3RyaW5nKHRoaXMuYmFzZUluYm94Lmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFsbCgpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5yZXFzLnZhbHVlcygpKTtcbiAgICB9XG4gICAgaGFuZGxlRXJyb3IoaXNNdXhQZXJtaXNzaW9uRXJyb3IsIGVycikge1xuICAgICAgICBpZiAoZXJyICYmIGVyci5wZXJtaXNzaW9uQ29udGV4dCkge1xuICAgICAgICAgICAgaWYgKGlzTXV4UGVybWlzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGwoKS5mb3JFYWNoKChyKT0+e1xuICAgICAgICAgICAgICAgICAgICByLnJlc29sdmVyKGVyciwge30pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY3R4ID0gZXJyLnBlcm1pc3Npb25Db250ZXh0O1xuICAgICAgICAgICAgaWYgKGN0eC5vcGVyYXRpb24gPT09IFwicHVibGlzaFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxID0gdGhpcy5hbGwoKS5maW5kKChzKT0+e1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5yZXF1ZXN0U3ViamVjdCA9PT0gY3R4LnN1YmplY3Q7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcSkge1xuICAgICAgICAgICAgICAgICAgICByZXEucmVzb2x2ZXIoZXJyLCB7fSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRpc3BhdGNoZXIoKSB7XG4gICAgICAgIHJldHVybiAoZXJyLCBtKT0+e1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLmdldFRva2VuKG0pO1xuICAgICAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IHRoaXMuZ2V0KHRva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyID09PSBudWxsICYmIG0uaGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gaXNSZXF1ZXN0RXJyb3IobSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgci5yZXNvbHZlcihlcnIsIG0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLlRpbWVvdXQpO1xuICAgICAgICB0aGlzLnJlcXMuZm9yRWFjaCgocmVxKT0+e1xuICAgICAgICAgICAgcmVxLnJlc29sdmVyKGVyciwge30pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5jb25zdCBQT05HX0NNRCA9IGVuY29kZShcIlBPTkdcXHJcXG5cIik7XG5jb25zdCBQSU5HX0NNRCA9IGVuY29kZShcIlBJTkdcXHJcXG5cIik7XG5jbGFzcyBDb25uZWN0IHtcbiAgICBlY2hvO1xuICAgIG5vX3Jlc3BvbmRlcnM7XG4gICAgcHJvdG9jb2w7XG4gICAgdmVyYm9zZTtcbiAgICBwZWRhbnRpYztcbiAgICBqd3Q7XG4gICAgbmtleTtcbiAgICBzaWc7XG4gICAgdXNlcjtcbiAgICBwYXNzO1xuICAgIGF1dGhfdG9rZW47XG4gICAgdGxzX3JlcXVpcmVkO1xuICAgIG5hbWU7XG4gICAgbGFuZztcbiAgICB2ZXJzaW9uO1xuICAgIGhlYWRlcnM7XG4gICAgY29uc3RydWN0b3IodHJhbnNwb3J0LCBvcHRzLCBub25jZSl7XG4gICAgICAgIHRoaXMucHJvdG9jb2wgPSAxO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSB0cmFuc3BvcnQudmVyc2lvbjtcbiAgICAgICAgdGhpcy5sYW5nID0gdHJhbnNwb3J0Lmxhbmc7XG4gICAgICAgIHRoaXMuZWNobyA9IG9wdHMubm9FY2hvID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudmVyYm9zZSA9IG9wdHMudmVyYm9zZTtcbiAgICAgICAgdGhpcy5wZWRhbnRpYyA9IG9wdHMucGVkYW50aWM7XG4gICAgICAgIHRoaXMudGxzX3JlcXVpcmVkID0gb3B0cy50bHMgPyB0cnVlIDogdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm5hbWUgPSBvcHRzLm5hbWU7XG4gICAgICAgIGNvbnN0IGNyZWRzID0gKG9wdHMgJiYgb3B0cy5hdXRoZW50aWNhdG9yID8gb3B0cy5hdXRoZW50aWNhdG9yKG5vbmNlKSA6IHt9KSB8fCB7fTtcbiAgICAgICAgZXh0ZW5kKHRoaXMsIGNyZWRzKTtcbiAgICB9XG59XG5jbGFzcyBQcm90b2NvbEhhbmRsZXIge1xuICAgIGNvbm5lY3RlZDtcbiAgICBjb25uZWN0ZWRPbmNlO1xuICAgIGluZm9SZWNlaXZlZDtcbiAgICBpbmZvO1xuICAgIG11eFN1YnNjcmlwdGlvbnM7XG4gICAgb3B0aW9ucztcbiAgICBvdXRib3VuZDtcbiAgICBwb25ncztcbiAgICBzdWJzY3JpcHRpb25zO1xuICAgIHRyYW5zcG9ydDtcbiAgICBub01vcmVQdWJsaXNoaW5nO1xuICAgIGNvbm5lY3RFcnJvcjtcbiAgICBwdWJsaXNoZXI7XG4gICAgX2Nsb3NlZDtcbiAgICBjbG9zZWQ7XG4gICAgbGlzdGVuZXJzO1xuICAgIGhlYXJ0YmVhdHM7XG4gICAgcGFyc2VyO1xuICAgIG91dE1zZ3M7XG4gICAgaW5Nc2dzO1xuICAgIG91dEJ5dGVzO1xuICAgIGluQnl0ZXM7XG4gICAgcGVuZGluZ0xpbWl0O1xuICAgIGxhc3RFcnJvcjtcbiAgICBhYm9ydFJlY29ubmVjdDtcbiAgICBzZXJ2ZXJzO1xuICAgIHNlcnZlcjtcbiAgICBmZWF0dXJlcztcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBwdWJsaXNoZXIpe1xuICAgICAgICB0aGlzLl9jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRPbmNlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5mb1JlY2VpdmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubm9Nb3JlUHVibGlzaGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFib3J0UmVjb25uZWN0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMucGVuZGluZ0xpbWl0ID0gRkxVU0hfVEhSRVNIT0xEO1xuICAgICAgICB0aGlzLm91dE1zZ3MgPSAwO1xuICAgICAgICB0aGlzLmluTXNncyA9IDA7XG4gICAgICAgIHRoaXMub3V0Qnl0ZXMgPSAwO1xuICAgICAgICB0aGlzLmluQnl0ZXMgPSAwO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnB1Ymxpc2hlciA9IHB1Ymxpc2hlcjtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IFN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgdGhpcy5tdXhTdWJzY3JpcHRpb25zID0gbmV3IE11eFN1YnNjcmlwdGlvbigpO1xuICAgICAgICB0aGlzLm91dGJvdW5kID0gbmV3IERhdGFCdWZmZXIoKTtcbiAgICAgICAgdGhpcy5wb25ncyA9IFtdO1xuICAgICAgICB0aGlzLnBlbmRpbmdMaW1pdCA9IG9wdGlvbnMucGVuZGluZ0xpbWl0IHx8IHRoaXMucGVuZGluZ0xpbWl0O1xuICAgICAgICB0aGlzLmZlYXR1cmVzID0gbmV3IEZlYXR1cmVzKHtcbiAgICAgICAgICAgIG1ham9yOiAwLFxuICAgICAgICAgICAgbWlub3I6IDAsXG4gICAgICAgICAgICBtaWNybzogMFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc2VydmVycyA9IHR5cGVvZiBvcHRpb25zLnNlcnZlcnMgPT09IFwic3RyaW5nXCIgPyBbXG4gICAgICAgICAgICBvcHRpb25zLnNlcnZlcnNcbiAgICAgICAgXSA6IG9wdGlvbnMuc2VydmVycztcbiAgICAgICAgdGhpcy5zZXJ2ZXJzID0gbmV3IFNlcnZlcnMoc2VydmVycywge1xuICAgICAgICAgICAgcmFuZG9taXplOiAhb3B0aW9ucy5ub1JhbmRvbWl6ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jbG9zZWQgPSBkZWZlcnJlZCgpO1xuICAgICAgICB0aGlzLnBhcnNlciA9IG5ldyBQYXJzZXIodGhpcyk7XG4gICAgICAgIHRoaXMuaGVhcnRiZWF0cyA9IG5ldyBIZWFydGJlYXQodGhpcywgdGhpcy5vcHRpb25zLnBpbmdJbnRlcnZhbCB8fCBERUZBVUxUX1BJTkdfSU5URVJWQUwsIHRoaXMub3B0aW9ucy5tYXhQaW5nT3V0IHx8IERFRkFVTFRfTUFYX1BJTkdfT1VUKTtcbiAgICB9XG4gICAgcmVzZXRPdXRib3VuZCgpIHtcbiAgICAgICAgdGhpcy5vdXRib3VuZC5yZXNldCgpO1xuICAgICAgICBjb25zdCBwb25ncyA9IHRoaXMucG9uZ3M7XG4gICAgICAgIHRoaXMucG9uZ3MgPSBbXTtcbiAgICAgICAgcG9uZ3MuZm9yRWFjaCgocCk9PntcbiAgICAgICAgICAgIHAucmVqZWN0KE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLkRpc2Nvbm5lY3QpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGFyc2VyID0gbmV3IFBhcnNlcih0aGlzKTtcbiAgICAgICAgdGhpcy5pbmZvUmVjZWl2ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgZGlzcGF0Y2hTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goKHEpPT57XG4gICAgICAgICAgICBxLnB1c2goc3RhdHVzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXR1cygpIHtcbiAgICAgICAgY29uc3QgaXRlciA9IG5ldyBRdWV1ZWRJdGVyYXRvckltcGwoKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMucHVzaChpdGVyKTtcbiAgICAgICAgcmV0dXJuIGl0ZXI7XG4gICAgfVxuICAgIHByZXBhcmUoKSB7XG4gICAgICAgIHRoaXMuaW5mbyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yZXNldE91dGJvdW5kKCk7XG4gICAgICAgIGNvbnN0IHBvbmcgPSBkZWZlcnJlZCgpO1xuICAgICAgICB0aGlzLnBvbmdzLnVuc2hpZnQocG9uZyk7XG4gICAgICAgIHRoaXMuY29ubmVjdEVycm9yID0gKGVycik9PntcbiAgICAgICAgICAgIHBvbmcucmVqZWN0KGVycik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gbmV3VHJhbnNwb3J0KCk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlZCgpLnRoZW4oYXN5bmMgKF9lcnIpPT57XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzQ2xvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmRpc2Nvbm5lY3RlZCh0aGlzLnRyYW5zcG9ydC5jbG9zZUVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcG9uZztcbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaFN0YXR1cyh7XG4gICAgICAgICAgICB0eXBlOiBEZWJ1Z0V2ZW50cy5TdGFsZUNvbm5lY3Rpb24sXG4gICAgICAgICAgICBkYXRhOiBcIlwiXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG4gICAgfVxuICAgIGFzeW5jIGRpc2Nvbm5lY3RlZChfZXJyKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hTdGF0dXMoe1xuICAgICAgICAgICAgdHlwZTogRXZlbnRzLkRpc2Nvbm5lY3QsXG4gICAgICAgICAgICBkYXRhOiB0aGlzLnNlcnZlcnMuZ2V0Q3VycmVudFNlcnZlcigpLnRvU3RyaW5nKClcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVjb25uZWN0KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmRpYWxMb29wKCkudGhlbigoKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hTdGF0dXMoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudHMuUmVjb25uZWN0LFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLnNlcnZlcnMuZ2V0Q3VycmVudFNlcnZlcigpLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xvc2UoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBkaWFsKHNydikge1xuICAgICAgICBjb25zdCBwb25nID0gdGhpcy5wcmVwYXJlKCk7XG4gICAgICAgIGxldCB0aW1lcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRpbWVyID0gdGltZW91dCh0aGlzLm9wdGlvbnMudGltZW91dCB8fCAyMDAwMCk7XG4gICAgICAgICAgICBjb25zdCBjcCA9IHRoaXMudHJhbnNwb3J0LmNvbm5lY3Qoc3J2LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgICAgICBjcCxcbiAgICAgICAgICAgICAgICB0aW1lclxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAoYXN5bmMgKCk9PntcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGIgb2YgdGhpcy50cmFuc3BvcnQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZXIucGFyc2UoYik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJyZWFkZXIgY2xvc2VkXCIsIGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKS50aGVuKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcG9uZy5yZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgICAgICB0aW1lcixcbiAgICAgICAgICAgICAgICBwb25nXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgICAgIHRpbWVyLmNhbmNlbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0RXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnNlbmRTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RlZE9uY2UgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zZXJ2ZXIuZGlkQ29ubmVjdCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNlcnZlci5yZWNvbm5lY3RzID0gMDtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hQZW5kaW5nKCk7XG4gICAgICAgICAgICB0aGlzLmhlYXJ0YmVhdHMuc3RhcnQoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyMSkge1xuICAgICAgICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgICAgICAgICAgdGltZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnRyYW5zcG9ydC5jbG9zZShlcnIxKTtcbiAgICAgICAgICAgIHRocm93IGVycjE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2RvRGlhbChzcnYpIHtcbiAgICAgICAgY29uc3QgYWx0cyA9IGF3YWl0IHNydi5yZXNvbHZlKHtcbiAgICAgICAgICAgIGZuOiBnZXRSZXNvbHZlRm4oKSxcbiAgICAgICAgICAgIHJhbmRvbWl6ZTogIXRoaXMub3B0aW9ucy5ub1JhbmRvbWl6ZVxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGxhc3RFcnIgPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGEgb2YgYWx0cyl7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxhc3RFcnIgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hTdGF0dXMoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBEZWJ1Z0V2ZW50cy5SZWNvbm5lY3RpbmcsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGEudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZGlhbChhKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBsYXN0RXJyID0gZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IGxhc3RFcnI7XG4gICAgfVxuICAgIGFzeW5jIGRpYWxMb29wKCkge1xuICAgICAgICBsZXQgbGFzdEVycm9yO1xuICAgICAgICB3aGlsZSh0cnVlKXtcbiAgICAgICAgICAgIGNvbnN0IHdhaXQgPSB0aGlzLm9wdGlvbnMucmVjb25uZWN0RGVsYXlIYW5kbGVyID8gdGhpcy5vcHRpb25zLnJlY29ubmVjdERlbGF5SGFuZGxlcigpIDogREVGQVVMVF9SRUNPTk5FQ1RfVElNRV9XQUlUO1xuICAgICAgICAgICAgbGV0IG1heFdhaXQgPSB3YWl0O1xuICAgICAgICAgICAgY29uc3Qgc3J2ID0gdGhpcy5zZWxlY3RTZXJ2ZXIoKTtcbiAgICAgICAgICAgIGlmICghc3J2IHx8IHRoaXMuYWJvcnRSZWNvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGxhc3RFcnJvcjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGFzdEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMubGFzdEVycm9yO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLkNvbm5lY3Rpb25SZWZ1c2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgaWYgKHNydi5sYXN0Q29ubmVjdCA9PT0gMCB8fCBzcnYubGFzdENvbm5lY3QgKyB3YWl0IDw9IG5vdykge1xuICAgICAgICAgICAgICAgIHNydi5sYXN0Q29ubmVjdCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fZG9EaWFsKHNydik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBsYXN0RXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb25uZWN0ZWRPbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLndhaXRPbkZpcnN0Q29ubmVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZXJzLnJlbW92ZUN1cnJlbnRTZXJ2ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzcnYucmVjb25uZWN0cysrO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtcmEgPSB0aGlzLm9wdGlvbnMubWF4UmVjb25uZWN0QXR0ZW1wdHMgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1yYSAhPT0gLTEgJiYgc3J2LnJlY29ubmVjdHMgPj0gbXJhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlcnZlcnMucmVtb3ZlQ3VycmVudFNlcnZlcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXhXYWl0ID0gTWF0aC5taW4obWF4V2FpdCwgc3J2Lmxhc3RDb25uZWN0ICsgd2FpdCAtIG5vdyk7XG4gICAgICAgICAgICAgICAgYXdhaXQgZGVsYXkobWF4V2FpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGNvbm5lY3Qob3B0aW9ucywgcHVibGlzaGVyKSB7XG4gICAgICAgIGNvbnN0IGggPSBuZXcgUHJvdG9jb2xIYW5kbGVyKG9wdGlvbnMsIHB1Ymxpc2hlcik7XG4gICAgICAgIGF3YWl0IGguZGlhbExvb3AoKTtcbiAgICAgICAgcmV0dXJuIGg7XG4gICAgfVxuICAgIHN0YXRpYyB0b0Vycm9yKHMpIHtcbiAgICAgICAgY29uc3QgdCA9IHMgPyBzLnRvTG93ZXJDYXNlKCkgOiBcIlwiO1xuICAgICAgICBpZiAodC5pbmRleE9mKFwicGVybWlzc2lvbnMgdmlvbGF0aW9uXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IE5hdHNFcnJvcihzLCBFcnJvckNvZGUuUGVybWlzc2lvbnNWaW9sYXRpb24pO1xuICAgICAgICAgICAgY29uc3QgbSA9IHMubWF0Y2goLyhQdWJsaXNofFN1YnNjcmlwdGlvbikgdG8gXCIoXFxTKylcIi8pO1xuICAgICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgICAgICBlcnIucGVybWlzc2lvbkNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogbVsxXS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICBzdWJqZWN0OiBtWzJdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgIH0gZWxzZSBpZiAodC5pbmRleE9mKFwiYXV0aG9yaXphdGlvbiB2aW9sYXRpb25cIikgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5hdHNFcnJvcihzLCBFcnJvckNvZGUuQXV0aG9yaXphdGlvblZpb2xhdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAodC5pbmRleE9mKFwidXNlciBhdXRoZW50aWNhdGlvbiBleHBpcmVkXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBOYXRzRXJyb3IocywgRXJyb3JDb2RlLkF1dGhlbnRpY2F0aW9uRXhwaXJlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5hdHNFcnJvcihzLCBFcnJvckNvZGUuUHJvdG9jb2xFcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvY2Vzc01zZyhtc2csIGRhdGEpIHtcbiAgICAgICAgdGhpcy5pbk1zZ3MrKztcbiAgICAgICAgdGhpcy5pbkJ5dGVzICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICBpZiAoIXRoaXMuc3Vic2NyaXB0aW9ucy5zaWRDb3VudGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3ViID0gdGhpcy5zdWJzY3JpcHRpb25zLmdldChtc2cuc2lkKTtcbiAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdWIucmVjZWl2ZWQgKz0gMTtcbiAgICAgICAgaWYgKHN1Yi5jYWxsYmFjaykge1xuICAgICAgICAgICAgc3ViLmNhbGxiYWNrKG51bGwsIG5ldyBNc2dJbXBsKG1zZywgZGF0YSwgdGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdWIubWF4ICE9PSB1bmRlZmluZWQgJiYgc3ViLnJlY2VpdmVkID49IHN1Yi5tYXgpIHtcbiAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHByb2Nlc3NFcnJvcihtKSB7XG4gICAgICAgIGNvbnN0IHMgPSBkZWNvZGUobSk7XG4gICAgICAgIGNvbnN0IGVyciA9IFByb3RvY29sSGFuZGxlci50b0Vycm9yKHMpO1xuICAgICAgICBsZXQgaXNNdXhQZXJtaXNzaW9uRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0ge1xuICAgICAgICAgICAgdHlwZTogRXZlbnRzLkVycm9yLFxuICAgICAgICAgICAgZGF0YTogZXJyLmNvZGVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGVyci5wZXJtaXNzaW9uQ29udGV4dCkge1xuICAgICAgICAgICAgc3RhdHVzLnBlcm1pc3Npb25Db250ZXh0ID0gZXJyLnBlcm1pc3Npb25Db250ZXh0O1xuICAgICAgICAgICAgY29uc3QgbXV4ID0gdGhpcy5zdWJzY3JpcHRpb25zLmdldE11eCgpO1xuICAgICAgICAgICAgaXNNdXhQZXJtaXNzaW9uRXJyb3IgPSBtdXg/LnN1YmplY3QgPT09IGVyci5wZXJtaXNzaW9uQ29udGV4dC5zdWJqZWN0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5oYW5kbGVFcnJvcihlcnIpO1xuICAgICAgICB0aGlzLm11eFN1YnNjcmlwdGlvbnMuaGFuZGxlRXJyb3IoaXNNdXhQZXJtaXNzaW9uRXJyb3IsIGVycik7XG4gICAgICAgIGlmIChpc011eFBlcm1pc3Npb25FcnJvcikge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnNldE11eChudWxsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc3BhdGNoU3RhdHVzKHN0YXR1cyk7XG4gICAgICAgIGF3YWl0IHRoaXMuaGFuZGxlRXJyb3IoZXJyKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlRXJyb3IoZXJyKSB7XG4gICAgICAgIGlmIChlcnIuaXNBdXRoRXJyb3IoKSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVBdXRoRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyLmlzUHJvdG9jb2xFcnJvcigpKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9jbG9zZShlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdEVycm9yID0gZXJyO1xuICAgIH1cbiAgICBoYW5kbGVBdXRoRXJyb3IoZXJyKSB7XG4gICAgICAgIGlmICh0aGlzLmxhc3RFcnJvciAmJiBlcnIuY29kZSA9PT0gdGhpcy5sYXN0RXJyb3IuY29kZSkge1xuICAgICAgICAgICAgdGhpcy5hYm9ydFJlY29ubmVjdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdEVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RFcnJvcihlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvY2Vzc1BpbmcoKSB7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0LnNlbmQoUE9OR19DTUQpO1xuICAgIH1cbiAgICBwcm9jZXNzUG9uZygpIHtcbiAgICAgICAgY29uc3QgY2IgPSB0aGlzLnBvbmdzLnNoaWZ0KCk7XG4gICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgY2IucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3NJbmZvKG0pIHtcbiAgICAgICAgY29uc3QgaW5mbyA9IEpTT04ucGFyc2UoZGVjb2RlKG0pKTtcbiAgICAgICAgdGhpcy5pbmZvID0gaW5mbztcbiAgICAgICAgY29uc3QgdXBkYXRlcyA9IHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuaWdub3JlQ2x1c3RlclVwZGF0ZXMgPyB1bmRlZmluZWQgOiB0aGlzLnNlcnZlcnMudXBkYXRlKGluZm8pO1xuICAgICAgICBpZiAoIXRoaXMuaW5mb1JlY2VpdmVkKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVzID0gbmV3IEZlYXR1cmVzKHBhcnNlU2VtVmVyKGluZm8udmVyc2lvbikpO1xuICAgICAgICAgICAgdGhpcy5pbmZvUmVjZWl2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNwb3J0LmlzRW5jcnlwdGVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlcnZlcnMudXBkYXRlVExTTmFtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB2ZXJzaW9uICwgbGFuZyAgfSA9IHRoaXMudHJhbnNwb3J0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gbmV3IENvbm5lY3Qoe1xuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICBsYW5nXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5vcHRpb25zLCBpbmZvLm5vbmNlKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5mby5oZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGMuaGVhZGVycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGMubm9fcmVzcG9uZGVycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNzID0gSlNPTi5zdHJpbmdpZnkoYyk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuc2VuZChlbmNvZGUoYENPTk5FQ1QgJHtjc30ke0NSX0xGfWApKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKFBJTkdfQ01EKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlKE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLkJhZEF1dGhlbnRpY2F0aW9uLCBlcnIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlcykge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgdHlwZTogRXZlbnRzLlVwZGF0ZSxcbiAgICAgICAgICAgICAgICBkYXRhOiB1cGRhdGVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZG0gPSBpbmZvLmxkbSAhPT0gdW5kZWZpbmVkID8gaW5mby5sZG0gOiBmYWxzZTtcbiAgICAgICAgaWYgKGxkbSkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgdHlwZTogRXZlbnRzLkxETSxcbiAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLnNlcnZlcnMuZ2V0Q3VycmVudFNlcnZlcigpLnRvU3RyaW5nKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHB1c2goZSkge1xuICAgICAgICBzd2l0Y2goZS5raW5kKXtcbiAgICAgICAgICAgIGNhc2UgS2luZC5NU0c6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG1zZyAsIGRhdGEgIH0gPSBlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NNc2cobXNnLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBLaW5kLk9LOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBLaW5kLkVSUjpcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NFcnJvcihlLmRhdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBLaW5kLlBJTkc6XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzUGluZygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBLaW5kLlBPTkc6XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzUG9uZygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBLaW5kLklORk86XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzSW5mbyhlLmRhdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbmRDb21tYW5kKGNtZCwgLi4ucGF5bG9hZHMpIHtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRib3VuZC5sZW5ndGgoKTtcbiAgICAgICAgbGV0IGJ1ZjtcbiAgICAgICAgaWYgKHR5cGVvZiBjbWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGJ1ZiA9IGVuY29kZShjbWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnVmID0gY21kO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0Ym91bmQuZmlsbChidWYsIC4uLnBheWxvYWRzKTtcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hQZW5kaW5nKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm91dGJvdW5kLnNpemUoKSA+PSB0aGlzLnBlbmRpbmdMaW1pdCkge1xuICAgICAgICAgICAgdGhpcy5mbHVzaFBlbmRpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwdWJsaXNoKHN1YmplY3QsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgb3B0aW9ucy5yZXBseSA9IG9wdGlvbnMucmVwbHkgfHwgXCJcIjtcbiAgICAgICAgbGV0IGhlYWRlcnMgPSBFbXB0eTtcbiAgICAgICAgbGV0IGhsZW4gPSAwO1xuICAgICAgICBpZiAob3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmZvICYmICF0aGlzLmluZm8uaGVhZGVycykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOYXRzRXJyb3IoXCJoZWFkZXJzXCIsIEVycm9yQ29kZS5TZXJ2ZXJPcHRpb25Ob3RBdmFpbGFibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGRycyA9IG9wdGlvbnMuaGVhZGVycztcbiAgICAgICAgICAgIGhlYWRlcnMgPSBoZHJzLmVuY29kZSgpO1xuICAgICAgICAgICAgaGxlbiA9IGhlYWRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgbGVuID0gZGF0YS5sZW5ndGggKyBobGVuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluZm8gJiYgbGVuID4gdGhpcy5pbmZvLm1heF9wYXlsb2FkKSB7XG4gICAgICAgICAgICB0aHJvdyBOYXRzRXJyb3IuZXJyb3JGb3JDb2RlKEVycm9yQ29kZS5NYXhQYXlsb2FkRXhjZWVkZWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0Qnl0ZXMgKz0gbGVuO1xuICAgICAgICB0aGlzLm91dE1zZ3MrKztcbiAgICAgICAgbGV0IHByb3RvO1xuICAgICAgICBpZiAob3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5yZXBseSkge1xuICAgICAgICAgICAgICAgIHByb3RvID0gYEhQVUIgJHtzdWJqZWN0fSAke29wdGlvbnMucmVwbHl9ICR7aGxlbn0gJHtsZW59JHtDUl9MRn1gO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm90byA9IGBIUFVCICR7c3ViamVjdH0gJHtobGVufSAke2xlbn1cXHJcXG5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZW5kQ29tbWFuZChwcm90bywgaGVhZGVycywgZGF0YSwgQ1JMRik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5yZXBseSkge1xuICAgICAgICAgICAgICAgIHByb3RvID0gYFBVQiAke3N1YmplY3R9ICR7b3B0aW9ucy5yZXBseX0gJHtsZW59XFxyXFxuYDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvdG8gPSBgUFVCICR7c3ViamVjdH0gJHtsZW59XFxyXFxuYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2VuZENvbW1hbmQocHJvdG8sIGRhdGEsIENSTEYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcXVlc3Qocikge1xuICAgICAgICB0aGlzLmluaXRNdXgoKTtcbiAgICAgICAgdGhpcy5tdXhTdWJzY3JpcHRpb25zLmFkZChyKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIHN1YnNjcmliZShzKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQocyk7XG4gICAgICAgIHRoaXMuX3N1YnVuc3ViKHMpO1xuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgX3N1YihzKSB7XG4gICAgICAgIGlmIChzLnF1ZXVlKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRDb21tYW5kKGBTVUIgJHtzLnN1YmplY3R9ICR7cy5xdWV1ZX0gJHtzLnNpZH1cXHJcXG5gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZENvbW1hbmQoYFNVQiAke3Muc3ViamVjdH0gJHtzLnNpZH1cXHJcXG5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfc3VidW5zdWIocykge1xuICAgICAgICB0aGlzLl9zdWIocyk7XG4gICAgICAgIGlmIChzLm1heCkge1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZShzLCBzLm1heCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlKHMsIG1heCkge1xuICAgICAgICB0aGlzLnVuc3ViKHMsIG1heCk7XG4gICAgICAgIGlmIChzLm1heCA9PT0gdW5kZWZpbmVkIHx8IHMucmVjZWl2ZWQgPj0gcy5tYXgpIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5jYW5jZWwocyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5zdWIocywgbWF4KSB7XG4gICAgICAgIGlmICghcyB8fCB0aGlzLmlzQ2xvc2VkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4KSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRDb21tYW5kKGBVTlNVQiAke3Muc2lkfSAke21heH0ke0NSX0xGfWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZW5kQ29tbWFuZChgVU5TVUIgJHtzLnNpZH0ke0NSX0xGfWApO1xuICAgICAgICB9XG4gICAgICAgIHMubWF4ID0gbWF4O1xuICAgIH1cbiAgICByZXN1YihzLCBzdWJqZWN0KSB7XG4gICAgICAgIGlmICghcyB8fCB0aGlzLmlzQ2xvc2VkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzLnN1YmplY3QgPSBzdWJqZWN0O1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMucmVzdWIocyk7XG4gICAgICAgIHRoaXMuX3N1YihzKTtcbiAgICB9XG4gICAgZmx1c2gocCkge1xuICAgICAgICBpZiAoIXApIHtcbiAgICAgICAgICAgIHAgPSBkZWZlcnJlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9uZ3MucHVzaChwKTtcbiAgICAgICAgdGhpcy5zZW5kQ29tbWFuZChQSU5HX0NNRCk7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBzZW5kU3Vic2NyaXB0aW9ucygpIHtcbiAgICAgICAgY29uc3QgY21kcyA9IFtdO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWxsKCkuZm9yRWFjaCgocyk9PntcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IHM7XG4gICAgICAgICAgICBpZiAoc3ViLnF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY21kcy5wdXNoKGBTVUIgJHtzdWIuc3ViamVjdH0gJHtzdWIucXVldWV9ICR7c3ViLnNpZH0ke0NSX0xGfWApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbWRzLnB1c2goYFNVQiAke3N1Yi5zdWJqZWN0fSAke3N1Yi5zaWR9JHtDUl9MRn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjbWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuc2VuZChlbmNvZGUoY21kcy5qb2luKFwiXCIpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2Nsb3NlKGVycikge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWFydGJlYXRzLmNhbmNlbCgpO1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0RXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdEVycm9yKGVycik7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm11eFN1YnNjcmlwdGlvbnMuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmNsb3NlKCk7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goKGwpPT57XG4gICAgICAgICAgICBsLnN0b3AoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gICAgICAgIGF3YWl0IHRoaXMudHJhbnNwb3J0LmNsb3NlKGVycik7XG4gICAgICAgIGF3YWl0IHRoaXMuY2xvc2VkLnJlc29sdmUoZXJyKTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9zZSgpO1xuICAgIH1cbiAgICBpc0Nsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb3NlZDtcbiAgICB9XG4gICAgZHJhaW4oKSB7XG4gICAgICAgIGNvbnN0IHN1YnMgPSB0aGlzLnN1YnNjcmlwdGlvbnMuYWxsKCk7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIHN1YnMuZm9yRWFjaCgoc3ViKT0+e1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChzdWIuZHJhaW4oKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oYXN5bmMgKCk9PntcbiAgICAgICAgICAgIHRoaXMubm9Nb3JlUHVibGlzaGluZyA9IHRydWU7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmZsdXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9zZSgpO1xuICAgICAgICB9KS5jYXRjaCgoKT0+e30pO1xuICAgIH1cbiAgICBmbHVzaFBlbmRpbmcoKSB7XG4gICAgICAgIGlmICghdGhpcy5pbmZvUmVjZWl2ZWQgfHwgIXRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3V0Ym91bmQuc2l6ZSgpKSB7XG4gICAgICAgICAgICBjb25zdCBkID0gdGhpcy5vdXRib3VuZC5kcmFpbigpO1xuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuc2VuZChkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbml0TXV4KCkge1xuICAgICAgICBjb25zdCBtdXggPSB0aGlzLnN1YnNjcmlwdGlvbnMuZ2V0TXV4KCk7XG4gICAgICAgIGlmICghbXV4KSB7XG4gICAgICAgICAgICBjb25zdCBpbmJveCA9IHRoaXMubXV4U3Vic2NyaXB0aW9ucy5pbml0KHRoaXMub3B0aW9ucy5pbmJveFByZWZpeCk7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSBuZXcgU3Vic2NyaXB0aW9uSW1wbCh0aGlzLCBgJHtpbmJveH0qYCk7XG4gICAgICAgICAgICBzdWIuY2FsbGJhY2sgPSB0aGlzLm11eFN1YnNjcmlwdGlvbnMuZGlzcGF0Y2hlcigpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnNldE11eChzdWIpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUoc3ViKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWxlY3RTZXJ2ZXIoKSB7XG4gICAgICAgIGNvbnN0IHNlcnZlciA9IHRoaXMuc2VydmVycy5zZWxlY3RTZXJ2ZXIoKTtcbiAgICAgICAgaWYgKHNlcnZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VydmVyID0gc2VydmVyO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2ZXI7XG4gICAgfVxuICAgIGdldFNlcnZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VydmVyO1xuICAgIH1cbn1cbihmdW5jdGlvbihuYWNsKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciB1NjQgPSBmdW5jdGlvbihoLCBsKSB7XG4gICAgICAgIHRoaXMuaGkgPSBoIHwgMCA+Pj4gMDtcbiAgICAgICAgdGhpcy5sbyA9IGwgfCAwID4+PiAwO1xuICAgIH07XG4gICAgdmFyIGdmID0gZnVuY3Rpb24oaW5pdCkge1xuICAgICAgICB2YXIgaSwgciA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xuICAgICAgICBpZiAoaW5pdCkgZm9yKGkgPSAwOyBpIDwgaW5pdC5sZW5ndGg7IGkrKylyW2ldID0gaW5pdFtpXTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICB2YXIgcmFuZG9tYnl0ZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBQUk5HJyk7XG4gICAgfTtcbiAgICB2YXIgXzAgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgdmFyIF85ID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICAgIF85WzBdID0gOTtcbiAgICB2YXIgZ2YwID0gZ2YoKSwgZ2YxID0gZ2YoW1xuICAgICAgICAxXG4gICAgXSksIF8xMjE2NjUgPSBnZihbXG4gICAgICAgIDB4ZGI0MSxcbiAgICAgICAgMVxuICAgIF0pLCBEID0gZ2YoW1xuICAgICAgICAweDc4YTMsXG4gICAgICAgIDB4MTM1OSxcbiAgICAgICAgMHg0ZGNhLFxuICAgICAgICAweDc1ZWIsXG4gICAgICAgIDB4ZDhhYixcbiAgICAgICAgMHg0MTQxLFxuICAgICAgICAweDBhNGQsXG4gICAgICAgIDB4MDA3MCxcbiAgICAgICAgMHhlODk4LFxuICAgICAgICAweDc3NzksXG4gICAgICAgIDB4NDA3OSxcbiAgICAgICAgMHg4Y2M3LFxuICAgICAgICAweGZlNzMsXG4gICAgICAgIDB4MmI2ZixcbiAgICAgICAgMHg2Y2VlLFxuICAgICAgICAweDUyMDNcbiAgICBdKSwgRDIgPSBnZihbXG4gICAgICAgIDB4ZjE1OSxcbiAgICAgICAgMHgyNmIyLFxuICAgICAgICAweDliOTQsXG4gICAgICAgIDB4ZWJkNixcbiAgICAgICAgMHhiMTU2LFxuICAgICAgICAweDgyODMsXG4gICAgICAgIDB4MTQ5YSxcbiAgICAgICAgMHgwMGUwLFxuICAgICAgICAweGQxMzAsXG4gICAgICAgIDB4ZWVmMyxcbiAgICAgICAgMHg4MGYyLFxuICAgICAgICAweDE5OGUsXG4gICAgICAgIDB4ZmNlNyxcbiAgICAgICAgMHg1NmRmLFxuICAgICAgICAweGQ5ZGMsXG4gICAgICAgIDB4MjQwNlxuICAgIF0pLCBYID0gZ2YoW1xuICAgICAgICAweGQ1MWEsXG4gICAgICAgIDB4OGYyNSxcbiAgICAgICAgMHgyZDYwLFxuICAgICAgICAweGM5NTYsXG4gICAgICAgIDB4YTdiMixcbiAgICAgICAgMHg5NTI1LFxuICAgICAgICAweGM3NjAsXG4gICAgICAgIDB4NjkyYyxcbiAgICAgICAgMHhkYzVjLFxuICAgICAgICAweGZkZDYsXG4gICAgICAgIDB4ZTIzMSxcbiAgICAgICAgMHhjMGE0LFxuICAgICAgICAweDUzZmUsXG4gICAgICAgIDB4Y2Q2ZSxcbiAgICAgICAgMHgzNmQzLFxuICAgICAgICAweDIxNjlcbiAgICBdKSwgWSA9IGdmKFtcbiAgICAgICAgMHg2NjU4LFxuICAgICAgICAweDY2NjYsXG4gICAgICAgIDB4NjY2NixcbiAgICAgICAgMHg2NjY2LFxuICAgICAgICAweDY2NjYsXG4gICAgICAgIDB4NjY2NixcbiAgICAgICAgMHg2NjY2LFxuICAgICAgICAweDY2NjYsXG4gICAgICAgIDB4NjY2NixcbiAgICAgICAgMHg2NjY2LFxuICAgICAgICAweDY2NjYsXG4gICAgICAgIDB4NjY2NixcbiAgICAgICAgMHg2NjY2LFxuICAgICAgICAweDY2NjYsXG4gICAgICAgIDB4NjY2NixcbiAgICAgICAgMHg2NjY2XG4gICAgXSksIEkgPSBnZihbXG4gICAgICAgIDB4YTBiMCxcbiAgICAgICAgMHg0YTBlLFxuICAgICAgICAweDFiMjcsXG4gICAgICAgIDB4YzRlZSxcbiAgICAgICAgMHhlNDc4LFxuICAgICAgICAweGFkMmYsXG4gICAgICAgIDB4MTgwNixcbiAgICAgICAgMHgyZjQzLFxuICAgICAgICAweGQ3YTcsXG4gICAgICAgIDB4M2RmYixcbiAgICAgICAgMHgwMDk5LFxuICAgICAgICAweDJiNGQsXG4gICAgICAgIDB4ZGYwYixcbiAgICAgICAgMHg0ZmMxLFxuICAgICAgICAweDI0ODAsXG4gICAgICAgIDB4MmI4M1xuICAgIF0pO1xuICAgIGZ1bmN0aW9uIEwzMih4LCBjKSB7XG4gICAgICAgIHJldHVybiB4IDw8IGMgfCB4ID4+PiAzMiAtIGM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxkMzIoeCwgaSkge1xuICAgICAgICB2YXIgdSA9IHhbaSArIDNdICYgMHhmZjtcbiAgICAgICAgdSA9IHUgPDwgOCB8IHhbaSArIDJdICYgMHhmZjtcbiAgICAgICAgdSA9IHUgPDwgOCB8IHhbaSArIDFdICYgMHhmZjtcbiAgICAgICAgcmV0dXJuIHUgPDwgOCB8IHhbaSArIDBdICYgMHhmZjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGw2NCh4LCBpKSB7XG4gICAgICAgIHZhciBoID0geFtpXSA8PCAyNCB8IHhbaSArIDFdIDw8IDE2IHwgeFtpICsgMl0gPDwgOCB8IHhbaSArIDNdO1xuICAgICAgICB2YXIgbCA9IHhbaSArIDRdIDw8IDI0IHwgeFtpICsgNV0gPDwgMTYgfCB4W2kgKyA2XSA8PCA4IHwgeFtpICsgN107XG4gICAgICAgIHJldHVybiBuZXcgdTY0KGgsIGwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdDMyKHgsIGosIHUpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDQ7IGkrKyl7XG4gICAgICAgICAgICB4W2ogKyBpXSA9IHUgJiAyNTU7XG4gICAgICAgICAgICB1ID4+Pj0gODtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0czY0KHgsIGksIHUpIHtcbiAgICAgICAgeFtpXSA9IHUuaGkgPj4gMjQgJiAweGZmO1xuICAgICAgICB4W2kgKyAxXSA9IHUuaGkgPj4gMTYgJiAweGZmO1xuICAgICAgICB4W2kgKyAyXSA9IHUuaGkgPj4gOCAmIDB4ZmY7XG4gICAgICAgIHhbaSArIDNdID0gdS5oaSAmIDB4ZmY7XG4gICAgICAgIHhbaSArIDRdID0gdS5sbyA+PiAyNCAmIDB4ZmY7XG4gICAgICAgIHhbaSArIDVdID0gdS5sbyA+PiAxNiAmIDB4ZmY7XG4gICAgICAgIHhbaSArIDZdID0gdS5sbyA+PiA4ICYgMHhmZjtcbiAgICAgICAgeFtpICsgN10gPSB1LmxvICYgMHhmZjtcbiAgICB9XG4gICAgZnVuY3Rpb24gdm4oeCwgeGksIHksIHlpLCBuKSB7XG4gICAgICAgIHZhciBpLCBkID0gMDtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgbjsgaSsrKWQgfD0geFt4aSArIGldIF4geVt5aSArIGldO1xuICAgICAgICByZXR1cm4gKDEgJiBkIC0gMSA+Pj4gOCkgLSAxO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcnlwdG9fdmVyaWZ5XzE2KHgsIHhpLCB5LCB5aSkge1xuICAgICAgICByZXR1cm4gdm4oeCwgeGksIHksIHlpLCAxNik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyeXB0b192ZXJpZnlfMzIoeCwgeGksIHksIHlpKSB7XG4gICAgICAgIHJldHVybiB2bih4LCB4aSwgeSwgeWksIDMyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29yZShvdXQsIGlucCwgaywgYywgaCkge1xuICAgICAgICB2YXIgdyA9IG5ldyBVaW50MzJBcnJheSgxNiksIHggPSBuZXcgVWludDMyQXJyYXkoMTYpLCB5ID0gbmV3IFVpbnQzMkFycmF5KDE2KSwgdCA9IG5ldyBVaW50MzJBcnJheSg0KTtcbiAgICAgICAgdmFyIGksIGosIG07XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDQ7IGkrKyl7XG4gICAgICAgICAgICB4WzUgKiBpXSA9IGxkMzIoYywgNCAqIGkpO1xuICAgICAgICAgICAgeFsxICsgaV0gPSBsZDMyKGssIDQgKiBpKTtcbiAgICAgICAgICAgIHhbNiArIGldID0gbGQzMihpbnAsIDQgKiBpKTtcbiAgICAgICAgICAgIHhbMTEgKyBpXSA9IGxkMzIoaywgMTYgKyA0ICogaSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgMTY7IGkrKyl5W2ldID0geFtpXTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgMjA7IGkrKyl7XG4gICAgICAgICAgICBmb3IoaiA9IDA7IGogPCA0OyBqKyspe1xuICAgICAgICAgICAgICAgIGZvcihtID0gMDsgbSA8IDQ7IG0rKyl0W21dID0geFsoNSAqIGogKyA0ICogbSkgJSAxNl07XG4gICAgICAgICAgICAgICAgdFsxXSBePSBMMzIodFswXSArIHRbM10gfCAwLCA3KTtcbiAgICAgICAgICAgICAgICB0WzJdIF49IEwzMih0WzFdICsgdFswXSB8IDAsIDkpO1xuICAgICAgICAgICAgICAgIHRbM10gXj0gTDMyKHRbMl0gKyB0WzFdIHwgMCwgMTMpO1xuICAgICAgICAgICAgICAgIHRbMF0gXj0gTDMyKHRbM10gKyB0WzJdIHwgMCwgMTgpO1xuICAgICAgICAgICAgICAgIGZvcihtID0gMDsgbSA8IDQ7IG0rKyl3WzQgKiBqICsgKGogKyBtKSAlIDRdID0gdFttXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvcihtID0gMDsgbSA8IDE2OyBtKyspeFttXSA9IHdbbV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGgpIHtcbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IDE2OyBpKyspeFtpXSA9IHhbaV0gKyB5W2ldIHwgMDtcbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IDQ7IGkrKyl7XG4gICAgICAgICAgICAgICAgeFs1ICogaV0gPSB4WzUgKiBpXSAtIGxkMzIoYywgNCAqIGkpIHwgMDtcbiAgICAgICAgICAgICAgICB4WzYgKyBpXSA9IHhbNiArIGldIC0gbGQzMihpbnAsIDQgKiBpKSB8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCA0OyBpKyspe1xuICAgICAgICAgICAgICAgIHN0MzIob3V0LCA0ICogaSwgeFs1ICogaV0pO1xuICAgICAgICAgICAgICAgIHN0MzIob3V0LCAxNiArIDQgKiBpLCB4WzYgKyBpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCAxNjsgaSsrKXN0MzIob3V0LCA0ICogaSwgeFtpXSArIHlbaV0gfCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjcnlwdG9fY29yZV9zYWxzYTIwKG91dCwgaW5wLCBrLCBjKSB7XG4gICAgICAgIGNvcmUob3V0LCBpbnAsIGssIGMsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyeXB0b19jb3JlX2hzYWxzYTIwKG91dCwgaW5wLCBrLCBjKSB7XG4gICAgICAgIGNvcmUob3V0LCBpbnAsIGssIGMsIHRydWUpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgdmFyIHNpZ21hID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAxMDEsXG4gICAgICAgIDEyMCxcbiAgICAgICAgMTEyLFxuICAgICAgICA5NyxcbiAgICAgICAgMTEwLFxuICAgICAgICAxMDAsXG4gICAgICAgIDMyLFxuICAgICAgICA1MSxcbiAgICAgICAgNTAsXG4gICAgICAgIDQ1LFxuICAgICAgICA5OCxcbiAgICAgICAgMTIxLFxuICAgICAgICAxMTYsXG4gICAgICAgIDEwMSxcbiAgICAgICAgMzIsXG4gICAgICAgIDEwN1xuICAgIF0pO1xuICAgIGZ1bmN0aW9uIGNyeXB0b19zdHJlYW1fc2Fsc2EyMF94b3IoYywgY3BvcywgbSwgbXBvcywgYiwgbiwgaykge1xuICAgICAgICB2YXIgeiA9IG5ldyBVaW50OEFycmF5KDE2KSwgeCA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgICAgICAgdmFyIHUsIGk7XG4gICAgICAgIGlmICghYikgcmV0dXJuIDA7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDE2OyBpKyspeltpXSA9IDA7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDg7IGkrKyl6W2ldID0gbltpXTtcbiAgICAgICAgd2hpbGUoYiA+PSA2NCl7XG4gICAgICAgICAgICBjcnlwdG9fY29yZV9zYWxzYTIwKHgsIHosIGssIHNpZ21hKTtcbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IDY0OyBpKyspY1tjcG9zICsgaV0gPSAobSA/IG1bbXBvcyArIGldIDogMCkgXiB4W2ldO1xuICAgICAgICAgICAgdSA9IDE7XG4gICAgICAgICAgICBmb3IoaSA9IDg7IGkgPCAxNjsgaSsrKXtcbiAgICAgICAgICAgICAgICB1ID0gdSArICh6W2ldICYgMHhmZikgfCAwO1xuICAgICAgICAgICAgICAgIHpbaV0gPSB1ICYgMHhmZjtcbiAgICAgICAgICAgICAgICB1ID4+Pj0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIgLT0gNjQ7XG4gICAgICAgICAgICBjcG9zICs9IDY0O1xuICAgICAgICAgICAgaWYgKG0pIG1wb3MgKz0gNjQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGIgPiAwKSB7XG4gICAgICAgICAgICBjcnlwdG9fY29yZV9zYWxzYTIwKHgsIHosIGssIHNpZ21hKTtcbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IGI7IGkrKyljW2Nwb3MgKyBpXSA9IChtID8gbVttcG9zICsgaV0gOiAwKSBeIHhbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyeXB0b19zdHJlYW1fc2Fsc2EyMChjLCBjcG9zLCBkLCBuLCBrKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG9fc3RyZWFtX3NhbHNhMjBfeG9yKGMsIGNwb3MsIG51bGwsIDAsIGQsIG4sIGspO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcnlwdG9fc3RyZWFtKGMsIGNwb3MsIGQsIG4sIGspIHtcbiAgICAgICAgdmFyIHMgPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgICAgIGNyeXB0b19jb3JlX2hzYWxzYTIwKHMsIG4sIGssIHNpZ21hKTtcbiAgICAgICAgcmV0dXJuIGNyeXB0b19zdHJlYW1fc2Fsc2EyMChjLCBjcG9zLCBkLCBuLnN1YmFycmF5KDE2KSwgcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyeXB0b19zdHJlYW1feG9yKGMsIGNwb3MsIG0sIG1wb3MsIGQsIG4sIGspIHtcbiAgICAgICAgdmFyIHMgPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgICAgIGNyeXB0b19jb3JlX2hzYWxzYTIwKHMsIG4sIGssIHNpZ21hKTtcbiAgICAgICAgcmV0dXJuIGNyeXB0b19zdHJlYW1fc2Fsc2EyMF94b3IoYywgY3BvcywgbSwgbXBvcywgZCwgbi5zdWJhcnJheSgxNiksIHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGQxMzA1KGgsIGMpIHtcbiAgICAgICAgdmFyIGosIHUgPSAwO1xuICAgICAgICBmb3IoaiA9IDA7IGogPCAxNzsgaisrKXtcbiAgICAgICAgICAgIHUgPSB1ICsgKGhbal0gKyBjW2pdIHwgMCkgfCAwO1xuICAgICAgICAgICAgaFtqXSA9IHUgJiAyNTU7XG4gICAgICAgICAgICB1ID4+Pj0gODtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgbWludXNwID0gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAgICAgNSxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMjUyXG4gICAgXSk7XG4gICAgZnVuY3Rpb24gY3J5cHRvX29uZXRpbWVhdXRoKG91dCwgb3V0cG9zLCBtLCBtcG9zLCBuLCBrKSB7XG4gICAgICAgIHZhciBzLCBpLCBqLCB1O1xuICAgICAgICB2YXIgeCA9IG5ldyBVaW50MzJBcnJheSgxNyksIHIgPSBuZXcgVWludDMyQXJyYXkoMTcpLCBoID0gbmV3IFVpbnQzMkFycmF5KDE3KSwgYyA9IG5ldyBVaW50MzJBcnJheSgxNyksIGcgPSBuZXcgVWludDMyQXJyYXkoMTcpO1xuICAgICAgICBmb3IoaiA9IDA7IGogPCAxNzsgaisrKXJbal0gPSBoW2pdID0gMDtcbiAgICAgICAgZm9yKGogPSAwOyBqIDwgMTY7IGorKylyW2pdID0ga1tqXTtcbiAgICAgICAgclszXSAmPSAxNTtcbiAgICAgICAgcls0XSAmPSAyNTI7XG4gICAgICAgIHJbN10gJj0gMTU7XG4gICAgICAgIHJbOF0gJj0gMjUyO1xuICAgICAgICByWzExXSAmPSAxNTtcbiAgICAgICAgclsxMl0gJj0gMjUyO1xuICAgICAgICByWzE1XSAmPSAxNTtcbiAgICAgICAgd2hpbGUobiA+IDApe1xuICAgICAgICAgICAgZm9yKGogPSAwOyBqIDwgMTc7IGorKyljW2pdID0gMDtcbiAgICAgICAgICAgIGZvcihqID0gMDsgaiA8IDE2ICYmIGogPCBuOyArK2opY1tqXSA9IG1bbXBvcyArIGpdO1xuICAgICAgICAgICAgY1tqXSA9IDE7XG4gICAgICAgICAgICBtcG9zICs9IGo7XG4gICAgICAgICAgICBuIC09IGo7XG4gICAgICAgICAgICBhZGQxMzA1KGgsIGMpO1xuICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgMTc7IGkrKyl7XG4gICAgICAgICAgICAgICAgeFtpXSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yKGogPSAwOyBqIDwgMTc7IGorKyl4W2ldID0geFtpXSArIGhbal0gKiAoaiA8PSBpID8gcltpIC0gal0gOiAzMjAgKiByW2kgKyAxNyAtIGpdIHwgMCkgfCAwIHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IDE3OyBpKyspaFtpXSA9IHhbaV07XG4gICAgICAgICAgICB1ID0gMDtcbiAgICAgICAgICAgIGZvcihqID0gMDsgaiA8IDE2OyBqKyspe1xuICAgICAgICAgICAgICAgIHUgPSB1ICsgaFtqXSB8IDA7XG4gICAgICAgICAgICAgICAgaFtqXSA9IHUgJiAyNTU7XG4gICAgICAgICAgICAgICAgdSA+Pj49IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1ID0gdSArIGhbMTZdIHwgMDtcbiAgICAgICAgICAgIGhbMTZdID0gdSAmIDM7XG4gICAgICAgICAgICB1ID0gNSAqICh1ID4+PiAyKSB8IDA7XG4gICAgICAgICAgICBmb3IoaiA9IDA7IGogPCAxNjsgaisrKXtcbiAgICAgICAgICAgICAgICB1ID0gdSArIGhbal0gfCAwO1xuICAgICAgICAgICAgICAgIGhbal0gPSB1ICYgMjU1O1xuICAgICAgICAgICAgICAgIHUgPj4+PSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdSA9IHUgKyBoWzE2XSB8IDA7XG4gICAgICAgICAgICBoWzE2XSA9IHU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGogPSAwOyBqIDwgMTc7IGorKylnW2pdID0gaFtqXTtcbiAgICAgICAgYWRkMTMwNShoLCBtaW51c3ApO1xuICAgICAgICBzID0gLShoWzE2XSA+Pj4gNykgfCAwO1xuICAgICAgICBmb3IoaiA9IDA7IGogPCAxNzsgaisrKWhbal0gXj0gcyAmIChnW2pdIF4gaFtqXSk7XG4gICAgICAgIGZvcihqID0gMDsgaiA8IDE2OyBqKyspY1tqXSA9IGtbaiArIDE2XTtcbiAgICAgICAgY1sxNl0gPSAwO1xuICAgICAgICBhZGQxMzA1KGgsIGMpO1xuICAgICAgICBmb3IoaiA9IDA7IGogPCAxNjsgaisrKW91dFtvdXRwb3MgKyBqXSA9IGhbal07XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcnlwdG9fb25ldGltZWF1dGhfdmVyaWZ5KGgsIGhwb3MsIG0sIG1wb3MsIG4sIGspIHtcbiAgICAgICAgdmFyIHggPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICAgIGNyeXB0b19vbmV0aW1lYXV0aCh4LCAwLCBtLCBtcG9zLCBuLCBrKTtcbiAgICAgICAgcmV0dXJuIGNyeXB0b192ZXJpZnlfMTYoaCwgaHBvcywgeCwgMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyeXB0b19zZWNyZXRib3goYywgbSwgZCwgbiwgaykge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgaWYgKGQgPCAzMikgcmV0dXJuIC0xO1xuICAgICAgICBjcnlwdG9fc3RyZWFtX3hvcihjLCAwLCBtLCAwLCBkLCBuLCBrKTtcbiAgICAgICAgY3J5cHRvX29uZXRpbWVhdXRoKGMsIDE2LCBjLCAzMiwgZCAtIDMyLCBjKTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgMTY7IGkrKyljW2ldID0gMDtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyeXB0b19zZWNyZXRib3hfb3BlbihtLCBjLCBkLCBuLCBrKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgeCA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgICAgICAgaWYgKGQgPCAzMikgcmV0dXJuIC0xO1xuICAgICAgICBjcnlwdG9fc3RyZWFtKHgsIDAsIDMyLCBuLCBrKTtcbiAgICAgICAgaWYgKGNyeXB0b19vbmV0aW1lYXV0aF92ZXJpZnkoYywgMTYsIGMsIDMyLCBkIC0gMzIsIHgpICE9PSAwKSByZXR1cm4gLTE7XG4gICAgICAgIGNyeXB0b19zdHJlYW1feG9yKG0sIDAsIGMsIDAsIGQsIG4sIGspO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCAzMjsgaSsrKW1baV0gPSAwO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0MjU1MTkociwgYSkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgMTY7IGkrKylyW2ldID0gYVtpXSB8IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhcjI1NTE5KG8pIHtcbiAgICAgICAgdmFyIGM7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCAxNjsgaSsrKXtcbiAgICAgICAgICAgIG9baV0gKz0gNjU1MzY7XG4gICAgICAgICAgICBjID0gTWF0aC5mbG9vcihvW2ldIC8gNjU1MzYpO1xuICAgICAgICAgICAgb1soaSArIDEpICogKGkgPCAxNSA/IDEgOiAwKV0gKz0gYyAtIDEgKyAzNyAqIChjIC0gMSkgKiAoaSA9PT0gMTUgPyAxIDogMCk7XG4gICAgICAgICAgICBvW2ldIC09IGMgKiA2NTUzNjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzZWwyNTUxOShwLCBxLCBiKSB7XG4gICAgICAgIHZhciB0LCBjID0gfihiIC0gMSk7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKXtcbiAgICAgICAgICAgIHQgPSBjICYgKHBbaV0gXiBxW2ldKTtcbiAgICAgICAgICAgIHBbaV0gXj0gdDtcbiAgICAgICAgICAgIHFbaV0gXj0gdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwYWNrMjU1MTkobywgbikge1xuICAgICAgICB2YXIgaSwgaiwgYjtcbiAgICAgICAgdmFyIG0gPSBnZigpLCB0ID0gZ2YoKTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgMTY7IGkrKyl0W2ldID0gbltpXTtcbiAgICAgICAgY2FyMjU1MTkodCk7XG4gICAgICAgIGNhcjI1NTE5KHQpO1xuICAgICAgICBjYXIyNTUxOSh0KTtcbiAgICAgICAgZm9yKGogPSAwOyBqIDwgMjsgaisrKXtcbiAgICAgICAgICAgIG1bMF0gPSB0WzBdIC0gMHhmZmVkO1xuICAgICAgICAgICAgZm9yKGkgPSAxOyBpIDwgMTU7IGkrKyl7XG4gICAgICAgICAgICAgICAgbVtpXSA9IHRbaV0gLSAweGZmZmYgLSAobVtpIC0gMV0gPj4gMTYgJiAxKTtcbiAgICAgICAgICAgICAgICBtW2kgLSAxXSAmPSAweGZmZmY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtWzE1XSA9IHRbMTVdIC0gMHg3ZmZmIC0gKG1bMTRdID4+IDE2ICYgMSk7XG4gICAgICAgICAgICBiID0gbVsxNV0gPj4gMTYgJiAxO1xuICAgICAgICAgICAgbVsxNF0gJj0gMHhmZmZmO1xuICAgICAgICAgICAgc2VsMjU1MTkodCwgbSwgMSAtIGIpO1xuICAgICAgICB9XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDE2OyBpKyspe1xuICAgICAgICAgICAgb1syICogaV0gPSB0W2ldICYgMHhmZjtcbiAgICAgICAgICAgIG9bMiAqIGkgKyAxXSA9IHRbaV0gPj4gODtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBuZXEyNTUxOShhLCBiKSB7XG4gICAgICAgIHZhciBjID0gbmV3IFVpbnQ4QXJyYXkoMzIpLCBkID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICAgICAgICBwYWNrMjU1MTkoYywgYSk7XG4gICAgICAgIHBhY2syNTUxOShkLCBiKTtcbiAgICAgICAgcmV0dXJuIGNyeXB0b192ZXJpZnlfMzIoYywgMCwgZCwgMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcjI1NTE5KGEpIHtcbiAgICAgICAgdmFyIGQgPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgICAgIHBhY2syNTUxOShkLCBhKTtcbiAgICAgICAgcmV0dXJuIGRbMF0gJiAxO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bnBhY2syNTUxOShvLCBuKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCAxNjsgaSsrKW9baV0gPSBuWzIgKiBpXSArIChuWzIgKiBpICsgMV0gPDwgOCk7XG4gICAgICAgIG9bMTVdICY9IDB4N2ZmZjtcbiAgICB9XG4gICAgZnVuY3Rpb24gQShvLCBhLCBiKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCAxNjsgaSsrKW9baV0gPSBhW2ldICsgYltpXSB8IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFoobywgYSwgYikge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgMTY7IGkrKylvW2ldID0gYVtpXSAtIGJbaV0gfCAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBNKG8sIGEsIGIpIHtcbiAgICAgICAgdmFyIGksIGosIHQgPSBuZXcgRmxvYXQ2NEFycmF5KDMxKTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgMzE7IGkrKyl0W2ldID0gMDtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgMTY7IGkrKyl7XG4gICAgICAgICAgICBmb3IoaiA9IDA7IGogPCAxNjsgaisrKXtcbiAgICAgICAgICAgICAgICB0W2kgKyBqXSArPSBhW2ldICogYltqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IoaSA9IDA7IGkgPCAxNTsgaSsrKXtcbiAgICAgICAgICAgIHRbaV0gKz0gMzggKiB0W2kgKyAxNl07XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgMTY7IGkrKylvW2ldID0gdFtpXTtcbiAgICAgICAgY2FyMjU1MTkobyk7XG4gICAgICAgIGNhcjI1NTE5KG8pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBTKG8sIGEpIHtcbiAgICAgICAgTShvLCBhLCBhKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW52MjU1MTkobywgaSkge1xuICAgICAgICB2YXIgYyA9IGdmKCk7XG4gICAgICAgIHZhciBhO1xuICAgICAgICBmb3IoYSA9IDA7IGEgPCAxNjsgYSsrKWNbYV0gPSBpW2FdO1xuICAgICAgICBmb3IoYSA9IDI1MzsgYSA+PSAwOyBhLS0pe1xuICAgICAgICAgICAgUyhjLCBjKTtcbiAgICAgICAgICAgIGlmIChhICE9PSAyICYmIGEgIT09IDQpIE0oYywgYywgaSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGEgPSAwOyBhIDwgMTY7IGErKylvW2FdID0gY1thXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG93MjUyMyhvLCBpKSB7XG4gICAgICAgIHZhciBjID0gZ2YoKTtcbiAgICAgICAgdmFyIGE7XG4gICAgICAgIGZvcihhID0gMDsgYSA8IDE2OyBhKyspY1thXSA9IGlbYV07XG4gICAgICAgIGZvcihhID0gMjUwOyBhID49IDA7IGEtLSl7XG4gICAgICAgICAgICBTKGMsIGMpO1xuICAgICAgICAgICAgaWYgKGEgIT09IDEpIE0oYywgYywgaSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGEgPSAwOyBhIDwgMTY7IGErKylvW2FdID0gY1thXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3J5cHRvX3NjYWxhcm11bHQocSwgbiwgcCkge1xuICAgICAgICB2YXIgeiA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgICAgICAgdmFyIHggPSBuZXcgRmxvYXQ2NEFycmF5KDgwKSwgciwgaTtcbiAgICAgICAgdmFyIGEgPSBnZigpLCBiID0gZ2YoKSwgYyA9IGdmKCksIGQgPSBnZigpLCBlID0gZ2YoKSwgZiA9IGdmKCk7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDMxOyBpKyspeltpXSA9IG5baV07XG4gICAgICAgIHpbMzFdID0gblszMV0gJiAxMjcgfCA2NDtcbiAgICAgICAgelswXSAmPSAyNDg7XG4gICAgICAgIHVucGFjazI1NTE5KHgsIHApO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCAxNjsgaSsrKXtcbiAgICAgICAgICAgIGJbaV0gPSB4W2ldO1xuICAgICAgICAgICAgZFtpXSA9IGFbaV0gPSBjW2ldID0gMDtcbiAgICAgICAgfVxuICAgICAgICBhWzBdID0gZFswXSA9IDE7XG4gICAgICAgIGZvcihpID0gMjU0OyBpID49IDA7IC0taSl7XG4gICAgICAgICAgICByID0geltpID4+PiAzXSA+Pj4gKGkgJiA3KSAmIDE7XG4gICAgICAgICAgICBzZWwyNTUxOShhLCBiLCByKTtcbiAgICAgICAgICAgIHNlbDI1NTE5KGMsIGQsIHIpO1xuICAgICAgICAgICAgQShlLCBhLCBjKTtcbiAgICAgICAgICAgIFooYSwgYSwgYyk7XG4gICAgICAgICAgICBBKGMsIGIsIGQpO1xuICAgICAgICAgICAgWihiLCBiLCBkKTtcbiAgICAgICAgICAgIFMoZCwgZSk7XG4gICAgICAgICAgICBTKGYsIGEpO1xuICAgICAgICAgICAgTShhLCBjLCBhKTtcbiAgICAgICAgICAgIE0oYywgYiwgZSk7XG4gICAgICAgICAgICBBKGUsIGEsIGMpO1xuICAgICAgICAgICAgWihhLCBhLCBjKTtcbiAgICAgICAgICAgIFMoYiwgYSk7XG4gICAgICAgICAgICBaKGMsIGQsIGYpO1xuICAgICAgICAgICAgTShhLCBjLCBfMTIxNjY1KTtcbiAgICAgICAgICAgIEEoYSwgYSwgZCk7XG4gICAgICAgICAgICBNKGMsIGMsIGEpO1xuICAgICAgICAgICAgTShhLCBkLCBmKTtcbiAgICAgICAgICAgIE0oZCwgYiwgeCk7XG4gICAgICAgICAgICBTKGIsIGUpO1xuICAgICAgICAgICAgc2VsMjU1MTkoYSwgYiwgcik7XG4gICAgICAgICAgICBzZWwyNTUxOShjLCBkLCByKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IoaSA9IDA7IGkgPCAxNjsgaSsrKXtcbiAgICAgICAgICAgIHhbaSArIDE2XSA9IGFbaV07XG4gICAgICAgICAgICB4W2kgKyAzMl0gPSBjW2ldO1xuICAgICAgICAgICAgeFtpICsgNDhdID0gYltpXTtcbiAgICAgICAgICAgIHhbaSArIDY0XSA9IGRbaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHgzMiA9IHguc3ViYXJyYXkoMzIpO1xuICAgICAgICB2YXIgeDE2ID0geC5zdWJhcnJheSgxNik7XG4gICAgICAgIGludjI1NTE5KHgzMiwgeDMyKTtcbiAgICAgICAgTSh4MTYsIHgxNiwgeDMyKTtcbiAgICAgICAgcGFjazI1NTE5KHEsIHgxNik7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcnlwdG9fc2NhbGFybXVsdF9iYXNlKHEsIG4pIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0b19zY2FsYXJtdWx0KHEsIG4sIF85KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3J5cHRvX2JveF9rZXlwYWlyKHksIHgpIHtcbiAgICAgICAgcmFuZG9tYnl0ZXMoeCwgMzIpO1xuICAgICAgICByZXR1cm4gY3J5cHRvX3NjYWxhcm11bHRfYmFzZSh5LCB4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3J5cHRvX2JveF9iZWZvcmVubShrLCB5LCB4KSB7XG4gICAgICAgIHZhciBzID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICAgICAgICBjcnlwdG9fc2NhbGFybXVsdChzLCB4LCB5KTtcbiAgICAgICAgcmV0dXJuIGNyeXB0b19jb3JlX2hzYWxzYTIwKGssIF8wLCBzLCBzaWdtYSk7XG4gICAgfVxuICAgIHZhciBjcnlwdG9fYm94X2FmdGVybm0gPSBjcnlwdG9fc2VjcmV0Ym94O1xuICAgIHZhciBjcnlwdG9fYm94X29wZW5fYWZ0ZXJubSA9IGNyeXB0b19zZWNyZXRib3hfb3BlbjtcbiAgICBmdW5jdGlvbiBjcnlwdG9fYm94KGMsIG0sIGQsIG4sIHksIHgpIHtcbiAgICAgICAgdmFyIGsgPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgICAgIGNyeXB0b19ib3hfYmVmb3Jlbm0oaywgeSwgeCk7XG4gICAgICAgIHJldHVybiBjcnlwdG9fYm94X2FmdGVybm0oYywgbSwgZCwgbiwgayk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyeXB0b19ib3hfb3BlbihtLCBjLCBkLCBuLCB5LCB4KSB7XG4gICAgICAgIHZhciBrID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICAgICAgICBjcnlwdG9fYm94X2JlZm9yZW5tKGssIHksIHgpO1xuICAgICAgICByZXR1cm4gY3J5cHRvX2JveF9vcGVuX2FmdGVybm0obSwgYywgZCwgbiwgayk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZDY0KCkge1xuICAgICAgICB2YXIgYSA9IDAsIGIgPSAwLCBjID0gMCwgZCA9IDAsIG0xNiA9IDY1NTM1LCBsLCBoLCBpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgbCA9IGFyZ3VtZW50c1tpXS5sbztcbiAgICAgICAgICAgIGggPSBhcmd1bWVudHNbaV0uaGk7XG4gICAgICAgICAgICBhICs9IGwgJiBtMTY7XG4gICAgICAgICAgICBiICs9IGwgPj4+IDE2O1xuICAgICAgICAgICAgYyArPSBoICYgbTE2O1xuICAgICAgICAgICAgZCArPSBoID4+PiAxNjtcbiAgICAgICAgfVxuICAgICAgICBiICs9IGEgPj4+IDE2O1xuICAgICAgICBjICs9IGIgPj4+IDE2O1xuICAgICAgICBkICs9IGMgPj4+IDE2O1xuICAgICAgICByZXR1cm4gbmV3IHU2NChjICYgbTE2IHwgZCA8PCAxNiwgYSAmIG0xNiB8IGIgPDwgMTYpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaHI2NCh4LCBjKSB7XG4gICAgICAgIHJldHVybiBuZXcgdTY0KHguaGkgPj4+IGMsIHgubG8gPj4+IGMgfCB4LmhpIDw8IDMyIC0gYyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHhvcjY0KCkge1xuICAgICAgICB2YXIgbCA9IDAsIGggPSAwLCBpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgbCBePSBhcmd1bWVudHNbaV0ubG87XG4gICAgICAgICAgICBoIF49IGFyZ3VtZW50c1tpXS5oaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IHU2NChoLCBsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUih4LCBjKSB7XG4gICAgICAgIHZhciBoLCBsLCBjMSA9IDMyIC0gYztcbiAgICAgICAgaWYgKGMgPCAzMikge1xuICAgICAgICAgICAgaCA9IHguaGkgPj4+IGMgfCB4LmxvIDw8IGMxO1xuICAgICAgICAgICAgbCA9IHgubG8gPj4+IGMgfCB4LmhpIDw8IGMxO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPCA2NCkge1xuICAgICAgICAgICAgaCA9IHgubG8gPj4+IGMgfCB4LmhpIDw8IGMxO1xuICAgICAgICAgICAgbCA9IHguaGkgPj4+IGMgfCB4LmxvIDw8IGMxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgdTY0KGgsIGwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBDaCh4LCB5LCB6KSB7XG4gICAgICAgIHZhciBoID0geC5oaSAmIHkuaGkgXiB+eC5oaSAmIHouaGksIGwgPSB4LmxvICYgeS5sbyBeIH54LmxvICYgei5sbztcbiAgICAgICAgcmV0dXJuIG5ldyB1NjQoaCwgbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE1haih4LCB5LCB6KSB7XG4gICAgICAgIHZhciBoID0geC5oaSAmIHkuaGkgXiB4LmhpICYgei5oaSBeIHkuaGkgJiB6LmhpLCBsID0geC5sbyAmIHkubG8gXiB4LmxvICYgei5sbyBeIHkubG8gJiB6LmxvO1xuICAgICAgICByZXR1cm4gbmV3IHU2NChoLCBsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gU2lnbWEwKHgpIHtcbiAgICAgICAgcmV0dXJuIHhvcjY0KFIoeCwgMjgpLCBSKHgsIDM0KSwgUih4LCAzOSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBTaWdtYTEoeCkge1xuICAgICAgICByZXR1cm4geG9yNjQoUih4LCAxNCksIFIoeCwgMTgpLCBSKHgsIDQxKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNpZ21hMCh4KSB7XG4gICAgICAgIHJldHVybiB4b3I2NChSKHgsIDEpLCBSKHgsIDgpLCBzaHI2NCh4LCA3KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNpZ21hMSh4KSB7XG4gICAgICAgIHJldHVybiB4b3I2NChSKHgsIDE5KSwgUih4LCA2MSksIHNocjY0KHgsIDYpKTtcbiAgICB9XG4gICAgdmFyIEsgPSBbXG4gICAgICAgIG5ldyB1NjQoMHg0MjhhMmY5OCwgMHhkNzI4YWUyMiksXG4gICAgICAgIG5ldyB1NjQoMHg3MTM3NDQ5MSwgMHgyM2VmNjVjZCksXG4gICAgICAgIG5ldyB1NjQoMHhiNWMwZmJjZiwgMHhlYzRkM2IyZiksXG4gICAgICAgIG5ldyB1NjQoMHhlOWI1ZGJhNSwgMHg4MTg5ZGJiYyksXG4gICAgICAgIG5ldyB1NjQoMHgzOTU2YzI1YiwgMHhmMzQ4YjUzOCksXG4gICAgICAgIG5ldyB1NjQoMHg1OWYxMTFmMSwgMHhiNjA1ZDAxOSksXG4gICAgICAgIG5ldyB1NjQoMHg5MjNmODJhNCwgMHhhZjE5NGY5YiksXG4gICAgICAgIG5ldyB1NjQoMHhhYjFjNWVkNSwgMHhkYTZkODExOCksXG4gICAgICAgIG5ldyB1NjQoMHhkODA3YWE5OCwgMHhhMzAzMDI0MiksXG4gICAgICAgIG5ldyB1NjQoMHgxMjgzNWIwMSwgMHg0NTcwNmZiZSksXG4gICAgICAgIG5ldyB1NjQoMHgyNDMxODViZSwgMHg0ZWU0YjI4YyksXG4gICAgICAgIG5ldyB1NjQoMHg1NTBjN2RjMywgMHhkNWZmYjRlMiksXG4gICAgICAgIG5ldyB1NjQoMHg3MmJlNWQ3NCwgMHhmMjdiODk2ZiksXG4gICAgICAgIG5ldyB1NjQoMHg4MGRlYjFmZSwgMHgzYjE2OTZiMSksXG4gICAgICAgIG5ldyB1NjQoMHg5YmRjMDZhNywgMHgyNWM3MTIzNSksXG4gICAgICAgIG5ldyB1NjQoMHhjMTliZjE3NCwgMHhjZjY5MjY5NCksXG4gICAgICAgIG5ldyB1NjQoMHhlNDliNjljMSwgMHg5ZWYxNGFkMiksXG4gICAgICAgIG5ldyB1NjQoMHhlZmJlNDc4NiwgMHgzODRmMjVlMyksXG4gICAgICAgIG5ldyB1NjQoMHgwZmMxOWRjNiwgMHg4YjhjZDViNSksXG4gICAgICAgIG5ldyB1NjQoMHgyNDBjYTFjYywgMHg3N2FjOWM2NSksXG4gICAgICAgIG5ldyB1NjQoMHgyZGU5MmM2ZiwgMHg1OTJiMDI3NSksXG4gICAgICAgIG5ldyB1NjQoMHg0YTc0ODRhYSwgMHg2ZWE2ZTQ4MyksXG4gICAgICAgIG5ldyB1NjQoMHg1Y2IwYTlkYywgMHhiZDQxZmJkNCksXG4gICAgICAgIG5ldyB1NjQoMHg3NmY5ODhkYSwgMHg4MzExNTNiNSksXG4gICAgICAgIG5ldyB1NjQoMHg5ODNlNTE1MiwgMHhlZTY2ZGZhYiksXG4gICAgICAgIG5ldyB1NjQoMHhhODMxYzY2ZCwgMHgyZGI0MzIxMCksXG4gICAgICAgIG5ldyB1NjQoMHhiMDAzMjdjOCwgMHg5OGZiMjEzZiksXG4gICAgICAgIG5ldyB1NjQoMHhiZjU5N2ZjNywgMHhiZWVmMGVlNCksXG4gICAgICAgIG5ldyB1NjQoMHhjNmUwMGJmMywgMHgzZGE4OGZjMiksXG4gICAgICAgIG5ldyB1NjQoMHhkNWE3OTE0NywgMHg5MzBhYTcyNSksXG4gICAgICAgIG5ldyB1NjQoMHgwNmNhNjM1MSwgMHhlMDAzODI2ZiksXG4gICAgICAgIG5ldyB1NjQoMHgxNDI5Mjk2NywgMHgwYTBlNmU3MCksXG4gICAgICAgIG5ldyB1NjQoMHgyN2I3MGE4NSwgMHg0NmQyMmZmYyksXG4gICAgICAgIG5ldyB1NjQoMHgyZTFiMjEzOCwgMHg1YzI2YzkyNiksXG4gICAgICAgIG5ldyB1NjQoMHg0ZDJjNmRmYywgMHg1YWM0MmFlZCksXG4gICAgICAgIG5ldyB1NjQoMHg1MzM4MGQxMywgMHg5ZDk1YjNkZiksXG4gICAgICAgIG5ldyB1NjQoMHg2NTBhNzM1NCwgMHg4YmFmNjNkZSksXG4gICAgICAgIG5ldyB1NjQoMHg3NjZhMGFiYiwgMHgzYzc3YjJhOCksXG4gICAgICAgIG5ldyB1NjQoMHg4MWMyYzkyZSwgMHg0N2VkYWVlNiksXG4gICAgICAgIG5ldyB1NjQoMHg5MjcyMmM4NSwgMHgxNDgyMzUzYiksXG4gICAgICAgIG5ldyB1NjQoMHhhMmJmZThhMSwgMHg0Y2YxMDM2NCksXG4gICAgICAgIG5ldyB1NjQoMHhhODFhNjY0YiwgMHhiYzQyMzAwMSksXG4gICAgICAgIG5ldyB1NjQoMHhjMjRiOGI3MCwgMHhkMGY4OTc5MSksXG4gICAgICAgIG5ldyB1NjQoMHhjNzZjNTFhMywgMHgwNjU0YmUzMCksXG4gICAgICAgIG5ldyB1NjQoMHhkMTkyZTgxOSwgMHhkNmVmNTIxOCksXG4gICAgICAgIG5ldyB1NjQoMHhkNjk5MDYyNCwgMHg1NTY1YTkxMCksXG4gICAgICAgIG5ldyB1NjQoMHhmNDBlMzU4NSwgMHg1NzcxMjAyYSksXG4gICAgICAgIG5ldyB1NjQoMHgxMDZhYTA3MCwgMHgzMmJiZDFiOCksXG4gICAgICAgIG5ldyB1NjQoMHgxOWE0YzExNiwgMHhiOGQyZDBjOCksXG4gICAgICAgIG5ldyB1NjQoMHgxZTM3NmMwOCwgMHg1MTQxYWI1MyksXG4gICAgICAgIG5ldyB1NjQoMHgyNzQ4Nzc0YywgMHhkZjhlZWI5OSksXG4gICAgICAgIG5ldyB1NjQoMHgzNGIwYmNiNSwgMHhlMTliNDhhOCksXG4gICAgICAgIG5ldyB1NjQoMHgzOTFjMGNiMywgMHhjNWM5NWE2MyksXG4gICAgICAgIG5ldyB1NjQoMHg0ZWQ4YWE0YSwgMHhlMzQxOGFjYiksXG4gICAgICAgIG5ldyB1NjQoMHg1YjljY2E0ZiwgMHg3NzYzZTM3MyksXG4gICAgICAgIG5ldyB1NjQoMHg2ODJlNmZmMywgMHhkNmIyYjhhMyksXG4gICAgICAgIG5ldyB1NjQoMHg3NDhmODJlZSwgMHg1ZGVmYjJmYyksXG4gICAgICAgIG5ldyB1NjQoMHg3OGE1NjM2ZiwgMHg0MzE3MmY2MCksXG4gICAgICAgIG5ldyB1NjQoMHg4NGM4NzgxNCwgMHhhMWYwYWI3MiksXG4gICAgICAgIG5ldyB1NjQoMHg4Y2M3MDIwOCwgMHgxYTY0MzllYyksXG4gICAgICAgIG5ldyB1NjQoMHg5MGJlZmZmYSwgMHgyMzYzMWUyOCksXG4gICAgICAgIG5ldyB1NjQoMHhhNDUwNmNlYiwgMHhkZTgyYmRlOSksXG4gICAgICAgIG5ldyB1NjQoMHhiZWY5YTNmNywgMHhiMmM2NzkxNSksXG4gICAgICAgIG5ldyB1NjQoMHhjNjcxNzhmMiwgMHhlMzcyNTMyYiksXG4gICAgICAgIG5ldyB1NjQoMHhjYTI3M2VjZSwgMHhlYTI2NjE5YyksXG4gICAgICAgIG5ldyB1NjQoMHhkMTg2YjhjNywgMHgyMWMwYzIwNyksXG4gICAgICAgIG5ldyB1NjQoMHhlYWRhN2RkNiwgMHhjZGUwZWIxZSksXG4gICAgICAgIG5ldyB1NjQoMHhmNTdkNGY3ZiwgMHhlZTZlZDE3OCksXG4gICAgICAgIG5ldyB1NjQoMHgwNmYwNjdhYSwgMHg3MjE3NmZiYSksXG4gICAgICAgIG5ldyB1NjQoMHgwYTYzN2RjNSwgMHhhMmM4OThhNiksXG4gICAgICAgIG5ldyB1NjQoMHgxMTNmOTgwNCwgMHhiZWY5MGRhZSksXG4gICAgICAgIG5ldyB1NjQoMHgxYjcxMGIzNSwgMHgxMzFjNDcxYiksXG4gICAgICAgIG5ldyB1NjQoMHgyOGRiNzdmNSwgMHgyMzA0N2Q4NCksXG4gICAgICAgIG5ldyB1NjQoMHgzMmNhYWI3YiwgMHg0MGM3MjQ5MyksXG4gICAgICAgIG5ldyB1NjQoMHgzYzllYmUwYSwgMHgxNWM5YmViYyksXG4gICAgICAgIG5ldyB1NjQoMHg0MzFkNjdjNCwgMHg5YzEwMGQ0YyksXG4gICAgICAgIG5ldyB1NjQoMHg0Y2M1ZDRiZSwgMHhjYjNlNDJiNiksXG4gICAgICAgIG5ldyB1NjQoMHg1OTdmMjk5YywgMHhmYzY1N2UyYSksXG4gICAgICAgIG5ldyB1NjQoMHg1ZmNiNmZhYiwgMHgzYWQ2ZmFlYyksXG4gICAgICAgIG5ldyB1NjQoMHg2YzQ0MTk4YywgMHg0YTQ3NTgxNylcbiAgICBdO1xuICAgIGZ1bmN0aW9uIGNyeXB0b19oYXNoYmxvY2tzKHgsIG0sIG4pIHtcbiAgICAgICAgdmFyIHogPSBbXSwgYiA9IFtdLCBhID0gW10sIHcgPSBbXSwgdCwgaSwgajtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgODsgaSsrKXpbaV0gPSBhW2ldID0gZGw2NCh4LCA4ICogaSk7XG4gICAgICAgIHZhciBwb3MgPSAwO1xuICAgICAgICB3aGlsZShuID49IDEyOCl7XG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCAxNjsgaSsrKXdbaV0gPSBkbDY0KG0sIDggKiBpICsgcG9zKTtcbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IDgwOyBpKyspe1xuICAgICAgICAgICAgICAgIGZvcihqID0gMDsgaiA8IDg7IGorKyliW2pdID0gYVtqXTtcbiAgICAgICAgICAgICAgICB0ID0gYWRkNjQoYVs3XSwgU2lnbWExKGFbNF0pLCBDaChhWzRdLCBhWzVdLCBhWzZdKSwgS1tpXSwgd1tpICUgMTZdKTtcbiAgICAgICAgICAgICAgICBiWzddID0gYWRkNjQodCwgU2lnbWEwKGFbMF0pLCBNYWooYVswXSwgYVsxXSwgYVsyXSkpO1xuICAgICAgICAgICAgICAgIGJbM10gPSBhZGQ2NChiWzNdLCB0KTtcbiAgICAgICAgICAgICAgICBmb3IoaiA9IDA7IGogPCA4OyBqKyspYVsoaiArIDEpICUgOF0gPSBiW2pdO1xuICAgICAgICAgICAgICAgIGlmIChpICUgMTYgPT09IDE1KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcihqID0gMDsgaiA8IDE2OyBqKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgd1tqXSA9IGFkZDY0KHdbal0sIHdbKGogKyA5KSAlIDE2XSwgc2lnbWEwKHdbKGogKyAxKSAlIDE2XSksIHNpZ21hMSh3WyhqICsgMTQpICUgMTZdKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCA4OyBpKyspe1xuICAgICAgICAgICAgICAgIGFbaV0gPSBhZGQ2NChhW2ldLCB6W2ldKTtcbiAgICAgICAgICAgICAgICB6W2ldID0gYVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyArPSAxMjg7XG4gICAgICAgICAgICBuIC09IDEyODtcbiAgICAgICAgfVxuICAgICAgICBmb3IoaSA9IDA7IGkgPCA4OyBpKyspdHM2NCh4LCA4ICogaSwgeltpXSk7XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgICB2YXIgaXYgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAgIDB4NmEsXG4gICAgICAgIDB4MDksXG4gICAgICAgIDB4ZTYsXG4gICAgICAgIDB4NjcsXG4gICAgICAgIDB4ZjMsXG4gICAgICAgIDB4YmMsXG4gICAgICAgIDB4YzksXG4gICAgICAgIDB4MDgsXG4gICAgICAgIDB4YmIsXG4gICAgICAgIDB4NjcsXG4gICAgICAgIDB4YWUsXG4gICAgICAgIDB4ODUsXG4gICAgICAgIDB4ODQsXG4gICAgICAgIDB4Y2EsXG4gICAgICAgIDB4YTcsXG4gICAgICAgIDB4M2IsXG4gICAgICAgIDB4M2MsXG4gICAgICAgIDB4NmUsXG4gICAgICAgIDB4ZjMsXG4gICAgICAgIDB4NzIsXG4gICAgICAgIDB4ZmUsXG4gICAgICAgIDB4OTQsXG4gICAgICAgIDB4ZjgsXG4gICAgICAgIDB4MmIsXG4gICAgICAgIDB4YTUsXG4gICAgICAgIDB4NGYsXG4gICAgICAgIDB4ZjUsXG4gICAgICAgIDB4M2EsXG4gICAgICAgIDB4NWYsXG4gICAgICAgIDB4MWQsXG4gICAgICAgIDB4MzYsXG4gICAgICAgIDB4ZjEsXG4gICAgICAgIDB4NTEsXG4gICAgICAgIDB4MGUsXG4gICAgICAgIDB4NTIsXG4gICAgICAgIDB4N2YsXG4gICAgICAgIDB4YWQsXG4gICAgICAgIDB4ZTYsXG4gICAgICAgIDB4ODIsXG4gICAgICAgIDB4ZDEsXG4gICAgICAgIDB4OWIsXG4gICAgICAgIDB4MDUsXG4gICAgICAgIDB4NjgsXG4gICAgICAgIDB4OGMsXG4gICAgICAgIDB4MmIsXG4gICAgICAgIDB4M2UsXG4gICAgICAgIDB4NmMsXG4gICAgICAgIDB4MWYsXG4gICAgICAgIDB4MWYsXG4gICAgICAgIDB4ODMsXG4gICAgICAgIDB4ZDksXG4gICAgICAgIDB4YWIsXG4gICAgICAgIDB4ZmIsXG4gICAgICAgIDB4NDEsXG4gICAgICAgIDB4YmQsXG4gICAgICAgIDB4NmIsXG4gICAgICAgIDB4NWIsXG4gICAgICAgIDB4ZTAsXG4gICAgICAgIDB4Y2QsXG4gICAgICAgIDB4MTksXG4gICAgICAgIDB4MTMsXG4gICAgICAgIDB4N2UsXG4gICAgICAgIDB4MjEsXG4gICAgICAgIDB4NzlcbiAgICBdKTtcbiAgICBmdW5jdGlvbiBjcnlwdG9faGFzaChvdXQsIG0sIG4pIHtcbiAgICAgICAgdmFyIGggPSBuZXcgVWludDhBcnJheSg2NCksIHggPSBuZXcgVWludDhBcnJheSgyNTYpO1xuICAgICAgICB2YXIgaSwgYiA9IG47XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDY0OyBpKyspaFtpXSA9IGl2W2ldO1xuICAgICAgICBjcnlwdG9faGFzaGJsb2NrcyhoLCBtLCBuKTtcbiAgICAgICAgbiAlPSAxMjg7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDI1NjsgaSsrKXhbaV0gPSAwO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCBuOyBpKyspeFtpXSA9IG1bYiAtIG4gKyBpXTtcbiAgICAgICAgeFtuXSA9IDEyODtcbiAgICAgICAgbiA9IDI1NiAtIDEyOCAqIChuIDwgMTEyID8gMSA6IDApO1xuICAgICAgICB4W24gLSA5XSA9IDA7XG4gICAgICAgIHRzNjQoeCwgbiAtIDgsIG5ldyB1NjQoYiAvIDB4MjAwMDAwMDAgfCAwLCBiIDw8IDMpKTtcbiAgICAgICAgY3J5cHRvX2hhc2hibG9ja3MoaCwgeCwgbik7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDY0OyBpKyspb3V0W2ldID0gaFtpXTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZChwLCBxKSB7XG4gICAgICAgIHZhciBhID0gZ2YoKSwgYiA9IGdmKCksIGMgPSBnZigpLCBkID0gZ2YoKSwgZSA9IGdmKCksIGYgPSBnZigpLCBnID0gZ2YoKSwgaCA9IGdmKCksIHQgPSBnZigpO1xuICAgICAgICBaKGEsIHBbMV0sIHBbMF0pO1xuICAgICAgICBaKHQsIHFbMV0sIHFbMF0pO1xuICAgICAgICBNKGEsIGEsIHQpO1xuICAgICAgICBBKGIsIHBbMF0sIHBbMV0pO1xuICAgICAgICBBKHQsIHFbMF0sIHFbMV0pO1xuICAgICAgICBNKGIsIGIsIHQpO1xuICAgICAgICBNKGMsIHBbM10sIHFbM10pO1xuICAgICAgICBNKGMsIGMsIEQyKTtcbiAgICAgICAgTShkLCBwWzJdLCBxWzJdKTtcbiAgICAgICAgQShkLCBkLCBkKTtcbiAgICAgICAgWihlLCBiLCBhKTtcbiAgICAgICAgWihmLCBkLCBjKTtcbiAgICAgICAgQShnLCBkLCBjKTtcbiAgICAgICAgQShoLCBiLCBhKTtcbiAgICAgICAgTShwWzBdLCBlLCBmKTtcbiAgICAgICAgTShwWzFdLCBoLCBnKTtcbiAgICAgICAgTShwWzJdLCBnLCBmKTtcbiAgICAgICAgTShwWzNdLCBlLCBoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3N3YXAocCwgcSwgYikge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgNDsgaSsrKXtcbiAgICAgICAgICAgIHNlbDI1NTE5KHBbaV0sIHFbaV0sIGIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhY2sociwgcCkge1xuICAgICAgICB2YXIgdHggPSBnZigpLCB0eSA9IGdmKCksIHppID0gZ2YoKTtcbiAgICAgICAgaW52MjU1MTkoemksIHBbMl0pO1xuICAgICAgICBNKHR4LCBwWzBdLCB6aSk7XG4gICAgICAgIE0odHksIHBbMV0sIHppKTtcbiAgICAgICAgcGFjazI1NTE5KHIsIHR5KTtcbiAgICAgICAgclszMV0gXj0gcGFyMjU1MTkodHgpIDw8IDc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYWxhcm11bHQocCwgcSwgcykge1xuICAgICAgICB2YXIgYiwgaTtcbiAgICAgICAgc2V0MjU1MTkocFswXSwgZ2YwKTtcbiAgICAgICAgc2V0MjU1MTkocFsxXSwgZ2YxKTtcbiAgICAgICAgc2V0MjU1MTkocFsyXSwgZ2YxKTtcbiAgICAgICAgc2V0MjU1MTkocFszXSwgZ2YwKTtcbiAgICAgICAgZm9yKGkgPSAyNTU7IGkgPj0gMDsgLS1pKXtcbiAgICAgICAgICAgIGIgPSBzW2kgLyA4IHwgMF0gPj4gKGkgJiA3KSAmIDE7XG4gICAgICAgICAgICBjc3dhcChwLCBxLCBiKTtcbiAgICAgICAgICAgIGFkZChxLCBwKTtcbiAgICAgICAgICAgIGFkZChwLCBwKTtcbiAgICAgICAgICAgIGNzd2FwKHAsIHEsIGIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYWxhcmJhc2UocCwgcykge1xuICAgICAgICB2YXIgcSA9IFtcbiAgICAgICAgICAgIGdmKCksXG4gICAgICAgICAgICBnZigpLFxuICAgICAgICAgICAgZ2YoKSxcbiAgICAgICAgICAgIGdmKClcbiAgICAgICAgXTtcbiAgICAgICAgc2V0MjU1MTkocVswXSwgWCk7XG4gICAgICAgIHNldDI1NTE5KHFbMV0sIFkpO1xuICAgICAgICBzZXQyNTUxOShxWzJdLCBnZjEpO1xuICAgICAgICBNKHFbM10sIFgsIFkpO1xuICAgICAgICBzY2FsYXJtdWx0KHAsIHEsIHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcnlwdG9fc2lnbl9rZXlwYWlyKHBrLCBzaywgc2VlZGVkKSB7XG4gICAgICAgIHZhciBkID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICAgICAgICB2YXIgcCA9IFtcbiAgICAgICAgICAgIGdmKCksXG4gICAgICAgICAgICBnZigpLFxuICAgICAgICAgICAgZ2YoKSxcbiAgICAgICAgICAgIGdmKClcbiAgICAgICAgXTtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGlmICghc2VlZGVkKSByYW5kb21ieXRlcyhzaywgMzIpO1xuICAgICAgICBjcnlwdG9faGFzaChkLCBzaywgMzIpO1xuICAgICAgICBkWzBdICY9IDI0ODtcbiAgICAgICAgZFszMV0gJj0gMTI3O1xuICAgICAgICBkWzMxXSB8PSA2NDtcbiAgICAgICAgc2NhbGFyYmFzZShwLCBkKTtcbiAgICAgICAgcGFjayhwaywgcCk7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDMyOyBpKyspc2tbaSArIDMyXSA9IHBrW2ldO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgdmFyIEwgPSBuZXcgRmxvYXQ2NEFycmF5KFtcbiAgICAgICAgMHhlZCxcbiAgICAgICAgMHhkMyxcbiAgICAgICAgMHhmNSxcbiAgICAgICAgMHg1YyxcbiAgICAgICAgMHgxYSxcbiAgICAgICAgMHg2MyxcbiAgICAgICAgMHgxMixcbiAgICAgICAgMHg1OCxcbiAgICAgICAgMHhkNixcbiAgICAgICAgMHg5YyxcbiAgICAgICAgMHhmNyxcbiAgICAgICAgMHhhMixcbiAgICAgICAgMHhkZSxcbiAgICAgICAgMHhmOSxcbiAgICAgICAgMHhkZSxcbiAgICAgICAgMHgxNCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMHgxMFxuICAgIF0pO1xuICAgIGZ1bmN0aW9uIG1vZEwociwgeCkge1xuICAgICAgICB2YXIgY2FycnksIGksIGosIGs7XG4gICAgICAgIGZvcihpID0gNjM7IGkgPj0gMzI7IC0taSl7XG4gICAgICAgICAgICBjYXJyeSA9IDA7XG4gICAgICAgICAgICBmb3IoaiA9IGkgLSAzMiwgayA9IGkgLSAxMjsgaiA8IGs7ICsrail7XG4gICAgICAgICAgICAgICAgeFtqXSArPSBjYXJyeSAtIDE2ICogeFtpXSAqIExbaiAtIChpIC0gMzIpXTtcbiAgICAgICAgICAgICAgICBjYXJyeSA9IE1hdGguZmxvb3IoKHhbal0gKyAxMjgpIC8gMjU2KTtcbiAgICAgICAgICAgICAgICB4W2pdIC09IGNhcnJ5ICogMjU2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeFtqXSArPSBjYXJyeTtcbiAgICAgICAgICAgIHhbaV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgICAgZm9yKGogPSAwOyBqIDwgMzI7IGorKyl7XG4gICAgICAgICAgICB4W2pdICs9IGNhcnJ5IC0gKHhbMzFdID4+IDQpICogTFtqXTtcbiAgICAgICAgICAgIGNhcnJ5ID0geFtqXSA+PiA4O1xuICAgICAgICAgICAgeFtqXSAmPSAyNTU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGogPSAwOyBqIDwgMzI7IGorKyl4W2pdIC09IGNhcnJ5ICogTFtqXTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgMzI7IGkrKyl7XG4gICAgICAgICAgICB4W2kgKyAxXSArPSB4W2ldID4+IDg7XG4gICAgICAgICAgICByW2ldID0geFtpXSAmIDI1NTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWR1Y2Uocikge1xuICAgICAgICB2YXIgeCA9IG5ldyBGbG9hdDY0QXJyYXkoNjQpLCBpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCA2NDsgaSsrKXhbaV0gPSByW2ldO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCA2NDsgaSsrKXJbaV0gPSAwO1xuICAgICAgICBtb2RMKHIsIHgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcnlwdG9fc2lnbihzbSwgbSwgbiwgc2spIHtcbiAgICAgICAgdmFyIGQgPSBuZXcgVWludDhBcnJheSg2NCksIGggPSBuZXcgVWludDhBcnJheSg2NCksIHIgPSBuZXcgVWludDhBcnJheSg2NCk7XG4gICAgICAgIHZhciBpLCBqLCB4ID0gbmV3IEZsb2F0NjRBcnJheSg2NCk7XG4gICAgICAgIHZhciBwID0gW1xuICAgICAgICAgICAgZ2YoKSxcbiAgICAgICAgICAgIGdmKCksXG4gICAgICAgICAgICBnZigpLFxuICAgICAgICAgICAgZ2YoKVxuICAgICAgICBdO1xuICAgICAgICBjcnlwdG9faGFzaChkLCBzaywgMzIpO1xuICAgICAgICBkWzBdICY9IDI0ODtcbiAgICAgICAgZFszMV0gJj0gMTI3O1xuICAgICAgICBkWzMxXSB8PSA2NDtcbiAgICAgICAgdmFyIHNtbGVuID0gbiArIDY0O1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCBuOyBpKyspc21bNjQgKyBpXSA9IG1baV07XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDMyOyBpKyspc21bMzIgKyBpXSA9IGRbMzIgKyBpXTtcbiAgICAgICAgY3J5cHRvX2hhc2gociwgc20uc3ViYXJyYXkoMzIpLCBuICsgMzIpO1xuICAgICAgICByZWR1Y2Uocik7XG4gICAgICAgIHNjYWxhcmJhc2UocCwgcik7XG4gICAgICAgIHBhY2soc20sIHApO1xuICAgICAgICBmb3IoaSA9IDMyOyBpIDwgNjQ7IGkrKylzbVtpXSA9IHNrW2ldO1xuICAgICAgICBjcnlwdG9faGFzaChoLCBzbSwgbiArIDY0KTtcbiAgICAgICAgcmVkdWNlKGgpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCA2NDsgaSsrKXhbaV0gPSAwO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCAzMjsgaSsrKXhbaV0gPSByW2ldO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCAzMjsgaSsrKXtcbiAgICAgICAgICAgIGZvcihqID0gMDsgaiA8IDMyOyBqKyspe1xuICAgICAgICAgICAgICAgIHhbaSArIGpdICs9IGhbaV0gKiBkW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1vZEwoc20uc3ViYXJyYXkoMzIpLCB4KTtcbiAgICAgICAgcmV0dXJuIHNtbGVuO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bnBhY2tuZWcociwgcCkge1xuICAgICAgICB2YXIgdCA9IGdmKCksIGNoayA9IGdmKCksIG51bSA9IGdmKCksIGRlbiA9IGdmKCksIGRlbjIgPSBnZigpLCBkZW40ID0gZ2YoKSwgZGVuNiA9IGdmKCk7XG4gICAgICAgIHNldDI1NTE5KHJbMl0sIGdmMSk7XG4gICAgICAgIHVucGFjazI1NTE5KHJbMV0sIHApO1xuICAgICAgICBTKG51bSwgclsxXSk7XG4gICAgICAgIE0oZGVuLCBudW0sIEQpO1xuICAgICAgICBaKG51bSwgbnVtLCByWzJdKTtcbiAgICAgICAgQShkZW4sIHJbMl0sIGRlbik7XG4gICAgICAgIFMoZGVuMiwgZGVuKTtcbiAgICAgICAgUyhkZW40LCBkZW4yKTtcbiAgICAgICAgTShkZW42LCBkZW40LCBkZW4yKTtcbiAgICAgICAgTSh0LCBkZW42LCBudW0pO1xuICAgICAgICBNKHQsIHQsIGRlbik7XG4gICAgICAgIHBvdzI1MjModCwgdCk7XG4gICAgICAgIE0odCwgdCwgbnVtKTtcbiAgICAgICAgTSh0LCB0LCBkZW4pO1xuICAgICAgICBNKHQsIHQsIGRlbik7XG4gICAgICAgIE0oclswXSwgdCwgZGVuKTtcbiAgICAgICAgUyhjaGssIHJbMF0pO1xuICAgICAgICBNKGNoaywgY2hrLCBkZW4pO1xuICAgICAgICBpZiAobmVxMjU1MTkoY2hrLCBudW0pKSBNKHJbMF0sIHJbMF0sIEkpO1xuICAgICAgICBTKGNoaywgclswXSk7XG4gICAgICAgIE0oY2hrLCBjaGssIGRlbik7XG4gICAgICAgIGlmIChuZXEyNTUxOShjaGssIG51bSkpIHJldHVybiAtMTtcbiAgICAgICAgaWYgKHBhcjI1NTE5KHJbMF0pID09PSBwWzMxXSA+PiA3KSBaKHJbMF0sIGdmMCwgclswXSk7XG4gICAgICAgIE0oclszXSwgclswXSwgclsxXSk7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcnlwdG9fc2lnbl9vcGVuKG0sIHNtLCBuLCBwaykge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIHQgPSBuZXcgVWludDhBcnJheSgzMiksIGggPSBuZXcgVWludDhBcnJheSg2NCk7XG4gICAgICAgIHZhciBwID0gW1xuICAgICAgICAgICAgZ2YoKSxcbiAgICAgICAgICAgIGdmKCksXG4gICAgICAgICAgICBnZigpLFxuICAgICAgICAgICAgZ2YoKVxuICAgICAgICBdLCBxID0gW1xuICAgICAgICAgICAgZ2YoKSxcbiAgICAgICAgICAgIGdmKCksXG4gICAgICAgICAgICBnZigpLFxuICAgICAgICAgICAgZ2YoKVxuICAgICAgICBdO1xuICAgICAgICBpZiAobiA8IDY0KSByZXR1cm4gLTE7XG4gICAgICAgIGlmICh1bnBhY2tuZWcocSwgcGspKSByZXR1cm4gLTE7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IG47IGkrKyltW2ldID0gc21baV07XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDMyOyBpKyspbVtpICsgMzJdID0gcGtbaV07XG4gICAgICAgIGNyeXB0b19oYXNoKGgsIG0sIG4pO1xuICAgICAgICByZWR1Y2UoaCk7XG4gICAgICAgIHNjYWxhcm11bHQocCwgcSwgaCk7XG4gICAgICAgIHNjYWxhcmJhc2UocSwgc20uc3ViYXJyYXkoMzIpKTtcbiAgICAgICAgYWRkKHAsIHEpO1xuICAgICAgICBwYWNrKHQsIHApO1xuICAgICAgICBuIC09IDY0O1xuICAgICAgICBpZiAoY3J5cHRvX3ZlcmlmeV8zMihzbSwgMCwgdCwgMCkpIHtcbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IG47IGkrKyltW2ldID0gMDtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBmb3IoaSA9IDA7IGkgPCBuOyBpKyspbVtpXSA9IHNtW2kgKyA2NF07XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgICB2YXIgY3J5cHRvX3NlY3JldGJveF9LRVlCWVRFUyA9IDMyLCBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVMgPSAyNCwgY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVMgPSAzMiwgY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVMgPSAxNiwgY3J5cHRvX3NjYWxhcm11bHRfQllURVMgPSAzMiwgY3J5cHRvX3NjYWxhcm11bHRfU0NBTEFSQllURVMgPSAzMiwgY3J5cHRvX2JveF9QVUJMSUNLRVlCWVRFUyA9IDMyLCBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTID0gMzIsIGNyeXB0b19ib3hfQkVGT1JFTk1CWVRFUyA9IDMyLCBjcnlwdG9fYm94X05PTkNFQllURVMgPSBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVMsIGNyeXB0b19ib3hfWkVST0JZVEVTID0gY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVMsIGNyeXB0b19ib3hfQk9YWkVST0JZVEVTID0gY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVMsIGNyeXB0b19zaWduX0JZVEVTID0gNjQsIGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTID0gMzIsIGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTID0gNjQsIGNyeXB0b19zaWduX1NFRURCWVRFUyA9IDMyLCBjcnlwdG9faGFzaF9CWVRFUyA9IDY0O1xuICAgIG5hY2wubG93bGV2ZWwgPSB7XG4gICAgICAgIGNyeXB0b19jb3JlX2hzYWxzYTIwOiBjcnlwdG9fY29yZV9oc2Fsc2EyMCxcbiAgICAgICAgY3J5cHRvX3N0cmVhbV94b3I6IGNyeXB0b19zdHJlYW1feG9yLFxuICAgICAgICBjcnlwdG9fc3RyZWFtOiBjcnlwdG9fc3RyZWFtLFxuICAgICAgICBjcnlwdG9fc3RyZWFtX3NhbHNhMjBfeG9yOiBjcnlwdG9fc3RyZWFtX3NhbHNhMjBfeG9yLFxuICAgICAgICBjcnlwdG9fc3RyZWFtX3NhbHNhMjA6IGNyeXB0b19zdHJlYW1fc2Fsc2EyMCxcbiAgICAgICAgY3J5cHRvX29uZXRpbWVhdXRoOiBjcnlwdG9fb25ldGltZWF1dGgsXG4gICAgICAgIGNyeXB0b19vbmV0aW1lYXV0aF92ZXJpZnk6IGNyeXB0b19vbmV0aW1lYXV0aF92ZXJpZnksXG4gICAgICAgIGNyeXB0b192ZXJpZnlfMTY6IGNyeXB0b192ZXJpZnlfMTYsXG4gICAgICAgIGNyeXB0b192ZXJpZnlfMzI6IGNyeXB0b192ZXJpZnlfMzIsXG4gICAgICAgIGNyeXB0b19zZWNyZXRib3g6IGNyeXB0b19zZWNyZXRib3gsXG4gICAgICAgIGNyeXB0b19zZWNyZXRib3hfb3BlbjogY3J5cHRvX3NlY3JldGJveF9vcGVuLFxuICAgICAgICBjcnlwdG9fc2NhbGFybXVsdDogY3J5cHRvX3NjYWxhcm11bHQsXG4gICAgICAgIGNyeXB0b19zY2FsYXJtdWx0X2Jhc2U6IGNyeXB0b19zY2FsYXJtdWx0X2Jhc2UsXG4gICAgICAgIGNyeXB0b19ib3hfYmVmb3Jlbm06IGNyeXB0b19ib3hfYmVmb3Jlbm0sXG4gICAgICAgIGNyeXB0b19ib3hfYWZ0ZXJubTogY3J5cHRvX2JveF9hZnRlcm5tLFxuICAgICAgICBjcnlwdG9fYm94OiBjcnlwdG9fYm94LFxuICAgICAgICBjcnlwdG9fYm94X29wZW46IGNyeXB0b19ib3hfb3BlbixcbiAgICAgICAgY3J5cHRvX2JveF9rZXlwYWlyOiBjcnlwdG9fYm94X2tleXBhaXIsXG4gICAgICAgIGNyeXB0b19oYXNoOiBjcnlwdG9faGFzaCxcbiAgICAgICAgY3J5cHRvX3NpZ246IGNyeXB0b19zaWduLFxuICAgICAgICBjcnlwdG9fc2lnbl9rZXlwYWlyOiBjcnlwdG9fc2lnbl9rZXlwYWlyLFxuICAgICAgICBjcnlwdG9fc2lnbl9vcGVuOiBjcnlwdG9fc2lnbl9vcGVuLFxuICAgICAgICBjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTOiBjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTLFxuICAgICAgICBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVM6IGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUyxcbiAgICAgICAgY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVM6IGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTLFxuICAgICAgICBjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUzogY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVMsXG4gICAgICAgIGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTOiBjcnlwdG9fc2NhbGFybXVsdF9CWVRFUyxcbiAgICAgICAgY3J5cHRvX3NjYWxhcm11bHRfU0NBTEFSQllURVM6IGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTLFxuICAgICAgICBjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTOiBjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTLFxuICAgICAgICBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTOiBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTLFxuICAgICAgICBjcnlwdG9fYm94X0JFRk9SRU5NQllURVM6IGNyeXB0b19ib3hfQkVGT1JFTk1CWVRFUyxcbiAgICAgICAgY3J5cHRvX2JveF9OT05DRUJZVEVTOiBjcnlwdG9fYm94X05PTkNFQllURVMsXG4gICAgICAgIGNyeXB0b19ib3hfWkVST0JZVEVTOiBjcnlwdG9fYm94X1pFUk9CWVRFUyxcbiAgICAgICAgY3J5cHRvX2JveF9CT1haRVJPQllURVM6IGNyeXB0b19ib3hfQk9YWkVST0JZVEVTLFxuICAgICAgICBjcnlwdG9fc2lnbl9CWVRFUzogY3J5cHRvX3NpZ25fQllURVMsXG4gICAgICAgIGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTOiBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUyxcbiAgICAgICAgY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVM6IGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTLFxuICAgICAgICBjcnlwdG9fc2lnbl9TRUVEQllURVM6IGNyeXB0b19zaWduX1NFRURCWVRFUyxcbiAgICAgICAgY3J5cHRvX2hhc2hfQllURVM6IGNyeXB0b19oYXNoX0JZVEVTLFxuICAgICAgICBnZjogZ2YsXG4gICAgICAgIEQ6IEQsXG4gICAgICAgIEw6IEwsXG4gICAgICAgIHBhY2syNTUxOTogcGFjazI1NTE5LFxuICAgICAgICB1bnBhY2syNTUxOTogdW5wYWNrMjU1MTksXG4gICAgICAgIE06IE0sXG4gICAgICAgIEE6IEEsXG4gICAgICAgIFM6IFMsXG4gICAgICAgIFo6IFosXG4gICAgICAgIHBvdzI1MjM6IHBvdzI1MjMsXG4gICAgICAgIGFkZDogYWRkLFxuICAgICAgICBzZXQyNTUxOTogc2V0MjU1MTksXG4gICAgICAgIG1vZEw6IG1vZEwsXG4gICAgICAgIHNjYWxhcm11bHQ6IHNjYWxhcm11bHQsXG4gICAgICAgIHNjYWxhcmJhc2U6IHNjYWxhcmJhc2VcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGNoZWNrTGVuZ3RocyhrLCBuKSB7XG4gICAgICAgIGlmIChrLmxlbmd0aCAhPT0gY3J5cHRvX3NlY3JldGJveF9LRVlCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQga2V5IHNpemUnKTtcbiAgICAgICAgaWYgKG4ubGVuZ3RoICE9PSBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIG5vbmNlIHNpemUnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tCb3hMZW5ndGhzKHBrLCBzaykge1xuICAgICAgICBpZiAocGsubGVuZ3RoICE9PSBjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwdWJsaWMga2V5IHNpemUnKTtcbiAgICAgICAgaWYgKHNrLmxlbmd0aCAhPT0gY3J5cHRvX2JveF9TRUNSRVRLRVlCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2VjcmV0IGtleSBzaXplJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrQXJyYXlUeXBlcygpIHtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBpZiAoIShhcmd1bWVudHNbaV0gaW5zdGFuY2VvZiBVaW50OEFycmF5KSkgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5leHBlY3RlZCB0eXBlLCB1c2UgVWludDhBcnJheScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsZWFudXAoYXJyKSB7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspYXJyW2ldID0gMDtcbiAgICB9XG4gICAgbmFjbC5yYW5kb21CeXRlcyA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgdmFyIGIgPSBuZXcgVWludDhBcnJheShuKTtcbiAgICAgICAgcmFuZG9tYnl0ZXMoYiwgbik7XG4gICAgICAgIHJldHVybiBiO1xuICAgIH07XG4gICAgbmFjbC5zZWNyZXRib3ggPSBmdW5jdGlvbihtc2csIG5vbmNlLCBrZXkpIHtcbiAgICAgICAgY2hlY2tBcnJheVR5cGVzKG1zZywgbm9uY2UsIGtleSk7XG4gICAgICAgIGNoZWNrTGVuZ3RocyhrZXksIG5vbmNlKTtcbiAgICAgICAgdmFyIG0gPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUyArIG1zZy5sZW5ndGgpO1xuICAgICAgICB2YXIgYyA9IG5ldyBVaW50OEFycmF5KG0ubGVuZ3RoKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKyltW2kgKyBjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFU10gPSBtc2dbaV07XG4gICAgICAgIGNyeXB0b19zZWNyZXRib3goYywgbSwgbS5sZW5ndGgsIG5vbmNlLCBrZXkpO1xuICAgICAgICByZXR1cm4gYy5zdWJhcnJheShjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUyk7XG4gICAgfTtcbiAgICBuYWNsLnNlY3JldGJveC5vcGVuID0gZnVuY3Rpb24oYm94LCBub25jZSwga2V5KSB7XG4gICAgICAgIGNoZWNrQXJyYXlUeXBlcyhib3gsIG5vbmNlLCBrZXkpO1xuICAgICAgICBjaGVja0xlbmd0aHMoa2V5LCBub25jZSk7XG4gICAgICAgIHZhciBjID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVMgKyBib3gubGVuZ3RoKTtcbiAgICAgICAgdmFyIG0gPSBuZXcgVWludDhBcnJheShjLmxlbmd0aCk7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBib3gubGVuZ3RoOyBpKyspY1tpICsgY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVNdID0gYm94W2ldO1xuICAgICAgICBpZiAoYy5sZW5ndGggPCAzMikgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChjcnlwdG9fc2VjcmV0Ym94X29wZW4obSwgYywgYy5sZW5ndGgsIG5vbmNlLCBrZXkpICE9PSAwKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG0uc3ViYXJyYXkoY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVMpO1xuICAgIH07XG4gICAgbmFjbC5zZWNyZXRib3gua2V5TGVuZ3RoID0gY3J5cHRvX3NlY3JldGJveF9LRVlCWVRFUztcbiAgICBuYWNsLnNlY3JldGJveC5ub25jZUxlbmd0aCA9IGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUztcbiAgICBuYWNsLnNlY3JldGJveC5vdmVyaGVhZExlbmd0aCA9IGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTO1xuICAgIG5hY2wuc2NhbGFyTXVsdCA9IGZ1bmN0aW9uKG4sIHApIHtcbiAgICAgICAgY2hlY2tBcnJheVR5cGVzKG4sIHApO1xuICAgICAgICBpZiAobi5sZW5ndGggIT09IGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBuIHNpemUnKTtcbiAgICAgICAgaWYgKHAubGVuZ3RoICE9PSBjcnlwdG9fc2NhbGFybXVsdF9CWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgcCBzaXplJyk7XG4gICAgICAgIHZhciBxID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NjYWxhcm11bHRfQllURVMpO1xuICAgICAgICBjcnlwdG9fc2NhbGFybXVsdChxLCBuLCBwKTtcbiAgICAgICAgcmV0dXJuIHE7XG4gICAgfTtcbiAgICBuYWNsLnNjYWxhck11bHQuYmFzZSA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgY2hlY2tBcnJheVR5cGVzKG4pO1xuICAgICAgICBpZiAobi5sZW5ndGggIT09IGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBuIHNpemUnKTtcbiAgICAgICAgdmFyIHEgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2NhbGFybXVsdF9CWVRFUyk7XG4gICAgICAgIGNyeXB0b19zY2FsYXJtdWx0X2Jhc2UocSwgbik7XG4gICAgICAgIHJldHVybiBxO1xuICAgIH07XG4gICAgbmFjbC5zY2FsYXJNdWx0LnNjYWxhckxlbmd0aCA9IGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTO1xuICAgIG5hY2wuc2NhbGFyTXVsdC5ncm91cEVsZW1lbnRMZW5ndGggPSBjcnlwdG9fc2NhbGFybXVsdF9CWVRFUztcbiAgICBuYWNsLmJveCA9IGZ1bmN0aW9uKG1zZywgbm9uY2UsIHB1YmxpY0tleSwgc2VjcmV0S2V5KSB7XG4gICAgICAgIHZhciBrID0gbmFjbC5ib3guYmVmb3JlKHB1YmxpY0tleSwgc2VjcmV0S2V5KTtcbiAgICAgICAgcmV0dXJuIG5hY2wuc2VjcmV0Ym94KG1zZywgbm9uY2UsIGspO1xuICAgIH07XG4gICAgbmFjbC5ib3guYmVmb3JlID0gZnVuY3Rpb24ocHVibGljS2V5LCBzZWNyZXRLZXkpIHtcbiAgICAgICAgY2hlY2tBcnJheVR5cGVzKHB1YmxpY0tleSwgc2VjcmV0S2V5KTtcbiAgICAgICAgY2hlY2tCb3hMZW5ndGhzKHB1YmxpY0tleSwgc2VjcmV0S2V5KTtcbiAgICAgICAgdmFyIGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fYm94X0JFRk9SRU5NQllURVMpO1xuICAgICAgICBjcnlwdG9fYm94X2JlZm9yZW5tKGssIHB1YmxpY0tleSwgc2VjcmV0S2V5KTtcbiAgICAgICAgcmV0dXJuIGs7XG4gICAgfTtcbiAgICBuYWNsLmJveC5hZnRlciA9IG5hY2wuc2VjcmV0Ym94O1xuICAgIG5hY2wuYm94Lm9wZW4gPSBmdW5jdGlvbihtc2csIG5vbmNlLCBwdWJsaWNLZXksIHNlY3JldEtleSkge1xuICAgICAgICB2YXIgayA9IG5hY2wuYm94LmJlZm9yZShwdWJsaWNLZXksIHNlY3JldEtleSk7XG4gICAgICAgIHJldHVybiBuYWNsLnNlY3JldGJveC5vcGVuKG1zZywgbm9uY2UsIGspO1xuICAgIH07XG4gICAgbmFjbC5ib3gub3Blbi5hZnRlciA9IG5hY2wuc2VjcmV0Ym94Lm9wZW47XG4gICAgbmFjbC5ib3gua2V5UGFpciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTKTtcbiAgICAgICAgdmFyIHNrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX2JveF9TRUNSRVRLRVlCWVRFUyk7XG4gICAgICAgIGNyeXB0b19ib3hfa2V5cGFpcihwaywgc2spO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHVibGljS2V5OiBwayxcbiAgICAgICAgICAgIHNlY3JldEtleTogc2tcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIG5hY2wuYm94LmtleVBhaXIuZnJvbVNlY3JldEtleSA9IGZ1bmN0aW9uKHNlY3JldEtleSkge1xuICAgICAgICBjaGVja0FycmF5VHlwZXMoc2VjcmV0S2V5KTtcbiAgICAgICAgaWYgKHNlY3JldEtleS5sZW5ndGggIT09IGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIHNlY3JldCBrZXkgc2l6ZScpO1xuICAgICAgICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTKTtcbiAgICAgICAgY3J5cHRvX3NjYWxhcm11bHRfYmFzZShwaywgc2VjcmV0S2V5KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHB1YmxpY0tleTogcGssXG4gICAgICAgICAgICBzZWNyZXRLZXk6IG5ldyBVaW50OEFycmF5KHNlY3JldEtleSlcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIG5hY2wuYm94LnB1YmxpY0tleUxlbmd0aCA9IGNyeXB0b19ib3hfUFVCTElDS0VZQllURVM7XG4gICAgbmFjbC5ib3guc2VjcmV0S2V5TGVuZ3RoID0gY3J5cHRvX2JveF9TRUNSRVRLRVlCWVRFUztcbiAgICBuYWNsLmJveC5zaGFyZWRLZXlMZW5ndGggPSBjcnlwdG9fYm94X0JFRk9SRU5NQllURVM7XG4gICAgbmFjbC5ib3gubm9uY2VMZW5ndGggPSBjcnlwdG9fYm94X05PTkNFQllURVM7XG4gICAgbmFjbC5ib3gub3ZlcmhlYWRMZW5ndGggPSBuYWNsLnNlY3JldGJveC5vdmVyaGVhZExlbmd0aDtcbiAgICBuYWNsLnNpZ24gPSBmdW5jdGlvbihtc2csIHNlY3JldEtleSkge1xuICAgICAgICBjaGVja0FycmF5VHlwZXMobXNnLCBzZWNyZXRLZXkpO1xuICAgICAgICBpZiAoc2VjcmV0S2V5Lmxlbmd0aCAhPT0gY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIHNlY3JldCBrZXkgc2l6ZScpO1xuICAgICAgICB2YXIgc2lnbmVkTXNnID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fQllURVMgKyBtc2cubGVuZ3RoKTtcbiAgICAgICAgY3J5cHRvX3NpZ24oc2lnbmVkTXNnLCBtc2csIG1zZy5sZW5ndGgsIHNlY3JldEtleSk7XG4gICAgICAgIHJldHVybiBzaWduZWRNc2c7XG4gICAgfTtcbiAgICBuYWNsLnNpZ24ub3BlbiA9IGZ1bmN0aW9uKHNpZ25lZE1zZywgcHVibGljS2V5KSB7XG4gICAgICAgIGNoZWNrQXJyYXlUeXBlcyhzaWduZWRNc2csIHB1YmxpY0tleSk7XG4gICAgICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgcHVibGljIGtleSBzaXplJyk7XG4gICAgICAgIHZhciB0bXAgPSBuZXcgVWludDhBcnJheShzaWduZWRNc2cubGVuZ3RoKTtcbiAgICAgICAgdmFyIG1sZW4gPSBjcnlwdG9fc2lnbl9vcGVuKHRtcCwgc2lnbmVkTXNnLCBzaWduZWRNc2cubGVuZ3RoLCBwdWJsaWNLZXkpO1xuICAgICAgICBpZiAobWxlbiA8IDApIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgbSA9IG5ldyBVaW50OEFycmF5KG1sZW4pO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkrKyltW2ldID0gdG1wW2ldO1xuICAgICAgICByZXR1cm4gbTtcbiAgICB9O1xuICAgIG5hY2wuc2lnbi5kZXRhY2hlZCA9IGZ1bmN0aW9uKG1zZywgc2VjcmV0S2V5KSB7XG4gICAgICAgIHZhciBzaWduZWRNc2cgPSBuYWNsLnNpZ24obXNnLCBzZWNyZXRLZXkpO1xuICAgICAgICB2YXIgc2lnID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fQllURVMpO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2lnLmxlbmd0aDsgaSsrKXNpZ1tpXSA9IHNpZ25lZE1zZ1tpXTtcbiAgICAgICAgcmV0dXJuIHNpZztcbiAgICB9O1xuICAgIG5hY2wuc2lnbi5kZXRhY2hlZC52ZXJpZnkgPSBmdW5jdGlvbihtc2csIHNpZywgcHVibGljS2V5KSB7XG4gICAgICAgIGNoZWNrQXJyYXlUeXBlcyhtc2csIHNpZywgcHVibGljS2V5KTtcbiAgICAgICAgaWYgKHNpZy5sZW5ndGggIT09IGNyeXB0b19zaWduX0JZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzaWduYXR1cmUgc2l6ZScpO1xuICAgICAgICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIHB1YmxpYyBrZXkgc2l6ZScpO1xuICAgICAgICB2YXIgc20gPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9CWVRFUyArIG1zZy5sZW5ndGgpO1xuICAgICAgICB2YXIgbSA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX0JZVEVTICsgbXNnLmxlbmd0aCk7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCBjcnlwdG9fc2lnbl9CWVRFUzsgaSsrKXNtW2ldID0gc2lnW2ldO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspc21baSArIGNyeXB0b19zaWduX0JZVEVTXSA9IG1zZ1tpXTtcbiAgICAgICAgcmV0dXJuIGNyeXB0b19zaWduX29wZW4obSwgc20sIHNtLmxlbmd0aCwgcHVibGljS2V5KSA+PSAwO1xuICAgIH07XG4gICAgbmFjbC5zaWduLmtleVBhaXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVMpO1xuICAgICAgICB2YXIgc2sgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUyk7XG4gICAgICAgIGNyeXB0b19zaWduX2tleXBhaXIocGssIHNrKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHB1YmxpY0tleTogcGssXG4gICAgICAgICAgICBzZWNyZXRLZXk6IHNrXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBuYWNsLnNpZ24ua2V5UGFpci5mcm9tU2VjcmV0S2V5ID0gZnVuY3Rpb24oc2VjcmV0S2V5KSB7XG4gICAgICAgIGNoZWNrQXJyYXlUeXBlcyhzZWNyZXRLZXkpO1xuICAgICAgICBpZiAoc2VjcmV0S2V5Lmxlbmd0aCAhPT0gY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIHNlY3JldCBrZXkgc2l6ZScpO1xuICAgICAgICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUyk7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBway5sZW5ndGg7IGkrKylwa1tpXSA9IHNlY3JldEtleVszMiArIGldO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHVibGljS2V5OiBwayxcbiAgICAgICAgICAgIHNlY3JldEtleTogbmV3IFVpbnQ4QXJyYXkoc2VjcmV0S2V5KVxuICAgICAgICB9O1xuICAgIH07XG4gICAgbmFjbC5zaWduLmtleVBhaXIuZnJvbVNlZWQgPSBmdW5jdGlvbihzZWVkKSB7XG4gICAgICAgIGNoZWNrQXJyYXlUeXBlcyhzZWVkKTtcbiAgICAgICAgaWYgKHNlZWQubGVuZ3RoICE9PSBjcnlwdG9fc2lnbl9TRUVEQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIHNlZWQgc2l6ZScpO1xuICAgICAgICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUyk7XG4gICAgICAgIHZhciBzayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IDMyOyBpKyspc2tbaV0gPSBzZWVkW2ldO1xuICAgICAgICBjcnlwdG9fc2lnbl9rZXlwYWlyKHBrLCBzaywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwdWJsaWNLZXk6IHBrLFxuICAgICAgICAgICAgc2VjcmV0S2V5OiBza1xuICAgICAgICB9O1xuICAgIH07XG4gICAgbmFjbC5zaWduLnB1YmxpY0tleUxlbmd0aCA9IGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTO1xuICAgIG5hY2wuc2lnbi5zZWNyZXRLZXlMZW5ndGggPSBjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUztcbiAgICBuYWNsLnNpZ24uc2VlZExlbmd0aCA9IGNyeXB0b19zaWduX1NFRURCWVRFUztcbiAgICBuYWNsLnNpZ24uc2lnbmF0dXJlTGVuZ3RoID0gY3J5cHRvX3NpZ25fQllURVM7XG4gICAgbmFjbC5oYXNoID0gZnVuY3Rpb24obXNnKSB7XG4gICAgICAgIGNoZWNrQXJyYXlUeXBlcyhtc2cpO1xuICAgICAgICB2YXIgaCA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19oYXNoX0JZVEVTKTtcbiAgICAgICAgY3J5cHRvX2hhc2goaCwgbXNnLCBtc2cubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGg7XG4gICAgfTtcbiAgICBuYWNsLmhhc2guaGFzaExlbmd0aCA9IGNyeXB0b19oYXNoX0JZVEVTO1xuICAgIG5hY2wudmVyaWZ5ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICBjaGVja0FycmF5VHlwZXMoeCwgeSk7XG4gICAgICAgIGlmICh4Lmxlbmd0aCA9PT0gMCB8fCB5Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoeC5sZW5ndGggIT09IHkubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB2bih4LCAwLCB5LCAwLCB4Lmxlbmd0aCkgPT09IDAgPyB0cnVlIDogZmFsc2U7XG4gICAgfTtcbiAgICBuYWNsLnNldFBSTkcgPSBmdW5jdGlvbihmbikge1xuICAgICAgICByYW5kb21ieXRlcyA9IGZuO1xuICAgIH07XG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY3J5cHRvMSA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMuY3J5cHRvIHx8IGdsb2JhbFRoaXMubXNDcnlwdG8gOiBudWxsO1xuICAgICAgICBpZiAoY3J5cHRvMSAmJiBjcnlwdG8xLmdldFJhbmRvbVZhbHVlcykge1xuICAgICAgICAgICAgdmFyIFFVT1RBID0gNjU1MzY7XG4gICAgICAgICAgICBuYWNsLnNldFBSTkcoZnVuY3Rpb24oeCwgbikge1xuICAgICAgICAgICAgICAgIHZhciBpLCB2ID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gICAgICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgbjsgaSArPSBRVU9UQSl7XG4gICAgICAgICAgICAgICAgICAgIGNyeXB0bzEuZ2V0UmFuZG9tVmFsdWVzKHYuc3ViYXJyYXkoaSwgaSArIE1hdGgubWluKG4gLSBpLCBRVU9UQSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgbjsgaSsrKXhbaV0gPSB2W2ldO1xuICAgICAgICAgICAgICAgIGNsZWFudXAodik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNyeXB0bzEgPSByZXF1aXJlKCdjcnlwdG8nKTtcbiAgICAgICAgICAgIGlmIChjcnlwdG8xICYmIGNyeXB0bzEucmFuZG9tQnl0ZXMpIHtcbiAgICAgICAgICAgICAgICBuYWNsLnNldFBSTkcoZnVuY3Rpb24oeCwgbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSwgdiA9IGNyeXB0bzEucmFuZG9tQnl0ZXMobik7XG4gICAgICAgICAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IG47IGkrKyl4W2ldID0gdltpXTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cCh2KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pKCk7XG59KSh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cyA/IG1vZHVsZS5leHBvcnRzIDogZ2xvYmFsVGhpcy5uYWNsID0gZ2xvYmFsVGhpcy5uYWNsIHx8IHt9KTtcbmNvbnN0IG5hY2wgPSBnbG9iYWxUaGlzLm5hY2w7XG5jb25zdCBkZW5vSGVscGVyID0ge1xuICAgIGZyb21TZWVkOiBuYWNsLnNpZ24ua2V5UGFpci5mcm9tU2VlZCxcbiAgICBzaWduOiBuYWNsLnNpZ24uZGV0YWNoZWQsXG4gICAgdmVyaWZ5OiBuYWNsLnNpZ24uZGV0YWNoZWQudmVyaWZ5LFxuICAgIHJhbmRvbUJ5dGVzOiBuYWNsLnJhbmRvbUJ5dGVzXG59O1xubGV0IGhlbHBlcjtcbmZ1bmN0aW9uIHNldEVkMjU1MTlIZWxwZXIobGliKSB7XG4gICAgaGVscGVyID0gbGliO1xufVxuZnVuY3Rpb24gZ2V0RWQyNTUxOUhlbHBlcigpIHtcbiAgICByZXR1cm4gaGVscGVyO1xufVxuY29uc3QgY3JjMTZ0YWIgPSBuZXcgVWludDE2QXJyYXkoW1xuICAgIDB4MDAwMCxcbiAgICAweDEwMjEsXG4gICAgMHgyMDQyLFxuICAgIDB4MzA2MyxcbiAgICAweDQwODQsXG4gICAgMHg1MGE1LFxuICAgIDB4NjBjNixcbiAgICAweDcwZTcsXG4gICAgMHg4MTA4LFxuICAgIDB4OTEyOSxcbiAgICAweGExNGEsXG4gICAgMHhiMTZiLFxuICAgIDB4YzE4YyxcbiAgICAweGQxYWQsXG4gICAgMHhlMWNlLFxuICAgIDB4ZjFlZixcbiAgICAweDEyMzEsXG4gICAgMHgwMjEwLFxuICAgIDB4MzI3MyxcbiAgICAweDIyNTIsXG4gICAgMHg1MmI1LFxuICAgIDB4NDI5NCxcbiAgICAweDcyZjcsXG4gICAgMHg2MmQ2LFxuICAgIDB4OTMzOSxcbiAgICAweDgzMTgsXG4gICAgMHhiMzdiLFxuICAgIDB4YTM1YSxcbiAgICAweGQzYmQsXG4gICAgMHhjMzljLFxuICAgIDB4ZjNmZixcbiAgICAweGUzZGUsXG4gICAgMHgyNDYyLFxuICAgIDB4MzQ0MyxcbiAgICAweDA0MjAsXG4gICAgMHgxNDAxLFxuICAgIDB4NjRlNixcbiAgICAweDc0YzcsXG4gICAgMHg0NGE0LFxuICAgIDB4NTQ4NSxcbiAgICAweGE1NmEsXG4gICAgMHhiNTRiLFxuICAgIDB4ODUyOCxcbiAgICAweDk1MDksXG4gICAgMHhlNWVlLFxuICAgIDB4ZjVjZixcbiAgICAweGM1YWMsXG4gICAgMHhkNThkLFxuICAgIDB4MzY1MyxcbiAgICAweDI2NzIsXG4gICAgMHgxNjExLFxuICAgIDB4MDYzMCxcbiAgICAweDc2ZDcsXG4gICAgMHg2NmY2LFxuICAgIDB4NTY5NSxcbiAgICAweDQ2YjQsXG4gICAgMHhiNzViLFxuICAgIDB4YTc3YSxcbiAgICAweDk3MTksXG4gICAgMHg4NzM4LFxuICAgIDB4ZjdkZixcbiAgICAweGU3ZmUsXG4gICAgMHhkNzlkLFxuICAgIDB4YzdiYyxcbiAgICAweDQ4YzQsXG4gICAgMHg1OGU1LFxuICAgIDB4Njg4NixcbiAgICAweDc4YTcsXG4gICAgMHgwODQwLFxuICAgIDB4MTg2MSxcbiAgICAweDI4MDIsXG4gICAgMHgzODIzLFxuICAgIDB4YzljYyxcbiAgICAweGQ5ZWQsXG4gICAgMHhlOThlLFxuICAgIDB4ZjlhZixcbiAgICAweDg5NDgsXG4gICAgMHg5OTY5LFxuICAgIDB4YTkwYSxcbiAgICAweGI5MmIsXG4gICAgMHg1YWY1LFxuICAgIDB4NGFkNCxcbiAgICAweDdhYjcsXG4gICAgMHg2YTk2LFxuICAgIDB4MWE3MSxcbiAgICAweDBhNTAsXG4gICAgMHgzYTMzLFxuICAgIDB4MmExMixcbiAgICAweGRiZmQsXG4gICAgMHhjYmRjLFxuICAgIDB4ZmJiZixcbiAgICAweGViOWUsXG4gICAgMHg5Yjc5LFxuICAgIDB4OGI1OCxcbiAgICAweGJiM2IsXG4gICAgMHhhYjFhLFxuICAgIDB4NmNhNixcbiAgICAweDdjODcsXG4gICAgMHg0Y2U0LFxuICAgIDB4NWNjNSxcbiAgICAweDJjMjIsXG4gICAgMHgzYzAzLFxuICAgIDB4MGM2MCxcbiAgICAweDFjNDEsXG4gICAgMHhlZGFlLFxuICAgIDB4ZmQ4ZixcbiAgICAweGNkZWMsXG4gICAgMHhkZGNkLFxuICAgIDB4YWQyYSxcbiAgICAweGJkMGIsXG4gICAgMHg4ZDY4LFxuICAgIDB4OWQ0OSxcbiAgICAweDdlOTcsXG4gICAgMHg2ZWI2LFxuICAgIDB4NWVkNSxcbiAgICAweDRlZjQsXG4gICAgMHgzZTEzLFxuICAgIDB4MmUzMixcbiAgICAweDFlNTEsXG4gICAgMHgwZTcwLFxuICAgIDB4ZmY5ZixcbiAgICAweGVmYmUsXG4gICAgMHhkZmRkLFxuICAgIDB4Y2ZmYyxcbiAgICAweGJmMWIsXG4gICAgMHhhZjNhLFxuICAgIDB4OWY1OSxcbiAgICAweDhmNzgsXG4gICAgMHg5MTg4LFxuICAgIDB4ODFhOSxcbiAgICAweGIxY2EsXG4gICAgMHhhMWViLFxuICAgIDB4ZDEwYyxcbiAgICAweGMxMmQsXG4gICAgMHhmMTRlLFxuICAgIDB4ZTE2ZixcbiAgICAweDEwODAsXG4gICAgMHgwMGExLFxuICAgIDB4MzBjMixcbiAgICAweDIwZTMsXG4gICAgMHg1MDA0LFxuICAgIDB4NDAyNSxcbiAgICAweDcwNDYsXG4gICAgMHg2MDY3LFxuICAgIDB4ODNiOSxcbiAgICAweDkzOTgsXG4gICAgMHhhM2ZiLFxuICAgIDB4YjNkYSxcbiAgICAweGMzM2QsXG4gICAgMHhkMzFjLFxuICAgIDB4ZTM3ZixcbiAgICAweGYzNWUsXG4gICAgMHgwMmIxLFxuICAgIDB4MTI5MCxcbiAgICAweDIyZjMsXG4gICAgMHgzMmQyLFxuICAgIDB4NDIzNSxcbiAgICAweDUyMTQsXG4gICAgMHg2Mjc3LFxuICAgIDB4NzI1NixcbiAgICAweGI1ZWEsXG4gICAgMHhhNWNiLFxuICAgIDB4OTVhOCxcbiAgICAweDg1ODksXG4gICAgMHhmNTZlLFxuICAgIDB4ZTU0ZixcbiAgICAweGQ1MmMsXG4gICAgMHhjNTBkLFxuICAgIDB4MzRlMixcbiAgICAweDI0YzMsXG4gICAgMHgxNGEwLFxuICAgIDB4MDQ4MSxcbiAgICAweDc0NjYsXG4gICAgMHg2NDQ3LFxuICAgIDB4NTQyNCxcbiAgICAweDQ0MDUsXG4gICAgMHhhN2RiLFxuICAgIDB4YjdmYSxcbiAgICAweDg3OTksXG4gICAgMHg5N2I4LFxuICAgIDB4ZTc1ZixcbiAgICAweGY3N2UsXG4gICAgMHhjNzFkLFxuICAgIDB4ZDczYyxcbiAgICAweDI2ZDMsXG4gICAgMHgzNmYyLFxuICAgIDB4MDY5MSxcbiAgICAweDE2YjAsXG4gICAgMHg2NjU3LFxuICAgIDB4NzY3NixcbiAgICAweDQ2MTUsXG4gICAgMHg1NjM0LFxuICAgIDB4ZDk0YyxcbiAgICAweGM5NmQsXG4gICAgMHhmOTBlLFxuICAgIDB4ZTkyZixcbiAgICAweDk5YzgsXG4gICAgMHg4OWU5LFxuICAgIDB4Yjk4YSxcbiAgICAweGE5YWIsXG4gICAgMHg1ODQ0LFxuICAgIDB4NDg2NSxcbiAgICAweDc4MDYsXG4gICAgMHg2ODI3LFxuICAgIDB4MThjMCxcbiAgICAweDA4ZTEsXG4gICAgMHgzODgyLFxuICAgIDB4MjhhMyxcbiAgICAweGNiN2QsXG4gICAgMHhkYjVjLFxuICAgIDB4ZWIzZixcbiAgICAweGZiMWUsXG4gICAgMHg4YmY5LFxuICAgIDB4OWJkOCxcbiAgICAweGFiYmIsXG4gICAgMHhiYjlhLFxuICAgIDB4NGE3NSxcbiAgICAweDVhNTQsXG4gICAgMHg2YTM3LFxuICAgIDB4N2ExNixcbiAgICAweDBhZjEsXG4gICAgMHgxYWQwLFxuICAgIDB4MmFiMyxcbiAgICAweDNhOTIsXG4gICAgMHhmZDJlLFxuICAgIDB4ZWQwZixcbiAgICAweGRkNmMsXG4gICAgMHhjZDRkLFxuICAgIDB4YmRhYSxcbiAgICAweGFkOGIsXG4gICAgMHg5ZGU4LFxuICAgIDB4OGRjOSxcbiAgICAweDdjMjYsXG4gICAgMHg2YzA3LFxuICAgIDB4NWM2NCxcbiAgICAweDRjNDUsXG4gICAgMHgzY2EyLFxuICAgIDB4MmM4MyxcbiAgICAweDFjZTAsXG4gICAgMHgwY2MxLFxuICAgIDB4ZWYxZixcbiAgICAweGZmM2UsXG4gICAgMHhjZjVkLFxuICAgIDB4ZGY3YyxcbiAgICAweGFmOWIsXG4gICAgMHhiZmJhLFxuICAgIDB4OGZkOSxcbiAgICAweDlmZjgsXG4gICAgMHg2ZTE3LFxuICAgIDB4N2UzNixcbiAgICAweDRlNTUsXG4gICAgMHg1ZTc0LFxuICAgIDB4MmU5MyxcbiAgICAweDNlYjIsXG4gICAgMHgwZWQxLFxuICAgIDB4MWVmMCwgXG5dKTtcbmNsYXNzIGNyYzE2IHtcbiAgICBzdGF0aWMgY2hlY2tzdW0oZGF0YSkge1xuICAgICAgICBsZXQgY3JjID0gMDtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGRhdGEuYnl0ZUxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGxldCBiID0gZGF0YVtpXTtcbiAgICAgICAgICAgIGNyYyA9IGNyYyA8PCA4ICYgMHhmZmZmIF4gY3JjMTZ0YWJbKGNyYyA+PiA4IF4gYikgJiAweDAwRkZdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmM7XG4gICAgfVxuICAgIHN0YXRpYyB2YWxpZGF0ZShkYXRhLCBleHBlY3RlZCkge1xuICAgICAgICBsZXQgYmEgPSBjcmMxNi5jaGVja3N1bShkYXRhKTtcbiAgICAgICAgcmV0dXJuIGJhID09IGV4cGVjdGVkO1xuICAgIH1cbn1cbmNvbnN0IGIzMkFscGhhYmV0ID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2N1wiO1xuY2xhc3MgYmFzZTMyIHtcbiAgICBzdGF0aWMgZW5jb2RlKHNyYykge1xuICAgICAgICBsZXQgYml0cyA9IDA7XG4gICAgICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgICAgIGxldCBhID0gbmV3IFVpbnQ4QXJyYXkoc3JjKTtcbiAgICAgICAgbGV0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KHNyYy5ieXRlTGVuZ3RoICogMik7XG4gICAgICAgIGxldCBqID0gMDtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGEuYnl0ZUxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPDwgOCB8IGFbaV07XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICB3aGlsZShiaXRzID49IDUpe1xuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IHZhbHVlID4+PiBiaXRzIC0gNSAmIDMxO1xuICAgICAgICAgICAgICAgIGJ1ZltqKytdID0gYjMyQWxwaGFiZXQuY2hhckF0KGluZGV4KS5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICAgIGJpdHMgLT0gNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYml0cyA+IDApIHtcbiAgICAgICAgICAgIGxldCBpbmRleDEgPSB2YWx1ZSA8PCA1IC0gYml0cyAmIDMxO1xuICAgICAgICAgICAgYnVmW2orK10gPSBiMzJBbHBoYWJldC5jaGFyQXQoaW5kZXgxKS5jaGFyQ29kZUF0KDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWYuc2xpY2UoMCwgaik7XG4gICAgfVxuICAgIHN0YXRpYyBkZWNvZGUoc3JjKSB7XG4gICAgICAgIGxldCBiaXRzID0gMDtcbiAgICAgICAgbGV0IF9fYnl0ZSA9IDA7XG4gICAgICAgIGxldCBqID0gMDtcbiAgICAgICAgbGV0IGEgPSBuZXcgVWludDhBcnJheShzcmMpO1xuICAgICAgICBsZXQgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoYS5ieXRlTGVuZ3RoICogNSAvIDggfCAwKTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGEuYnl0ZUxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGxldCB2ID0gU3RyaW5nLmZyb21DaGFyQ29kZShhW2ldKTtcbiAgICAgICAgICAgIGxldCB2diA9IGIzMkFscGhhYmV0LmluZGV4T2Yodik7XG4gICAgICAgICAgICBpZiAodnYgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBCYXNlMzIgY2hhcmFjdGVyOiBcIiArIGFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX19ieXRlID0gX19ieXRlIDw8IDUgfCB2djtcbiAgICAgICAgICAgIGJpdHMgKz0gNTtcbiAgICAgICAgICAgIGlmIChiaXRzID49IDgpIHtcbiAgICAgICAgICAgICAgICBvdXRbaisrXSA9IF9fYnl0ZSA+Pj4gYml0cyAtIDggJiAyNTU7XG4gICAgICAgICAgICAgICAgYml0cyAtPSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQuc2xpY2UoMCwgaik7XG4gICAgfVxufVxuY2xhc3MgTktleXNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBuYW1lO1xuICAgIGNvZGU7XG4gICAgY2hhaW5lZEVycm9yO1xuICAgIGNvbnN0cnVjdG9yKGNvZGUsIGNoYWluZWRFcnJvcil7XG4gICAgICAgIHN1cGVyKGNvZGUpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIk5LZXlzRXJyb3JcIjtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgdGhpcy5jaGFpbmVkRXJyb3IgPSBjaGFpbmVkRXJyb3I7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlT3BlcmF0b3IoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVBhaXIoUHJlZml4Lk9wZXJhdG9yKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFjY291bnQoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVBhaXIoUHJlZml4LkFjY291bnQpO1xufVxuZnVuY3Rpb24gY3JlYXRlVXNlcigpIHtcbiAgICByZXR1cm4gY3JlYXRlUGFpcihQcmVmaXguVXNlcik7XG59XG52YXIgTktleXNFcnJvckNvZGU7XG4oZnVuY3Rpb24oTktleXNFcnJvckNvZGUpIHtcbiAgICBOS2V5c0Vycm9yQ29kZVtcIkludmFsaWRQcmVmaXhCeXRlXCJdID0gXCJua2V5czogaW52YWxpZCBwcmVmaXggYnl0ZVwiO1xuICAgIE5LZXlzRXJyb3JDb2RlW1wiSW52YWxpZEtleVwiXSA9IFwibmtleXM6IGludmFsaWQga2V5XCI7XG4gICAgTktleXNFcnJvckNvZGVbXCJJbnZhbGlkUHVibGljS2V5XCJdID0gXCJua2V5czogaW52YWxpZCBwdWJsaWMga2V5XCI7XG4gICAgTktleXNFcnJvckNvZGVbXCJJbnZhbGlkU2VlZExlblwiXSA9IFwibmtleXM6IGludmFsaWQgc2VlZCBsZW5ndGhcIjtcbiAgICBOS2V5c0Vycm9yQ29kZVtcIkludmFsaWRTZWVkXCJdID0gXCJua2V5czogaW52YWxpZCBzZWVkXCI7XG4gICAgTktleXNFcnJvckNvZGVbXCJJbnZhbGlkRW5jb2RpbmdcIl0gPSBcIm5rZXlzOiBpbnZhbGlkIGVuY29kZWQga2V5XCI7XG4gICAgTktleXNFcnJvckNvZGVbXCJJbnZhbGlkU2lnbmF0dXJlXCJdID0gXCJua2V5czogc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBmYWlsZWRcIjtcbiAgICBOS2V5c0Vycm9yQ29kZVtcIkNhbm5vdFNpZ25cIl0gPSBcIm5rZXlzOiBjYW5ub3Qgc2lnbiwgbm8gcHJpdmF0ZSBrZXkgYXZhaWxhYmxlXCI7XG4gICAgTktleXNFcnJvckNvZGVbXCJQdWJsaWNLZXlPbmx5XCJdID0gXCJua2V5czogbm8gc2VlZCBvciBwcml2YXRlIGtleSBhdmFpbGFibGVcIjtcbiAgICBOS2V5c0Vycm9yQ29kZVtcIkludmFsaWRDaGVja3N1bVwiXSA9IFwibmtleXM6IGludmFsaWQgY2hlY2tzdW1cIjtcbiAgICBOS2V5c0Vycm9yQ29kZVtcIlNlcmlhbGl6YXRpb25FcnJvclwiXSA9IFwibmtleXM6IHNlcmlhbGl6YXRpb24gZXJyb3JcIjtcbiAgICBOS2V5c0Vycm9yQ29kZVtcIkFwaUVycm9yXCJdID0gXCJua2V5czogYXBpIGVycm9yXCI7XG4gICAgTktleXNFcnJvckNvZGVbXCJDbGVhcmVkUGFpclwiXSA9IFwibmtleXM6IHBhaXIgaXMgY2xlYXJlZFwiO1xufSkoTktleXNFcnJvckNvZGUgfHwgKE5LZXlzRXJyb3JDb2RlID0ge30pKTtcbnZhciBQcmVmaXg7XG4oZnVuY3Rpb24oUHJlZml4KSB7XG4gICAgUHJlZml4W1ByZWZpeFtcIlNlZWRcIl0gPSAxNDRdID0gXCJTZWVkXCI7XG4gICAgUHJlZml4W1ByZWZpeFtcIlByaXZhdGVcIl0gPSAxMjBdID0gXCJQcml2YXRlXCI7XG4gICAgUHJlZml4W1ByZWZpeFtcIk9wZXJhdG9yXCJdID0gMTEyXSA9IFwiT3BlcmF0b3JcIjtcbiAgICBQcmVmaXhbUHJlZml4W1wiU2VydmVyXCJdID0gMTA0XSA9IFwiU2VydmVyXCI7XG4gICAgUHJlZml4W1ByZWZpeFtcIkNsdXN0ZXJcIl0gPSAxNl0gPSBcIkNsdXN0ZXJcIjtcbiAgICBQcmVmaXhbUHJlZml4W1wiQWNjb3VudFwiXSA9IDBdID0gXCJBY2NvdW50XCI7XG4gICAgUHJlZml4W1ByZWZpeFtcIlVzZXJcIl0gPSAxNjBdID0gXCJVc2VyXCI7XG59KShQcmVmaXggfHwgKFByZWZpeCA9IHt9KSk7XG5jbGFzcyBQcmVmaXhlcyB7XG4gICAgc3RhdGljIGlzVmFsaWRQdWJsaWNQcmVmaXgocHJlZml4KSB7XG4gICAgICAgIHJldHVybiBwcmVmaXggPT0gUHJlZml4LlNlcnZlciB8fCBwcmVmaXggPT0gUHJlZml4Lk9wZXJhdG9yIHx8IHByZWZpeCA9PSBQcmVmaXguQ2x1c3RlciB8fCBwcmVmaXggPT0gUHJlZml4LkFjY291bnQgfHwgcHJlZml4ID09IFByZWZpeC5Vc2VyO1xuICAgIH1cbiAgICBzdGF0aWMgc3RhcnRzV2l0aFZhbGlkUHJlZml4KHMpIHtcbiAgICAgICAgbGV0IGMgPSBzWzBdO1xuICAgICAgICByZXR1cm4gYyA9PSBcIlNcIiB8fCBjID09IFwiUFwiIHx8IGMgPT0gXCJPXCIgfHwgYyA9PSBcIk5cIiB8fCBjID09IFwiQ1wiIHx8IGMgPT0gXCJBXCIgfHwgYyA9PSBcIlVcIjtcbiAgICB9XG4gICAgc3RhdGljIGlzVmFsaWRQcmVmaXgocHJlZml4KSB7XG4gICAgICAgIGxldCB2ID0gdGhpcy5wYXJzZVByZWZpeChwcmVmaXgpO1xuICAgICAgICByZXR1cm4gdiAhPSAtMTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlUHJlZml4KHYpIHtcbiAgICAgICAgc3dpdGNoKHYpe1xuICAgICAgICAgICAgY2FzZSBQcmVmaXguU2VlZDpcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJlZml4LlNlZWQ7XG4gICAgICAgICAgICBjYXNlIFByZWZpeC5Qcml2YXRlOlxuICAgICAgICAgICAgICAgIHJldHVybiBQcmVmaXguUHJpdmF0ZTtcbiAgICAgICAgICAgIGNhc2UgUHJlZml4Lk9wZXJhdG9yOlxuICAgICAgICAgICAgICAgIHJldHVybiBQcmVmaXguT3BlcmF0b3I7XG4gICAgICAgICAgICBjYXNlIFByZWZpeC5TZXJ2ZXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByZWZpeC5TZXJ2ZXI7XG4gICAgICAgICAgICBjYXNlIFByZWZpeC5DbHVzdGVyOlxuICAgICAgICAgICAgICAgIHJldHVybiBQcmVmaXguQ2x1c3RlcjtcbiAgICAgICAgICAgIGNhc2UgUHJlZml4LkFjY291bnQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByZWZpeC5BY2NvdW50O1xuICAgICAgICAgICAgY2FzZSBQcmVmaXguVXNlcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJlZml4LlVzZXI7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIENvZGVjIHtcbiAgICBzdGF0aWMgZW5jb2RlKHByZWZpeCwgc3JjKSB7XG4gICAgICAgIGlmICghc3JjIHx8ICEoc3JjIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLlNlcmlhbGl6YXRpb25FcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFQcmVmaXhlcy5pc1ZhbGlkUHJlZml4KHByZWZpeCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLkludmFsaWRQcmVmaXhCeXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ29kZWMuX2VuY29kZShmYWxzZSwgcHJlZml4LCBzcmMpO1xuICAgIH1cbiAgICBzdGF0aWMgZW5jb2RlU2VlZChyb2xlLCBzcmMpIHtcbiAgICAgICAgaWYgKCFzcmMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLkFwaUVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIVByZWZpeGVzLmlzVmFsaWRQdWJsaWNQcmVmaXgocm9sZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLkludmFsaWRQcmVmaXhCeXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3JjLmJ5dGVMZW5ndGggIT09IDMyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTktleXNFcnJvcihOS2V5c0Vycm9yQ29kZS5JbnZhbGlkU2VlZExlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENvZGVjLl9lbmNvZGUodHJ1ZSwgcm9sZSwgc3JjKTtcbiAgICB9XG4gICAgc3RhdGljIGRlY29kZShleHBlY3RlZCwgc3JjKSB7XG4gICAgICAgIGlmICghUHJlZml4ZXMuaXNWYWxpZFByZWZpeChleHBlY3RlZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLkludmFsaWRQcmVmaXhCeXRlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYXcgPSBDb2RlYy5fZGVjb2RlKHNyYyk7XG4gICAgICAgIGlmIChyYXdbMF0gIT09IGV4cGVjdGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTktleXNFcnJvcihOS2V5c0Vycm9yQ29kZS5JbnZhbGlkUHJlZml4Qnl0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhdy5zbGljZSgxKTtcbiAgICB9XG4gICAgc3RhdGljIGRlY29kZVNlZWQoc3JjKSB7XG4gICAgICAgIGNvbnN0IHJhdyA9IENvZGVjLl9kZWNvZGUoc3JjKTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gQ29kZWMuX2RlY29kZVByZWZpeChyYXcpO1xuICAgICAgICBpZiAocHJlZml4WzBdICE9IFByZWZpeC5TZWVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTktleXNFcnJvcihOS2V5c0Vycm9yQ29kZS5JbnZhbGlkU2VlZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFQcmVmaXhlcy5pc1ZhbGlkUHVibGljUHJlZml4KHByZWZpeFsxXSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLkludmFsaWRQcmVmaXhCeXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYnVmOiByYXcuc2xpY2UoMiksXG4gICAgICAgICAgICBwcmVmaXg6IHByZWZpeFsxXVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgX2VuY29kZShzZWVkLCByb2xlLCBwYXlsb2FkKSB7XG4gICAgICAgIGNvbnN0IHBheWxvYWRPZmZzZXQgPSBzZWVkID8gMiA6IDE7XG4gICAgICAgIGNvbnN0IHBheWxvYWRMZW4gPSBwYXlsb2FkLmJ5dGVMZW5ndGg7XG4gICAgICAgIGNvbnN0IGNhcCA9IHBheWxvYWRPZmZzZXQgKyBwYXlsb2FkTGVuICsgMjtcbiAgICAgICAgY29uc3QgY2hlY2tPZmZzZXQgPSBwYXlsb2FkT2Zmc2V0ICsgcGF5bG9hZExlbjtcbiAgICAgICAgY29uc3QgcmF3ID0gbmV3IFVpbnQ4QXJyYXkoY2FwKTtcbiAgICAgICAgaWYgKHNlZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWRQcmVmaXggPSBDb2RlYy5fZW5jb2RlUHJlZml4KFByZWZpeC5TZWVkLCByb2xlKTtcbiAgICAgICAgICAgIHJhdy5zZXQoZW5jb2RlZFByZWZpeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByYXdbMF0gPSByb2xlO1xuICAgICAgICB9XG4gICAgICAgIHJhdy5zZXQocGF5bG9hZCwgcGF5bG9hZE9mZnNldCk7XG4gICAgICAgIGNvbnN0IGNoZWNrc3VtID0gY3JjMTYuY2hlY2tzdW0ocmF3LnNsaWNlKDAsIGNoZWNrT2Zmc2V0KSk7XG4gICAgICAgIGNvbnN0IGR2ID0gbmV3IERhdGFWaWV3KHJhdy5idWZmZXIpO1xuICAgICAgICBkdi5zZXRVaW50MTYoY2hlY2tPZmZzZXQsIGNoZWNrc3VtLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGJhc2UzMi5lbmNvZGUocmF3KTtcbiAgICB9XG4gICAgc3RhdGljIF9kZWNvZGUoc3JjKSB7XG4gICAgICAgIGlmIChzcmMuYnl0ZUxlbmd0aCA8IDQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLkludmFsaWRFbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJhdztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJhdyA9IGJhc2UzMi5kZWNvZGUoc3JjKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLkludmFsaWRFbmNvZGluZywgZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoZWNrT2Zmc2V0ID0gcmF3LmJ5dGVMZW5ndGggLSAyO1xuICAgICAgICBjb25zdCBkdiA9IG5ldyBEYXRhVmlldyhyYXcuYnVmZmVyKTtcbiAgICAgICAgY29uc3QgY2hlY2tzdW0gPSBkdi5nZXRVaW50MTYoY2hlY2tPZmZzZXQsIHRydWUpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gcmF3LnNsaWNlKDAsIGNoZWNrT2Zmc2V0KTtcbiAgICAgICAgaWYgKCFjcmMxNi52YWxpZGF0ZShwYXlsb2FkLCBjaGVja3N1bSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLkludmFsaWRDaGVja3N1bSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfVxuICAgIHN0YXRpYyBfZW5jb2RlUHJlZml4KGtpbmQsIHJvbGUpIHtcbiAgICAgICAgY29uc3QgYjEgPSBraW5kIHwgcm9sZSA+PiA1O1xuICAgICAgICBjb25zdCBiMiA9IChyb2xlICYgMzEpIDw8IDM7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICBiMSxcbiAgICAgICAgICAgIGIyXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBzdGF0aWMgX2RlY29kZVByZWZpeChyYXcpIHtcbiAgICAgICAgY29uc3QgYjEgPSByYXdbMF0gJiAyNDg7XG4gICAgICAgIGNvbnN0IGIyID0gKHJhd1swXSAmIDcpIDw8IDUgfCAocmF3WzFdICYgMjQ4KSA+PiAzO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgYjEsXG4gICAgICAgICAgICBiMlxuICAgICAgICBdKTtcbiAgICB9XG59XG5jbGFzcyBLUCB7XG4gICAgc2VlZDtcbiAgICBjb25zdHJ1Y3RvcihzZWVkKXtcbiAgICAgICAgdGhpcy5zZWVkID0gc2VlZDtcbiAgICB9XG4gICAgZ2V0UmF3U2VlZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLkNsZWFyZWRQYWlyKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2QgPSBDb2RlYy5kZWNvZGVTZWVkKHRoaXMuc2VlZCk7XG4gICAgICAgIHJldHVybiBzZC5idWY7XG4gICAgfVxuICAgIGdldFNlZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5zZWVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTktleXNFcnJvcihOS2V5c0Vycm9yQ29kZS5DbGVhcmVkUGFpcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2VlZDtcbiAgICB9XG4gICAgZ2V0UHVibGljS2V5KCkge1xuICAgICAgICBpZiAoIXRoaXMuc2VlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5LZXlzRXJyb3IoTktleXNFcnJvckNvZGUuQ2xlYXJlZFBhaXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNkID0gQ29kZWMuZGVjb2RlU2VlZCh0aGlzLnNlZWQpO1xuICAgICAgICBjb25zdCBrcCA9IGdldEVkMjU1MTlIZWxwZXIoKS5mcm9tU2VlZCh0aGlzLmdldFJhd1NlZWQoKSk7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IENvZGVjLmVuY29kZShzZC5wcmVmaXgsIGtwLnB1YmxpY0tleSk7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnVmKTtcbiAgICB9XG4gICAgZ2V0UHJpdmF0ZUtleSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLkNsZWFyZWRQYWlyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrcCA9IGdldEVkMjU1MTlIZWxwZXIoKS5mcm9tU2VlZCh0aGlzLmdldFJhd1NlZWQoKSk7XG4gICAgICAgIHJldHVybiBDb2RlYy5lbmNvZGUoUHJlZml4LlByaXZhdGUsIGtwLnNlY3JldEtleSk7XG4gICAgfVxuICAgIHNpZ24oaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLkNsZWFyZWRQYWlyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrcCA9IGdldEVkMjU1MTlIZWxwZXIoKS5mcm9tU2VlZCh0aGlzLmdldFJhd1NlZWQoKSk7XG4gICAgICAgIHJldHVybiBnZXRFZDI1NTE5SGVscGVyKCkuc2lnbihpbnB1dCwga3Auc2VjcmV0S2V5KTtcbiAgICB9XG4gICAgdmVyaWZ5KGlucHV0LCBzaWcpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLkNsZWFyZWRQYWlyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrcCA9IGdldEVkMjU1MTlIZWxwZXIoKS5mcm9tU2VlZCh0aGlzLmdldFJhd1NlZWQoKSk7XG4gICAgICAgIHJldHVybiBnZXRFZDI1NTE5SGVscGVyKCkudmVyaWZ5KGlucHV0LCBzaWcsIGtwLnB1YmxpY0tleSk7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICBpZiAoIXRoaXMuc2VlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VlZC5maWxsKDApO1xuICAgICAgICB0aGlzLnNlZWQgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUGFpcihwcmVmaXgpIHtcbiAgICBjb25zdCByYXdTZWVkID0gZ2V0RWQyNTUxOUhlbHBlcigpLnJhbmRvbUJ5dGVzKDMyKTtcbiAgICBsZXQgc3RyID0gQ29kZWMuZW5jb2RlU2VlZChwcmVmaXgsIG5ldyBVaW50OEFycmF5KHJhd1NlZWQpKTtcbiAgICByZXR1cm4gbmV3IEtQKHN0cik7XG59XG5jbGFzcyBQdWJsaWNLZXkge1xuICAgIHB1YmxpY0tleTtcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWNLZXkpe1xuICAgICAgICB0aGlzLnB1YmxpY0tleSA9IHB1YmxpY0tleTtcbiAgICB9XG4gICAgZ2V0UHVibGljS2V5KCkge1xuICAgICAgICBpZiAoIXRoaXMucHVibGljS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTktleXNFcnJvcihOS2V5c0Vycm9yQ29kZS5DbGVhcmVkUGFpcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZSh0aGlzLnB1YmxpY0tleSk7XG4gICAgfVxuICAgIGdldFByaXZhdGVLZXkoKSB7XG4gICAgICAgIGlmICghdGhpcy5wdWJsaWNLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLkNsZWFyZWRQYWlyKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgTktleXNFcnJvcihOS2V5c0Vycm9yQ29kZS5QdWJsaWNLZXlPbmx5KTtcbiAgICB9XG4gICAgZ2V0U2VlZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnB1YmxpY0tleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5LZXlzRXJyb3IoTktleXNFcnJvckNvZGUuQ2xlYXJlZFBhaXIpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLlB1YmxpY0tleU9ubHkpO1xuICAgIH1cbiAgICBzaWduKF8pIHtcbiAgICAgICAgaWYgKCF0aGlzLnB1YmxpY0tleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5LZXlzRXJyb3IoTktleXNFcnJvckNvZGUuQ2xlYXJlZFBhaXIpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLkNhbm5vdFNpZ24pO1xuICAgIH1cbiAgICB2ZXJpZnkoaW5wdXQsIHNpZykge1xuICAgICAgICBpZiAoIXRoaXMucHVibGljS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTktleXNFcnJvcihOS2V5c0Vycm9yQ29kZS5DbGVhcmVkUGFpcik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJ1ZiA9IENvZGVjLl9kZWNvZGUodGhpcy5wdWJsaWNLZXkpO1xuICAgICAgICByZXR1cm4gZ2V0RWQyNTUxOUhlbHBlcigpLnZlcmlmeShpbnB1dCwgc2lnLCBidWYuc2xpY2UoMSkpO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnB1YmxpY0tleSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHVibGljS2V5LmZpbGwoMCk7XG4gICAgICAgIHRoaXMucHVibGljS2V5ID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZyb21QdWJsaWMoc3JjKSB7XG4gICAgY29uc3QgYmEgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3JjKTtcbiAgICBjb25zdCByYXcgPSBDb2RlYy5fZGVjb2RlKGJhKTtcbiAgICBjb25zdCBwcmVmaXggPSBQcmVmaXhlcy5wYXJzZVByZWZpeChyYXdbMF0pO1xuICAgIGlmIChQcmVmaXhlcy5pc1ZhbGlkUHVibGljUHJlZml4KHByZWZpeCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkoYmEpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgTktleXNFcnJvcihOS2V5c0Vycm9yQ29kZS5JbnZhbGlkUHVibGljS2V5KTtcbn1cbmZ1bmN0aW9uIGZyb21TZWVkKHNyYykge1xuICAgIENvZGVjLmRlY29kZVNlZWQoc3JjKTtcbiAgICByZXR1cm4gbmV3IEtQKHNyYyk7XG59XG5mdW5jdGlvbiBlbmNvZGUyKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZSguLi5ieXRlcykpO1xufVxuZnVuY3Rpb24gZGVjb2RlMihiNjRzdHIpIHtcbiAgICBjb25zdCBiaW4gPSBhdG9iKGI2NHN0cik7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShiaW4ubGVuZ3RoKTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgYmluLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgYnl0ZXNbaV0gPSBiaW4uY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuc2V0RWQyNTUxOUhlbHBlcihkZW5vSGVscGVyKTtcbmNvbnN0IG1vZCA9IHtcbiAgICBjcmVhdGVBY2NvdW50LFxuICAgIGNyZWF0ZU9wZXJhdG9yLFxuICAgIGNyZWF0ZVBhaXIsXG4gICAgY3JlYXRlVXNlcixcbiAgICBmcm9tUHVibGljLFxuICAgIGZyb21TZWVkLFxuICAgIE5LZXlzRXJyb3IsXG4gICAgTktleXNFcnJvckNvZGUsXG4gICAgUHJlZml4LFxuICAgIGRlY29kZTogZGVjb2RlMixcbiAgICBlbmNvZGU6IGVuY29kZTJcbn07XG5mdW5jdGlvbiBidWlsZEF1dGhlbnRpY2F0b3Iob3B0cykge1xuICAgIGlmIChvcHRzLmF1dGhlbnRpY2F0b3IpIHtcbiAgICAgICAgcmV0dXJuIG9wdHMuYXV0aGVudGljYXRvcjtcbiAgICB9XG4gICAgaWYgKG9wdHMudG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHRva2VuQXV0aGVudGljYXRvcihvcHRzLnRva2VuKTtcbiAgICB9XG4gICAgaWYgKG9wdHMudXNlcikge1xuICAgICAgICByZXR1cm4gdXNlcm5hbWVQYXNzd29yZEF1dGhlbnRpY2F0b3Iob3B0cy51c2VyLCBvcHRzLnBhc3MpO1xuICAgIH1cbiAgICByZXR1cm4gbm9BdXRoRm4oKTtcbn1cbmZ1bmN0aW9uIG5vQXV0aEZuKCkge1xuICAgIHJldHVybiAoKT0+e1xuICAgICAgICByZXR1cm47XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHVzZXJuYW1lUGFzc3dvcmRBdXRoZW50aWNhdG9yKHVzZXIsIHBhc3MpIHtcbiAgICByZXR1cm4gKCk9PntcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZXIsXG4gICAgICAgICAgICBwYXNzXG4gICAgICAgIH07XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRva2VuQXV0aGVudGljYXRvcih0b2tlbikge1xuICAgIHJldHVybiAoKT0+e1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXV0aF90b2tlbjogdG9rZW5cbiAgICAgICAgfTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbmtleUF1dGhlbnRpY2F0b3Ioc2VlZCkge1xuICAgIHJldHVybiAobm9uY2UpPT57XG4gICAgICAgIHNlZWQgPSB0eXBlb2Ygc2VlZCA9PT0gXCJmdW5jdGlvblwiID8gc2VlZCgpIDogc2VlZDtcbiAgICAgICAgY29uc3Qga3AgPSBzZWVkID8gbW9kLmZyb21TZWVkKHNlZWQpIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBua2V5ID0ga3AgPyBrcC5nZXRQdWJsaWNLZXkoKSA6IFwiXCI7XG4gICAgICAgIGNvbnN0IGNoYWxsZW5nZSA9IFRFLmVuY29kZShub25jZSB8fCBcIlwiKTtcbiAgICAgICAgY29uc3Qgc2lnQnl0ZXMgPSBrcCAhPT0gdW5kZWZpbmVkICYmIG5vbmNlID8ga3Auc2lnbihjaGFsbGVuZ2UpIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzaWcgPSBzaWdCeXRlcyA/IG1vZC5lbmNvZGUoc2lnQnl0ZXMpIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5rZXksXG4gICAgICAgICAgICBzaWdcbiAgICAgICAgfTtcbiAgICB9O1xufVxuZnVuY3Rpb24gand0QXV0aGVudGljYXRvcihhand0LCBzZWVkKSB7XG4gICAgcmV0dXJuIChub25jZSk9PntcbiAgICAgICAgY29uc3Qgand0ID0gdHlwZW9mIGFqd3QgPT09IFwiZnVuY3Rpb25cIiA/IGFqd3QoKSA6IGFqd3Q7XG4gICAgICAgIGNvbnN0IGZuID0gbmtleUF1dGhlbnRpY2F0b3Ioc2VlZCk7XG4gICAgICAgIGNvbnN0IHsgbmtleSAsIHNpZyAgfSA9IGZuKG5vbmNlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGp3dCxcbiAgICAgICAgICAgIG5rZXksXG4gICAgICAgICAgICBzaWdcbiAgICAgICAgfTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlZHNBdXRoZW50aWNhdG9yKGNyZWRzKSB7XG4gICAgY29uc3QgQ1JFRFMgPSAvXFxzKig/Oig/OlstXXszLH1bXlxcbl0qWy1dezMsfVxcbikoLispKD86XFxuXFxzKlstXXszLH1bXlxcbl0qWy1dezMsfVxcbikpL2lnO1xuICAgIGNvbnN0IHMgPSBURC5kZWNvZGUoY3JlZHMpO1xuICAgIGxldCBtID0gQ1JFRFMuZXhlYyhzKTtcbiAgICBpZiAoIW0pIHtcbiAgICAgICAgdGhyb3cgTmF0c0Vycm9yLmVycm9yRm9yQ29kZShFcnJvckNvZGUuQmFkQ3JlZHMpO1xuICAgIH1cbiAgICBjb25zdCBqd3QgPSBtWzFdLnRyaW0oKTtcbiAgICBtID0gQ1JFRFMuZXhlYyhzKTtcbiAgICBpZiAoIW0pIHtcbiAgICAgICAgdGhyb3cgTmF0c0Vycm9yLmVycm9yRm9yQ29kZShFcnJvckNvZGUuQmFkQ3JlZHMpO1xuICAgIH1cbiAgICBjb25zdCBzZWVkID0gVEUuZW5jb2RlKG1bMV0udHJpbSgpKTtcbiAgICByZXR1cm4gand0QXV0aGVudGljYXRvcihqd3QsIHNlZWQpO1xufVxuY2xhc3MgU3RyZWFtQVBJSW1wbCBleHRlbmRzIEJhc2VBcGlDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKG5jLCBvcHRzKXtcbiAgICAgICAgc3VwZXIobmMsIG9wdHMpO1xuICAgIH1cbiAgICBhc3luYyBhZGQoY2ZnID0ge30pIHtcbiAgICAgICAgdmFsaWRhdGVTdHJlYW1OYW1lKGNmZy5uYW1lKTtcbiAgICAgICAgY29uc3QgciA9IGF3YWl0IHRoaXMuX3JlcXVlc3QoYCR7dGhpcy5wcmVmaXh9LlNUUkVBTS5DUkVBVEUuJHtjZmcubmFtZX1gLCBjZmcpO1xuICAgICAgICBjb25zdCBzaSA9IHI7XG4gICAgICAgIHRoaXMuX2ZpeEluZm8oc2kpO1xuICAgICAgICByZXR1cm4gc2k7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZShzdHJlYW0pIHtcbiAgICAgICAgdmFsaWRhdGVTdHJlYW1OYW1lKHN0cmVhbSk7XG4gICAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLl9yZXF1ZXN0KGAke3RoaXMucHJlZml4fS5TVFJFQU0uREVMRVRFLiR7c3RyZWFtfWApO1xuICAgICAgICBjb25zdCBjciA9IHI7XG4gICAgICAgIHJldHVybiBjci5zdWNjZXNzO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGUobmFtZSwgY2ZnID0ge30pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBjb25zdCBzYyA9IG5hbWU7XG4gICAgICAgICAgICBuYW1lID0gc2MubmFtZTtcbiAgICAgICAgICAgIGNmZyA9IHNjO1xuICAgICAgICAgICAgY29uc29sZS50cmFjZShgXFx1MDAxQlszM20gPj4gc3RyZWFtcy51cGRhdGUoY29uZmlnOiBTdHJlYW1Db25maWcpIGFwaSBjaGFuZ2VkIHRvIHN0cmVhbXMudXBkYXRlKG5hbWU6IHN0cmluZywgY29uZmlnOiBTdHJlYW1VcGRhdGVDb25maWcpIC0gdGhpcyBzaGltIHdpbGwgYmUgcmVtb3ZlZCAtIHVwZGF0ZSB5b3VyIGNvZGUuICBcXHUwMDFCWzBtYCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsaWRhdGVTdHJlYW1OYW1lKG5hbWUpO1xuICAgICAgICBjb25zdCBvbGQgPSBhd2FpdCB0aGlzLmluZm8obmFtZSk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZSA9IE9iamVjdC5hc3NpZ24ob2xkLmNvbmZpZywgY2ZnKTtcbiAgICAgICAgY29uc3QgciA9IGF3YWl0IHRoaXMuX3JlcXVlc3QoYCR7dGhpcy5wcmVmaXh9LlNUUkVBTS5VUERBVEUuJHtuYW1lfWAsIHVwZGF0ZSk7XG4gICAgICAgIGNvbnN0IHNpID0gcjtcbiAgICAgICAgdGhpcy5fZml4SW5mbyhzaSk7XG4gICAgICAgIHJldHVybiBzaTtcbiAgICB9XG4gICAgYXN5bmMgaW5mbyhuYW1lLCBkYXRhKSB7XG4gICAgICAgIHZhbGlkYXRlU3RyZWFtTmFtZShuYW1lKTtcbiAgICAgICAgY29uc3QgciA9IGF3YWl0IHRoaXMuX3JlcXVlc3QoYCR7dGhpcy5wcmVmaXh9LlNUUkVBTS5JTkZPLiR7bmFtZX1gLCBkYXRhKTtcbiAgICAgICAgY29uc3Qgc2kgPSByO1xuICAgICAgICB0aGlzLl9maXhJbmZvKHNpKTtcbiAgICAgICAgcmV0dXJuIHNpO1xuICAgIH1cbiAgICBsaXN0KCkge1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSAodik9PntcbiAgICAgICAgICAgIGNvbnN0IHNsciA9IHY7XG4gICAgICAgICAgICBzbHIuc3RyZWFtcy5mb3JFYWNoKChzaSk9PntcbiAgICAgICAgICAgICAgICB0aGlzLl9maXhJbmZvKHNpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHNsci5zdHJlYW1zO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdWJqID0gYCR7dGhpcy5wcmVmaXh9LlNUUkVBTS5MSVNUYDtcbiAgICAgICAgcmV0dXJuIG5ldyBMaXN0ZXJJbXBsKHN1YmosIGZpbHRlciwgdGhpcyk7XG4gICAgfVxuICAgIF9maXhJbmZvKHNpKSB7XG4gICAgICAgIHNpLmNvbmZpZy5zZWFsZWQgPSBzaS5jb25maWcuc2VhbGVkIHx8IGZhbHNlO1xuICAgICAgICBzaS5jb25maWcuZGVueV9kZWxldGUgPSBzaS5jb25maWcuZGVueV9kZWxldGUgfHwgZmFsc2U7XG4gICAgICAgIHNpLmNvbmZpZy5kZW55X3B1cmdlID0gc2kuY29uZmlnLmRlbnlfcHVyZ2UgfHwgZmFsc2U7XG4gICAgICAgIHNpLmNvbmZpZy5hbGxvd19yb2xsdXBfaGRycyA9IHNpLmNvbmZpZy5hbGxvd19yb2xsdXBfaGRycyB8fCBmYWxzZTtcbiAgICB9XG4gICAgYXN5bmMgcHVyZ2UobmFtZSwgb3B0cykge1xuICAgICAgICBpZiAob3B0cykge1xuICAgICAgICAgICAgY29uc3QgeyBrZWVwICwgc2VxICB9ID0gb3B0cztcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2VlcCA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2Ygc2VxID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FuIHNwZWNpZnkgb25lIG9mIGtlZXAgb3Igc2VxXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhbGlkYXRlU3RyZWFtTmFtZShuYW1lKTtcbiAgICAgICAgY29uc3QgdiA9IGF3YWl0IHRoaXMuX3JlcXVlc3QoYCR7dGhpcy5wcmVmaXh9LlNUUkVBTS5QVVJHRS4ke25hbWV9YCwgb3B0cyk7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVNZXNzYWdlKHN0cmVhbSwgc2VxLCBlcmFzZSA9IHRydWUpIHtcbiAgICAgICAgdmFsaWRhdGVTdHJlYW1OYW1lKHN0cmVhbSk7XG4gICAgICAgIGNvbnN0IGRyID0ge1xuICAgICAgICAgICAgc2VxXG4gICAgICAgIH07XG4gICAgICAgIGlmICghZXJhc2UpIHtcbiAgICAgICAgICAgIGRyLm5vX2VyYXNlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByID0gYXdhaXQgdGhpcy5fcmVxdWVzdChgJHt0aGlzLnByZWZpeH0uU1RSRUFNLk1TRy5ERUxFVEUuJHtzdHJlYW19YCwgZHIpO1xuICAgICAgICBjb25zdCBjciA9IHI7XG4gICAgICAgIHJldHVybiBjci5zdWNjZXNzO1xuICAgIH1cbiAgICBhc3luYyBnZXRNZXNzYWdlKHN0cmVhbSwgcXVlcnkpIHtcbiAgICAgICAgdmFsaWRhdGVTdHJlYW1OYW1lKHN0cmVhbSk7XG4gICAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLl9yZXF1ZXN0KGAke3RoaXMucHJlZml4fS5TVFJFQU0uTVNHLkdFVC4ke3N0cmVhbX1gLCBxdWVyeSk7XG4gICAgICAgIGNvbnN0IHNtID0gcjtcbiAgICAgICAgcmV0dXJuIG5ldyBTdG9yZWRNc2dJbXBsKHNtKTtcbiAgICB9XG4gICAgZmluZChzdWJqZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRTdHJlYW0oc3ViamVjdCk7XG4gICAgfVxufVxuY2xhc3MgU3RvcmVkTXNnSW1wbCB7XG4gICAgc3ViamVjdDtcbiAgICBzZXE7XG4gICAgZGF0YTtcbiAgICB0aW1lO1xuICAgIGhlYWRlcjtcbiAgICBjb25zdHJ1Y3RvcihzbXIpe1xuICAgICAgICB0aGlzLnN1YmplY3QgPSBzbXIubWVzc2FnZS5zdWJqZWN0O1xuICAgICAgICB0aGlzLnNlcSA9IHNtci5tZXNzYWdlLnNlcTtcbiAgICAgICAgdGhpcy50aW1lID0gbmV3IERhdGUoRGF0ZS5wYXJzZShzbXIubWVzc2FnZS50aW1lKSk7XG4gICAgICAgIHRoaXMuZGF0YSA9IHNtci5tZXNzYWdlLmRhdGEgPyB0aGlzLl9wYXJzZShzbXIubWVzc2FnZS5kYXRhKSA6IEVtcHR5O1xuICAgICAgICBpZiAoc21yLm1lc3NhZ2UuaGRycykge1xuICAgICAgICAgICAgY29uc3QgaGQgPSB0aGlzLl9wYXJzZShzbXIubWVzc2FnZS5oZHJzKTtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyID0gTXNnSGRyc0ltcGwuZGVjb2RlKGhkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyID0gaGVhZGVycygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wYXJzZShzKSB7XG4gICAgICAgIGNvbnN0IGJzID0gYXRvYihzKTtcbiAgICAgICAgY29uc3QgbGVuID0gYnMubGVuZ3RoO1xuICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgICAgICAgICBieXRlc1tpXSA9IGJzLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbn1cbmNsYXNzIERpcmVjdFN0cmVhbUFQSUltcGwgZXh0ZW5kcyBCYXNlQXBpQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcihuYywgb3B0cyl7XG4gICAgICAgIHN1cGVyKG5jLCBvcHRzKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TWVzc2FnZShzdHJlYW0sIHF1ZXJ5KSB7XG4gICAgICAgIHZhbGlkYXRlU3RyZWFtTmFtZShzdHJlYW0pO1xuICAgICAgICBsZXQgcXEgPSBxdWVyeTtcbiAgICAgICAgY29uc3QgeyBsYXN0X2J5X3N1YmogIH0gPSBxcTtcbiAgICAgICAgaWYgKGxhc3RfYnlfc3Viaikge1xuICAgICAgICAgICAgcXEgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBxcSA/IHRoaXMuamMuZW5jb2RlKHFxKSA6IEVtcHR5O1xuICAgICAgICBjb25zdCBzdWJqID0gbGFzdF9ieV9zdWJqID8gYCRKUy5BUEkuRElSRUNULkdFVC4ke3N0cmVhbX0uJHtsYXN0X2J5X3N1Ymp9YCA6IGAkSlMuQVBJLkRJUkVDVC5HRVQuJHtzdHJlYW19YDtcbiAgICAgICAgY29uc3QgciA9IGF3YWl0IHRoaXMubmMucmVxdWVzdChzdWJqLCBwYXlsb2FkKTtcbiAgICAgICAgY29uc3QgZXJyID0gY2hlY2tKc0Vycm9yKHIpO1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkbSA9IG5ldyBEaXJlY3RNc2dJbXBsKHIpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRtKTtcbiAgICB9XG59XG5jbGFzcyBEaXJlY3RNc2dJbXBsIHtcbiAgICBkYXRhO1xuICAgIGhlYWRlcjtcbiAgICBjb25zdHJ1Y3RvcihtKXtcbiAgICAgICAgaWYgKCFtLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImhlYWRlcnMgZXhwZWN0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhID0gbS5kYXRhO1xuICAgICAgICB0aGlzLmhlYWRlciA9IG0uaGVhZGVycztcbiAgICB9XG4gICAgZ2V0IHN1YmplY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYWRlci5nZXQoRGlyZWN0TXNnSGVhZGVycy5TdWJqZWN0KTtcbiAgICB9XG4gICAgZ2V0IHNlcSgpIHtcbiAgICAgICAgY29uc3QgdiA9IHRoaXMuaGVhZGVyLmdldChEaXJlY3RNc2dIZWFkZXJzLlNlcXVlbmNlKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2ID09PSBcInN0cmluZ1wiID8gcGFyc2VJbnQodikgOiAwO1xuICAgIH1cbiAgICBnZXQgdGltZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUucGFyc2UodGhpcy5oZWFkZXIuZ2V0KERpcmVjdE1zZ0hlYWRlcnMuVGltZVN0YW1wKSkpO1xuICAgIH1cbiAgICBnZXQgc3RyZWFtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXIuZ2V0KERpcmVjdE1zZ0hlYWRlcnMuU3RyZWFtKTtcbiAgICB9XG59XG5jbGFzcyBKZXRTdHJlYW1NYW5hZ2VySW1wbCBleHRlbmRzIEJhc2VBcGlDbGllbnQge1xuICAgIHN0cmVhbXM7XG4gICAgY29uc3VtZXJzO1xuICAgIGRpcmVjdDtcbiAgICBjb25zdHJ1Y3RvcihuYywgb3B0cyl7XG4gICAgICAgIHN1cGVyKG5jLCBvcHRzKTtcbiAgICAgICAgdGhpcy5zdHJlYW1zID0gbmV3IFN0cmVhbUFQSUltcGwobmMsIG9wdHMpO1xuICAgICAgICB0aGlzLmNvbnN1bWVycyA9IG5ldyBDb25zdW1lckFQSUltcGwobmMsIG9wdHMpO1xuICAgICAgICB0aGlzLmRpcmVjdCA9IG5ldyBEaXJlY3RTdHJlYW1BUElJbXBsKG5jLCBvcHRzKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QWNjb3VudEluZm8oKSB7XG4gICAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLl9yZXF1ZXN0KGAke3RoaXMucHJlZml4fS5JTkZPYCk7XG4gICAgICAgIHJldHVybiByO1xuICAgIH1cbiAgICBhZHZpc29yaWVzKCkge1xuICAgICAgICBjb25zdCBpdGVyID0gbmV3IFF1ZXVlZEl0ZXJhdG9ySW1wbCgpO1xuICAgICAgICB0aGlzLm5jLnN1YnNjcmliZShgJEpTLkVWRU5ULkFEVklTT1JZLj5gLCB7XG4gICAgICAgICAgICBjYWxsYmFjazogKGVyciwgbXNnKT0+e1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkID0gdGhpcy5wYXJzZUpzUmVzcG9uc2UobXNnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmtzID0gZC50eXBlLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2luZCA9IGNodW5rc1tjaHVua3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGl0ZXIucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBraW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIxKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXIuc3RvcChlcnIxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaXRlcjtcbiAgICB9XG59XG5jbGFzcyBNZXRyaWMge1xuICAgIG5hbWU7XG4gICAgZHVyYXRpb247XG4gICAgZGF0ZTtcbiAgICBwYXlsb2FkO1xuICAgIG1zZ3M7XG4gICAgbGFuZztcbiAgICB2ZXJzaW9uO1xuICAgIGJ5dGVzO1xuICAgIGFzeW5jUmVxdWVzdHM7XG4gICAgbWluO1xuICAgIG1heDtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBkdXJhdGlvbil7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgdGhpcy5kYXRlID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5wYXlsb2FkID0gMDtcbiAgICAgICAgdGhpcy5tc2dzID0gMDtcbiAgICAgICAgdGhpcy5ieXRlcyA9IDA7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBzZWMgPSB0aGlzLmR1cmF0aW9uIC8gMTAwMDtcbiAgICAgICAgY29uc3QgbXBzID0gTWF0aC5yb3VuZCh0aGlzLm1zZ3MgLyBzZWMpO1xuICAgICAgICBjb25zdCBsYWJlbCA9IHRoaXMuYXN5bmNSZXF1ZXN0cyA/IFwiYXN5bmNSZXF1ZXN0c1wiIDogXCJcIjtcbiAgICAgICAgbGV0IG1pbm1heCA9IFwiXCI7XG4gICAgICAgIGlmICh0aGlzLm1heCkge1xuICAgICAgICAgICAgbWlubWF4ID0gYCR7dGhpcy5taW59LyR7dGhpcy5tYXh9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7dGhpcy5uYW1lfSR7bGFiZWwgPyBcIiBbYXN5bmNSZXF1ZXN0c11cIiA6IFwiXCJ9ICR7aHVtYW5pemVOdW1iZXIobXBzKX0gbXNncy9zZWMgLSBbJHtzZWMudG9GaXhlZCgyKX0gc2Vjc10gfiAke3Rocm91Z2hwdXQodGhpcy5ieXRlcywgc2VjKX0gJHttaW5tYXh9YDtcbiAgICB9XG4gICAgdG9Dc3YoKSB7XG4gICAgICAgIHJldHVybiBgXCIke3RoaXMubmFtZX1cIiwke25ldyBEYXRlKHRoaXMuZGF0ZSkudG9JU09TdHJpbmcoKX0sJHt0aGlzLmxhbmd9LCR7dGhpcy52ZXJzaW9ufSwke3RoaXMubXNnc30sJHt0aGlzLnBheWxvYWR9LCR7dGhpcy5ieXRlc30sJHt0aGlzLmR1cmF0aW9ufSwke3RoaXMuYXN5bmNSZXF1ZXN0cyA/IHRoaXMuYXN5bmNSZXF1ZXN0cyA6IGZhbHNlfVxcbmA7XG4gICAgfVxuICAgIHN0YXRpYyBoZWFkZXIoKSB7XG4gICAgICAgIHJldHVybiBgVGVzdCxEYXRlLExhbmcsVmVyc2lvbixDb3VudCxNc2dQYXlsb2FkLEJ5dGVzLE1pbGxpcyxBc3luY1xcbmA7XG4gICAgfVxufVxuY2xhc3MgQmVuY2gge1xuICAgIG5jO1xuICAgIGNhbGxiYWNrcztcbiAgICBtc2dzO1xuICAgIHNpemU7XG4gICAgc3ViamVjdDtcbiAgICBhc3luY1JlcXVlc3RzO1xuICAgIHB1YjtcbiAgICBzdWI7XG4gICAgcmVxO1xuICAgIHJlcDtcbiAgICBwZXJmO1xuICAgIHBheWxvYWQ7XG4gICAgY29uc3RydWN0b3IobmMsIG9wdHMgPSB7XG4gICAgICAgIG1zZ3M6IDEwMDAwMCxcbiAgICAgICAgc2l6ZTogMTI4LFxuICAgICAgICBzdWJqZWN0OiBcIlwiLFxuICAgICAgICBhc3luY1JlcXVlc3RzOiBmYWxzZSxcbiAgICAgICAgcHViOiBmYWxzZSxcbiAgICAgICAgc3ViOiBmYWxzZSxcbiAgICAgICAgcmVxOiBmYWxzZSxcbiAgICAgICAgcmVwOiBmYWxzZVxuICAgIH0pe1xuICAgICAgICB0aGlzLm5jID0gbmM7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gb3B0cy5jYWxsYmFja3MgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMubXNncyA9IG9wdHMubXNncyB8fCAwO1xuICAgICAgICB0aGlzLnNpemUgPSBvcHRzLnNpemUgfHwgMDtcbiAgICAgICAgdGhpcy5zdWJqZWN0ID0gb3B0cy5zdWJqZWN0IHx8IG51aWQubmV4dCgpO1xuICAgICAgICB0aGlzLmFzeW5jUmVxdWVzdHMgPSBvcHRzLmFzeW5jUmVxdWVzdHMgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMucHViID0gb3B0cy5wdWIgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMuc3ViID0gb3B0cy5zdWIgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMucmVxID0gb3B0cy5yZXEgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMucmVwID0gb3B0cy5yZXAgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMucGVyZiA9IG5ldyBQZXJmKCk7XG4gICAgICAgIHRoaXMucGF5bG9hZCA9IHRoaXMuc2l6ZSA/IG5ldyBVaW50OEFycmF5KHRoaXMuc2l6ZSkgOiBFbXB0eTtcbiAgICAgICAgaWYgKCF0aGlzLnB1YiAmJiAhdGhpcy5zdWIgJiYgIXRoaXMucmVxICYmICF0aGlzLnJlcCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gYmVuY2ggb3B0aW9uIHNlbGVjdGVkXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHJ1bigpIHtcbiAgICAgICAgdGhpcy5uYy5jbG9zZWQoKS50aGVuKChlcnIpPT57XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5hdHNFcnJvcihgYmVuY2ggY2xvc2VkIHdpdGggYW4gZXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YCwgRXJyb3JDb2RlLlVua25vd24sIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucnVuQ2FsbGJhY2tzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJ1bkFzeW5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc01ldHJpY3MoKTtcbiAgICB9XG4gICAgcHJvY2Vzc01ldHJpY3MoKSB7XG4gICAgICAgIGNvbnN0IG5jID0gdGhpcy5uYztcbiAgICAgICAgY29uc3QgeyBsYW5nICwgdmVyc2lvbiAgfSA9IG5jLnByb3RvY29sLnRyYW5zcG9ydDtcbiAgICAgICAgaWYgKHRoaXMucHViICYmIHRoaXMuc3ViKSB7XG4gICAgICAgICAgICB0aGlzLnBlcmYubWVhc3VyZShcInB1YnN1YlwiLCBcInB1YlN0YXJ0XCIsIFwic3ViU3RvcFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZWFzdXJlcyA9IHRoaXMucGVyZi5nZXRFbnRyaWVzKCk7XG4gICAgICAgIGNvbnN0IHB1YnN1YiA9IG1lYXN1cmVzLmZpbmQoKG0pPT5tLm5hbWUgPT09IFwicHVic3ViXCIpO1xuICAgICAgICBjb25zdCByZXEgPSBtZWFzdXJlcy5maW5kKChtKT0+bS5uYW1lID09PSBcInJlcVwiKTtcbiAgICAgICAgY29uc3QgcHViID0gbWVhc3VyZXMuZmluZCgobSk9Pm0ubmFtZSA9PT0gXCJwdWJcIik7XG4gICAgICAgIGNvbnN0IHN1YiA9IG1lYXN1cmVzLmZpbmQoKG0pPT5tLm5hbWUgPT09IFwic3ViXCIpO1xuICAgICAgICBjb25zdCBzdGF0cyA9IHRoaXMubmMuc3RhdHMoKTtcbiAgICAgICAgY29uc3QgbWV0cmljcyA9IFtdO1xuICAgICAgICBpZiAocHVic3ViKSB7XG4gICAgICAgICAgICBjb25zdCB7IG5hbWUgLCBkdXJhdGlvbiAgfSA9IHB1YnN1YjtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBuZXcgTWV0cmljKG5hbWUsIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIG0ubXNncyA9IHRoaXMubXNncyAqIDI7XG4gICAgICAgICAgICBtLmJ5dGVzID0gc3RhdHMuaW5CeXRlcyArIHN0YXRzLm91dEJ5dGVzO1xuICAgICAgICAgICAgbS5sYW5nID0gbGFuZztcbiAgICAgICAgICAgIG0udmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgICAgICBtLnBheWxvYWQgPSB0aGlzLnBheWxvYWQubGVuZ3RoO1xuICAgICAgICAgICAgbWV0cmljcy5wdXNoKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwdWIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZTogbmFtZTEgLCBkdXJhdGlvbjogZHVyYXRpb24xICB9ID0gcHViO1xuICAgICAgICAgICAgY29uc3QgbTEgPSBuZXcgTWV0cmljKG5hbWUxLCBkdXJhdGlvbjEpO1xuICAgICAgICAgICAgbTEubXNncyA9IHRoaXMubXNncztcbiAgICAgICAgICAgIG0xLmJ5dGVzID0gc3RhdHMub3V0Qnl0ZXM7XG4gICAgICAgICAgICBtMS5sYW5nID0gbGFuZztcbiAgICAgICAgICAgIG0xLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICAgICAgbTEucGF5bG9hZCA9IHRoaXMucGF5bG9hZC5sZW5ndGg7XG4gICAgICAgICAgICBtZXRyaWNzLnB1c2gobTEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdWIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZTogbmFtZTIgLCBkdXJhdGlvbjogZHVyYXRpb24yICB9ID0gc3ViO1xuICAgICAgICAgICAgY29uc3QgbTIgPSBuZXcgTWV0cmljKG5hbWUyLCBkdXJhdGlvbjIpO1xuICAgICAgICAgICAgbTIubXNncyA9IHRoaXMubXNncztcbiAgICAgICAgICAgIG0yLmJ5dGVzID0gc3RhdHMuaW5CeXRlcztcbiAgICAgICAgICAgIG0yLmxhbmcgPSBsYW5nO1xuICAgICAgICAgICAgbTIudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgICAgICBtMi5wYXlsb2FkID0gdGhpcy5wYXlsb2FkLmxlbmd0aDtcbiAgICAgICAgICAgIG1ldHJpY3MucHVzaChtMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcSkge1xuICAgICAgICAgICAgY29uc3QgeyBuYW1lOiBuYW1lMyAsIGR1cmF0aW9uOiBkdXJhdGlvbjMgIH0gPSByZXE7XG4gICAgICAgICAgICBjb25zdCBtMyA9IG5ldyBNZXRyaWMobmFtZTMsIGR1cmF0aW9uMyk7XG4gICAgICAgICAgICBtMy5tc2dzID0gdGhpcy5tc2dzICogMjtcbiAgICAgICAgICAgIG0zLmJ5dGVzID0gc3RhdHMuaW5CeXRlcyArIHN0YXRzLm91dEJ5dGVzO1xuICAgICAgICAgICAgbTMubGFuZyA9IGxhbmc7XG4gICAgICAgICAgICBtMy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgICAgIG0zLnBheWxvYWQgPSB0aGlzLnBheWxvYWQubGVuZ3RoO1xuICAgICAgICAgICAgbWV0cmljcy5wdXNoKG0zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0cmljcztcbiAgICB9XG4gICAgYXN5bmMgcnVuQ2FsbGJhY2tzKCkge1xuICAgICAgICBjb25zdCBqb2JzID0gW107XG4gICAgICAgIGlmICh0aGlzLnJlcSkge1xuICAgICAgICAgICAgY29uc3QgZCA9IGRlZmVycmVkKCk7XG4gICAgICAgICAgICBqb2JzLnB1c2goZCk7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSB0aGlzLm5jLnN1YnNjcmliZSh0aGlzLnN1YmplY3QsIHtcbiAgICAgICAgICAgICAgICBtYXg6IHRoaXMubXNncyxcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogKF8sIG0pPT57XG4gICAgICAgICAgICAgICAgICAgIG0ucmVzcG9uZCh0aGlzLnBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3ViLmdldFByb2Nlc3NlZCgpID09PSB0aGlzLm1zZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3ViKSB7XG4gICAgICAgICAgICBjb25zdCBkMSA9IGRlZmVycmVkKCk7XG4gICAgICAgICAgICBqb2JzLnB1c2goZDEpO1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgdGhpcy5uYy5zdWJzY3JpYmUodGhpcy5zdWJqZWN0LCB7XG4gICAgICAgICAgICAgICAgbWF4OiB0aGlzLm1zZ3MsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6ICgpPT57XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tYXJrKFwic3ViU3RhcnRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IHRoaXMubXNncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmLm1hcmsoXCJzdWJTdG9wXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmLm1lYXN1cmUoXCJzdWJcIiwgXCJzdWJTdGFydFwiLCBcInN1YlN0b3BcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBkMS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wdWIpIHtcbiAgICAgICAgICAgIGNvbnN0IGpvYiA9IChhc3luYyAoKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tYXJrKFwicHViU3RhcnRcIik7XG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMubXNnczsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYy5wdWJsaXNoKHRoaXMuc3ViamVjdCwgdGhpcy5wYXlsb2FkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5uYy5mbHVzaCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tYXJrKFwicHViU3RvcFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWVhc3VyZShcInB1YlwiLCBcInB1YlN0YXJ0XCIsIFwicHViU3RvcFwiKTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBqb2JzLnB1c2goam9iKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXEpIHtcbiAgICAgICAgICAgIGNvbnN0IGpvYjEgPSAoYXN5bmMgKCk9PntcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hc3luY1JlcXVlc3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tYXJrKFwicmVxU3RhcnRcIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMubXNnczsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaCh0aGlzLm5jLnJlcXVlc3QodGhpcy5zdWJqZWN0LCB0aGlzLnBheWxvYWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiAyMDAwMFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWFyayhcInJlcVN0b3BcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tZWFzdXJlKFwicmVxXCIsIFwicmVxU3RhcnRcIiwgXCJyZXFTdG9wXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tYXJrKFwicmVxU3RhcnRcIik7XG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaTEgPSAwOyBpMSA8IHRoaXMubXNnczsgaTErKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm5jLnJlcXVlc3QodGhpcy5zdWJqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWFyayhcInJlcVN0b3BcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tZWFzdXJlKFwicmVxXCIsIFwicmVxU3RhcnRcIiwgXCJyZXFTdG9wXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBqb2JzLnB1c2goam9iMSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoam9icyk7XG4gICAgfVxuICAgIGFzeW5jIHJ1bkFzeW5jKCkge1xuICAgICAgICBjb25zdCBqb2JzID0gW107XG4gICAgICAgIGlmICh0aGlzLnJlcSkge1xuICAgICAgICAgICAgY29uc3Qgc3ViID0gdGhpcy5uYy5zdWJzY3JpYmUodGhpcy5zdWJqZWN0LCB7XG4gICAgICAgICAgICAgICAgbWF4OiB0aGlzLm1zZ3NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgam9iID0gKGFzeW5jICgpPT57XG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBtIG9mIHN1Yil7XG4gICAgICAgICAgICAgICAgICAgIG0ucmVzcG9uZCh0aGlzLnBheWxvYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBqb2JzLnB1c2goam9iKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdWIpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3Qgc3ViMSA9IHRoaXMubmMuc3Vic2NyaWJlKHRoaXMuc3ViamVjdCwge1xuICAgICAgICAgICAgICAgIG1heDogdGhpcy5tc2dzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGpvYjEgPSAoYXN5bmMgKCk9PntcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IF9tIG9mIHN1YjEpe1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWFyayhcInN1YlN0YXJ0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tYXJrKFwic3ViU3RvcFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWVhc3VyZShcInN1YlwiLCBcInN1YlN0YXJ0XCIsIFwic3ViU3RvcFwiKTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBqb2JzLnB1c2goam9iMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHViKSB7XG4gICAgICAgICAgICBjb25zdCBqb2IyID0gKGFzeW5jICgpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5wZXJmLm1hcmsoXCJwdWJTdGFydFwiKTtcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5tc2dzOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5jLnB1Ymxpc2godGhpcy5zdWJqZWN0LCB0aGlzLnBheWxvYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm5jLmZsdXNoKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZXJmLm1hcmsoXCJwdWJTdG9wXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tZWFzdXJlKFwicHViXCIsIFwicHViU3RhcnRcIiwgXCJwdWJTdG9wXCIpO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIGpvYnMucHVzaChqb2IyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXEpIHtcbiAgICAgICAgICAgIGNvbnN0IGpvYjMgPSAoYXN5bmMgKCk9PntcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hc3luY1JlcXVlc3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tYXJrKFwicmVxU3RhcnRcIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMubXNnczsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaCh0aGlzLm5jLnJlcXVlc3QodGhpcy5zdWJqZWN0LCB0aGlzLnBheWxvYWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiAyMDAwMFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWFyayhcInJlcVN0b3BcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tZWFzdXJlKFwicmVxXCIsIFwicmVxU3RhcnRcIiwgXCJyZXFTdG9wXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tYXJrKFwicmVxU3RhcnRcIik7XG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaTEgPSAwOyBpMSA8IHRoaXMubXNnczsgaTErKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm5jLnJlcXVlc3QodGhpcy5zdWJqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWFyayhcInJlcVN0b3BcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tZWFzdXJlKFwicmVxXCIsIFwicmVxU3RhcnRcIiwgXCJyZXFTdG9wXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBqb2JzLnB1c2goam9iMyk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoam9icyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdGhyb3VnaHB1dChieXRlcywgc2Vjb25kcykge1xuICAgIHJldHVybiBodW1hbml6ZUJ5dGVzKGJ5dGVzIC8gc2Vjb25kcyk7XG59XG5mdW5jdGlvbiBodW1hbml6ZUJ5dGVzKGJ5dGVzLCBzaSA9IGZhbHNlKSB7XG4gICAgY29uc3QgYmFzZSA9IHNpID8gMTAwMCA6IDEwMjQ7XG4gICAgY29uc3QgcHJlID0gc2kgPyBbXG4gICAgICAgIFwia1wiLFxuICAgICAgICBcIk1cIixcbiAgICAgICAgXCJHXCIsXG4gICAgICAgIFwiVFwiLFxuICAgICAgICBcIlBcIixcbiAgICAgICAgXCJFXCJcbiAgICBdIDogW1xuICAgICAgICBcIktcIixcbiAgICAgICAgXCJNXCIsXG4gICAgICAgIFwiR1wiLFxuICAgICAgICBcIlRcIixcbiAgICAgICAgXCJQXCIsXG4gICAgICAgIFwiRVwiXG4gICAgXTtcbiAgICBjb25zdCBwb3N0ID0gc2kgPyBcImlCXCIgOiBcIkJcIjtcbiAgICBpZiAoYnl0ZXMgPCBiYXNlKSB7XG4gICAgICAgIHJldHVybiBgJHtieXRlcy50b0ZpeGVkKDIpfSAke3Bvc3R9L3NlY2A7XG4gICAgfVxuICAgIGNvbnN0IGV4cCA9IHBhcnNlSW50KE1hdGgubG9nKGJ5dGVzKSAvIE1hdGgubG9nKGJhc2UpICsgXCJcIik7XG4gICAgY29uc3QgaW5kZXggPSBwYXJzZUludChleHAgLSAxICsgXCJcIik7XG4gICAgcmV0dXJuIGAkeyhieXRlcyAvIE1hdGgucG93KGJhc2UsIGV4cCkpLnRvRml4ZWQoMil9ICR7cHJlW2luZGV4XX0ke3Bvc3R9L3NlY2A7XG59XG5mdW5jdGlvbiBodW1hbml6ZU51bWJlcihuKSB7XG4gICAgcmV0dXJuIG4udG9TdHJpbmcoKS5yZXBsYWNlKC9cXEIoPz0oXFxkezN9KSsoPyFcXGQpKS9nLCBcIixcIik7XG59XG5leHBvcnQgeyBBY2tQb2xpY3kgYXMgQWNrUG9saWN5LCBBZHZpc29yeUtpbmQgYXMgQWR2aXNvcnlLaW5kLCBCZW5jaCBhcyBCZW5jaCwgY2Fub25pY2FsTUlNRUhlYWRlcktleSBhcyBjYW5vbmljYWxNSU1FSGVhZGVyS2V5LCBjaGVja0pzRXJyb3IgYXMgY2hlY2tKc0Vycm9yLCBjb25zdW1lck9wdHMgYXMgY29uc3VtZXJPcHRzLCBjcmVhdGVJbmJveCBhcyBjcmVhdGVJbmJveCwgY3JlZHNBdXRoZW50aWNhdG9yIGFzIGNyZWRzQXV0aGVudGljYXRvciwgRGVidWdFdmVudHMgYXMgRGVidWdFdmVudHMsIGRlZmVycmVkIGFzIGRlZmVycmVkLCBEZWxpdmVyUG9saWN5IGFzIERlbGl2ZXJQb2xpY3ksIERpc2NhcmRQb2xpY3kgYXMgRGlzY2FyZFBvbGljeSwgRW1wdHkgYXMgRW1wdHksIEVycm9yQ29kZSBhcyBFcnJvckNvZGUsIEV2ZW50cyBhcyBFdmVudHMsIGhlYWRlcnMgYXMgaGVhZGVycywgaXNGbG93Q29udHJvbE1zZyBhcyBpc0Zsb3dDb250cm9sTXNnLCBpc0hlYXJ0YmVhdE1zZyBhcyBpc0hlYXJ0YmVhdE1zZywgSnNIZWFkZXJzIGFzIEpzSGVhZGVycywgSlNPTkNvZGVjIGFzIEpTT05Db2RlYywgand0QXV0aGVudGljYXRvciBhcyBqd3RBdXRoZW50aWNhdG9yLCBNYXRjaCBhcyBNYXRjaCwgTWV0cmljIGFzIE1ldHJpYywgbWlsbGlzIGFzIG1pbGxpcywgTXNnSGRyc0ltcGwgYXMgTXNnSGRyc0ltcGwsIG5hbm9zIGFzIG5hbm9zLCBOYXRzRXJyb3IgYXMgTmF0c0Vycm9yLCBua2V5QXV0aGVudGljYXRvciBhcyBua2V5QXV0aGVudGljYXRvciwgTnVpZCBhcyBOdWlkLCBudWlkIGFzIG51aWQsIFJlcGxheVBvbGljeSBhcyBSZXBsYXlQb2xpY3ksIFJldGVudGlvblBvbGljeSBhcyBSZXRlbnRpb25Qb2xpY3ksIFN0b3JhZ2VUeXBlIGFzIFN0b3JhZ2VUeXBlLCBTdHJpbmdDb2RlYyBhcyBTdHJpbmdDb2RlYywgdG9Kc01zZyBhcyB0b0pzTXNnLCB0b2tlbkF1dGhlbnRpY2F0b3IgYXMgdG9rZW5BdXRoZW50aWNhdG9yLCB1c2VybmFtZVBhc3N3b3JkQXV0aGVudGljYXRvciBhcyB1c2VybmFtZVBhc3N3b3JkQXV0aGVudGljYXRvciB9O1xuZnVuY3Rpb24gZGVmYXVsdE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWF4UGluZ091dDogMixcbiAgICAgICAgbWF4UmVjb25uZWN0QXR0ZW1wdHM6IDEwLFxuICAgICAgICBub1JhbmRvbWl6ZTogZmFsc2UsXG4gICAgICAgIHBlZGFudGljOiBmYWxzZSxcbiAgICAgICAgcGluZ0ludGVydmFsOiBERUZBVUxUX1BJTkdfSU5URVJWQUwsXG4gICAgICAgIHJlY29ubmVjdDogdHJ1ZSxcbiAgICAgICAgcmVjb25uZWN0Sml0dGVyOiAxMDAsXG4gICAgICAgIHJlY29ubmVjdEppdHRlclRMUzogMTAwMCxcbiAgICAgICAgcmVjb25uZWN0VGltZVdhaXQ6IERFRkFVTFRfUkVDT05ORUNUX1RJTUVfV0FJVCxcbiAgICAgICAgdGxzOiB1bmRlZmluZWQsXG4gICAgICAgIHZlcmJvc2U6IGZhbHNlLFxuICAgICAgICB3YWl0T25GaXJzdENvbm5lY3Q6IGZhbHNlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhvcHRzKSB7XG4gICAgY29uc3QgZGhwID0gYCR7REVGQVVMVF9IT1NUfToke2RlZmF1bHRQb3J0KCl9YDtcbiAgICBvcHRzID0gb3B0cyB8fCB7XG4gICAgICAgIHNlcnZlcnM6IFtcbiAgICAgICAgICAgIGRocFxuICAgICAgICBdXG4gICAgfTtcbiAgICBvcHRzLnNlcnZlcnMgPSBvcHRzLnNlcnZlcnMgfHwgW107XG4gICAgaWYgKHR5cGVvZiBvcHRzLnNlcnZlcnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgb3B0cy5zZXJ2ZXJzID0gW1xuICAgICAgICAgICAgb3B0cy5zZXJ2ZXJzXG4gICAgICAgIF07XG4gICAgfVxuICAgIGlmIChvcHRzLnNlcnZlcnMubGVuZ3RoID4gMCAmJiBvcHRzLnBvcnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IE5hdHNFcnJvcihcInBvcnQgYW5kIHNlcnZlcnMgb3B0aW9ucyBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlXCIsIEVycm9yQ29kZS5JbnZhbGlkT3B0aW9uKTtcbiAgICB9XG4gICAgaWYgKG9wdHMuc2VydmVycy5sZW5ndGggPT09IDAgJiYgb3B0cy5wb3J0KSB7XG4gICAgICAgIG9wdHMuc2VydmVycyA9IFtcbiAgICAgICAgICAgIGAke0RFRkFVTFRfSE9TVH06JHtvcHRzLnBvcnR9YFxuICAgICAgICBdO1xuICAgIH1cbiAgICBpZiAob3B0cy5zZXJ2ZXJzICYmIG9wdHMuc2VydmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgb3B0cy5zZXJ2ZXJzID0gW1xuICAgICAgICAgICAgZGhwXG4gICAgICAgIF07XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMgPSBleHRlbmQoZGVmYXVsdE9wdGlvbnMoKSwgb3B0cyk7XG4gICAgaWYgKG9wdHMudXNlciAmJiBvcHRzLnRva2VuKSB7XG4gICAgICAgIHRocm93IE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLkJhZEF1dGhlbnRpY2F0aW9uKTtcbiAgICB9XG4gICAgaWYgKG9wdHMuYXV0aGVudGljYXRvciAmJiAob3B0cy50b2tlbiB8fCBvcHRzLnVzZXIgfHwgb3B0cy5wYXNzKSkge1xuICAgICAgICB0aHJvdyBOYXRzRXJyb3IuZXJyb3JGb3JDb2RlKEVycm9yQ29kZS5CYWRBdXRoZW50aWNhdGlvbik7XG4gICAgfVxuICAgIG9wdGlvbnMuYXV0aGVudGljYXRvciA9IGJ1aWxkQXV0aGVudGljYXRvcihvcHRpb25zKTtcbiAgICBbXG4gICAgICAgIFwicmVjb25uZWN0RGVsYXlIYW5kbGVyXCIsXG4gICAgICAgIFwiYXV0aGVudGljYXRvclwiXG4gICAgXS5mb3JFYWNoKChuKT0+e1xuICAgICAgICBpZiAob3B0aW9uc1tuXSAmJiB0eXBlb2Ygb3B0aW9uc1tuXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTmF0c0Vycm9yKGAke259IG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbmAsIEVycm9yQ29kZS5Ob3RGdW5jdGlvbik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIW9wdGlvbnMucmVjb25uZWN0RGVsYXlIYW5kbGVyKSB7XG4gICAgICAgIG9wdGlvbnMucmVjb25uZWN0RGVsYXlIYW5kbGVyID0gKCk9PntcbiAgICAgICAgICAgIGxldCBleHRyYSA9IG9wdGlvbnMudGxzID8gb3B0aW9ucy5yZWNvbm5lY3RKaXR0ZXJUTFMgOiBvcHRpb25zLnJlY29ubmVjdEppdHRlcjtcbiAgICAgICAgICAgIGlmIChleHRyYSkge1xuICAgICAgICAgICAgICAgIGV4dHJhKys7XG4gICAgICAgICAgICAgICAgZXh0cmEgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBleHRyYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5yZWNvbm5lY3RUaW1lV2FpdCArIGV4dHJhO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5pbmJveFByZWZpeCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY3JlYXRlSW5ib3gob3B0aW9ucy5pbmJveFByZWZpeCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5hdHNFcnJvcihlcnIubWVzc2FnZSwgRXJyb3JDb2RlLkFwaUVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yZXNvbHZlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZ2V0UmVzb2x2ZUZuKCkgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5hdHNFcnJvcihgJ3Jlc29sdmUnIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBjbGllbnRgLCBFcnJvckNvZGUuSW52YWxpZE9wdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG52YXIgUHViSGVhZGVycztcbihmdW5jdGlvbihQdWJIZWFkZXJzKSB7XG4gICAgUHViSGVhZGVyc1tcIk1zZ0lkSGRyXCJdID0gXCJOYXRzLU1zZy1JZFwiO1xuICAgIFB1YkhlYWRlcnNbXCJFeHBlY3RlZFN0cmVhbUhkclwiXSA9IFwiTmF0cy1FeHBlY3RlZC1TdHJlYW1cIjtcbiAgICBQdWJIZWFkZXJzW1wiRXhwZWN0ZWRMYXN0U2VxSGRyXCJdID0gXCJOYXRzLUV4cGVjdGVkLUxhc3QtU2VxdWVuY2VcIjtcbiAgICBQdWJIZWFkZXJzW1wiRXhwZWN0ZWRMYXN0TXNnSWRIZHJcIl0gPSBcIk5hdHMtRXhwZWN0ZWQtTGFzdC1Nc2ctSWRcIjtcbiAgICBQdWJIZWFkZXJzW1wiRXhwZWN0ZWRMYXN0U3ViamVjdFNlcXVlbmNlSGRyXCJdID0gXCJOYXRzLUV4cGVjdGVkLUxhc3QtU3ViamVjdC1TZXF1ZW5jZVwiO1xufSkoUHViSGVhZGVycyB8fCAoUHViSGVhZGVycyA9IHt9KSk7XG5mdW5jdGlvbiBOb29wS3ZDb2RlY3MoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2V5OiB7XG4gICAgICAgICAgICBlbmNvZGUgKGspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWNvZGUgKGspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIGVuY29kZSAodikge1xuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlY29kZSAodikge1xuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRCdWNrZXRPcHRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlcGxpY2FzOiAxLFxuICAgICAgICBoaXN0b3J5OiAxLFxuICAgICAgICB0aW1lb3V0OiAyMDAwLFxuICAgICAgICBtYXhCdWNrZXRTaXplOiAtMSxcbiAgICAgICAgbWF4VmFsdWVTaXplOiAtMSxcbiAgICAgICAgY29kZWM6IE5vb3BLdkNvZGVjcygpLFxuICAgICAgICBzdG9yYWdlOiBTdG9yYWdlVHlwZS5GaWxlXG4gICAgfTtcbn1cbmNvbnN0IGt2T3BlcmF0aW9uSGRyID0gXCJLVi1PcGVyYXRpb25cIjtcbmNvbnN0IGt2UHJlZml4ID0gXCJLVl9cIjtcbmNvbnN0IGt2U3ViamVjdFByZWZpeCA9IFwiJEtWXCI7XG5jb25zdCB2YWxpZEtleVJlID0gL15bLS89Llxcd10rJC87XG5jb25zdCB2YWxpZFNlYXJjaEtleSA9IC9eWy0vPS4+Klxcd10rJC87XG5jb25zdCB2YWxpZEJ1Y2tldFJlID0gL15bLVxcd10rJC87XG5mdW5jdGlvbiB2YWxpZGF0ZUtleShrKSB7XG4gICAgaWYgKGsuc3RhcnRzV2l0aChcIi5cIikgfHwgay5lbmRzV2l0aChcIi5cIikgfHwgIXZhbGlkS2V5UmUudGVzdChrKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQga2V5OiAke2t9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVTZWFyY2hLZXkoaykge1xuICAgIGlmIChrLnN0YXJ0c1dpdGgoXCIuXCIpIHx8IGsuZW5kc1dpdGgoXCIuXCIpIHx8ICF2YWxpZFNlYXJjaEtleS50ZXN0KGspKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBrZXk6ICR7a31gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYXNXaWxkY2FyZHMoaykge1xuICAgIGlmIChrLnN0YXJ0c1dpdGgoXCIuXCIpIHx8IGsuZW5kc1dpdGgoXCIuXCIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBrZXk6ICR7a31gKTtcbiAgICB9XG4gICAgY29uc3QgY2h1bmtzID0gay5zcGxpdChcIi5cIik7XG4gICAgbGV0IGhhc1dpbGRjYXJkcyA9IGZhbHNlO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpKyspe1xuICAgICAgICBzd2l0Y2goY2h1bmtzW2ldKXtcbiAgICAgICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgICAgICAgICAgaGFzV2lsZGNhcmRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCI+XCI6XG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IGNodW5rcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBrZXk6ICR7a31gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGFzV2lsZGNhcmRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhhc1dpbGRjYXJkcztcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQnVja2V0KG5hbWUpIHtcbiAgICBpZiAoIXZhbGlkQnVja2V0UmUudGVzdChuYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgYnVja2V0IG5hbWU6ICR7bmFtZX1gKTtcbiAgICB9XG59XG5jbGFzcyBCdWNrZXQge1xuICAgIGpzbTtcbiAgICBqcztcbiAgICBzdHJlYW07XG4gICAgYnVja2V0O1xuICAgIGRpcmVjdDtcbiAgICBjb2RlYztcbiAgICBfcHJlZml4TGVuO1xuICAgIHN1YmpQcmVmaXg7XG4gICAgY29uc3RydWN0b3IoYnVja2V0LCBqc20sIGpzKXtcbiAgICAgICAgdmFsaWRhdGVCdWNrZXQoYnVja2V0KTtcbiAgICAgICAgdGhpcy5qc20gPSBqc207XG4gICAgICAgIHRoaXMuanMgPSBqcztcbiAgICAgICAgdGhpcy5idWNrZXQgPSBidWNrZXQ7XG4gICAgICAgIHRoaXMuX3ByZWZpeExlbiA9IDA7XG4gICAgICAgIHRoaXMuc3VialByZWZpeCA9IGt2U3ViamVjdFByZWZpeDtcbiAgICAgICAgY29uc3QganNpID0ganM7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IGpzaS5wcmVmaXggfHwgXCIkSlMuQVBJXCI7XG4gICAgICAgIGlmIChwcmVmaXggIT09IFwiJEpTLkFQSVwiKSB7XG4gICAgICAgICAgICB0aGlzLnN1YmpQcmVmaXggPSBgJHtwcmVmaXh9LiR7a3ZTdWJqZWN0UHJlZml4fWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGNyZWF0ZShqcywgbmFtZSwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHZhbGlkYXRlQnVja2V0KG5hbWUpO1xuICAgICAgICBjb25zdCB0byA9IG9wdHMudGltZW91dCB8fCAyMDAwO1xuICAgICAgICBjb25zdCBqc2kgPSBqcztcbiAgICAgICAgbGV0IGpzb3B0cyA9IGpzaS5vcHRzIHx8IHt9O1xuICAgICAgICBqc29wdHMgPSBPYmplY3QuYXNzaWduKGpzb3B0cywge1xuICAgICAgICAgICAgdGltZW91dDogdG9cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGpzbSA9IGF3YWl0IGpzaS5uYy5qZXRzdHJlYW1NYW5hZ2VyKGpzb3B0cyk7XG4gICAgICAgIGNvbnN0IGJ1Y2tldCA9IG5ldyBCdWNrZXQobmFtZSwganNtLCBqcyk7XG4gICAgICAgIGF3YWl0IGJ1Y2tldC5pbml0KG9wdHMpO1xuICAgICAgICByZXR1cm4gYnVja2V0O1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgYmluZChqcywgbmFtZSwgb3B0cyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGpzaSA9IGpzO1xuICAgICAgICBjb25zdCBqc20gPSBhd2FpdCBqc2kubmMuamV0c3RyZWFtTWFuYWdlcigpO1xuICAgICAgICBjb25zdCBpbmZvID0gYXdhaXQganNtLnN0cmVhbXMuaW5mbyhgJHtrdlByZWZpeH0ke25hbWV9YCk7XG4gICAgICAgIHZhbGlkYXRlQnVja2V0KGluZm8uY29uZmlnLm5hbWUpO1xuICAgICAgICBjb25zdCBidWNrZXQgPSBuZXcgQnVja2V0KG5hbWUsIGpzbSwganMpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGJ1Y2tldCwgaW5mbyk7XG4gICAgICAgIGJ1Y2tldC5jb2RlYyA9IG9wdHMuY29kZWMgfHwgTm9vcEt2Q29kZWNzKCk7XG4gICAgICAgIGJ1Y2tldC5kaXJlY3QgPSBpbmZvLmNvbmZpZy5hbGxvd19kaXJlY3QgPz8gZmFsc2U7XG4gICAgICAgIHJldHVybiBidWNrZXQ7XG4gICAgfVxuICAgIGFzeW5jIGluaXQob3B0cyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGJvID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0QnVja2V0T3B0cygpLCBvcHRzKTtcbiAgICAgICAgdGhpcy5jb2RlYyA9IGJvLmNvZGVjO1xuICAgICAgICBjb25zdCBzYyA9IHt9O1xuICAgICAgICB0aGlzLnN0cmVhbSA9IHNjLm5hbWUgPSBvcHRzLnN0cmVhbU5hbWUgPz8gdGhpcy5idWNrZXROYW1lKCk7XG4gICAgICAgIHNjLnN1YmplY3RzID0gW1xuICAgICAgICAgICAgdGhpcy5zdWJqZWN0Rm9yQnVja2V0KClcbiAgICAgICAgXTtcbiAgICAgICAgc2MucmV0ZW50aW9uID0gUmV0ZW50aW9uUG9saWN5LkxpbWl0cztcbiAgICAgICAgc2MubWF4X21zZ3NfcGVyX3N1YmplY3QgPSBiby5oaXN0b3J5O1xuICAgICAgICBpZiAoYm8ubWF4QnVja2V0U2l6ZSkge1xuICAgICAgICAgICAgYm8ubWF4X2J5dGVzID0gYm8ubWF4QnVja2V0U2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYm8ubWF4X2J5dGVzKSB7XG4gICAgICAgICAgICBzYy5tYXhfYnl0ZXMgPSBiby5tYXhfYnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgc2MubWF4X21zZ19zaXplID0gYm8ubWF4VmFsdWVTaXplO1xuICAgICAgICBzYy5zdG9yYWdlID0gYm8uc3RvcmFnZTtcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSBvcHRzLnBsYWNlbWVudENsdXN0ZXIgPz8gXCJcIjtcbiAgICAgICAgaWYgKGxvY2F0aW9uKSB7XG4gICAgICAgICAgICBvcHRzLnBsYWNlbWVudCA9IHt9O1xuICAgICAgICAgICAgb3B0cy5wbGFjZW1lbnQuY2x1c3RlciA9IGxvY2F0aW9uO1xuICAgICAgICAgICAgb3B0cy5wbGFjZW1lbnQudGFncyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLnBsYWNlbWVudCkge1xuICAgICAgICAgICAgc2MucGxhY2VtZW50ID0gb3B0cy5wbGFjZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMucmVwdWJsaXNoKSB7XG4gICAgICAgICAgICBzYy5yZXB1Ymxpc2ggPSBvcHRzLnJlcHVibGlzaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgc2MuZGVzY3JpcHRpb24gPSBvcHRzLmRlc2NyaXB0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5jaSA9IHRoaXMuanMubmM7XG4gICAgICAgIGNvbnN0IGhhdmUgPSBuY2kuZ2V0U2VydmVyVmVyc2lvbigpO1xuICAgICAgICBjb25zdCBkaXNjYXJkTmV3ID0gaGF2ZSA/IGNvbXBhcmUoaGF2ZSwgcGFyc2VTZW1WZXIoXCIyLjcuMlwiKSkgPj0gMCA6IGZhbHNlO1xuICAgICAgICBzYy5kaXNjYXJkID0gZGlzY2FyZE5ldyA/IERpc2NhcmRQb2xpY3kuTmV3IDogRGlzY2FyZFBvbGljeS5PbGQ7XG4gICAgICAgIGNvbnN0IGRpcmVjdCA9IGhhdmUgPyBjb21wYXJlKGhhdmUsIHBhcnNlU2VtVmVyKFwiMi44LjVcIikpID49IDAgOiBmYWxzZTtcbiAgICAgICAgc2MuYWxsb3dfZGlyZWN0ID0gb3B0cy5hbGxvd19kaXJlY3QgPyBkaXJlY3QgOiBmYWxzZTtcbiAgICAgICAgdGhpcy5kaXJlY3QgPSBzYy5hbGxvd19kaXJlY3Q7XG4gICAgICAgIHNjLm51bV9yZXBsaWNhcyA9IGJvLnJlcGxpY2FzO1xuICAgICAgICBpZiAoYm8udHRsKSB7XG4gICAgICAgICAgICBzYy5tYXhfYWdlID0gbmFub3MoYm8udHRsKTtcbiAgICAgICAgfVxuICAgICAgICBzYy5hbGxvd19yb2xsdXBfaGRycyA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmpzbS5zdHJlYW1zLmluZm8oc2MubmFtZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyci5tZXNzYWdlID09PSBcInN0cmVhbSBub3QgZm91bmRcIikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuanNtLnN0cmVhbXMuYWRkKHNjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBidWNrZXROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW0gPz8gYCR7a3ZQcmVmaXh9JHt0aGlzLmJ1Y2tldH1gO1xuICAgIH1cbiAgICBzdWJqZWN0Rm9yQnVja2V0KCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5zdWJqUHJlZml4fS4ke3RoaXMuYnVja2V0fS4+YDtcbiAgICB9XG4gICAgc3ViamVjdEZvcktleShrKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLnN1YmpQcmVmaXh9LiR7dGhpcy5idWNrZXR9LiR7a31gO1xuICAgIH1cbiAgICBmdWxsS2V5TmFtZShrKSB7XG4gICAgICAgIHJldHVybiBgJHtrdlN1YmplY3RQcmVmaXh9LiR7dGhpcy5idWNrZXR9LiR7a31gO1xuICAgIH1cbiAgICBnZXQgcHJlZml4TGVuKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJlZml4TGVuID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9wcmVmaXhMZW4gPSBgJHtrdlN1YmplY3RQcmVmaXh9LiR7dGhpcy5idWNrZXR9LmAubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcmVmaXhMZW47XG4gICAgfVxuICAgIGVuY29kZUtleShrZXkpIHtcbiAgICAgICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgdCBvZiBrZXkuc3BsaXQoXCIuXCIpKXtcbiAgICAgICAgICAgIHN3aXRjaCh0KXtcbiAgICAgICAgICAgICAgICBjYXNlIFwiPlwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBjaHVua3MucHVzaCh0aGlzLmNvZGVjLmtleS5lbmNvZGUodCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2h1bmtzLmpvaW4oXCIuXCIpO1xuICAgIH1cbiAgICBkZWNvZGVLZXkoZWtleSkge1xuICAgICAgICBjb25zdCBjaHVua3MgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB0IG9mIGVrZXkuc3BsaXQoXCIuXCIpKXtcbiAgICAgICAgICAgIHN3aXRjaCh0KXtcbiAgICAgICAgICAgICAgICBjYXNlIFwiPlwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBjaHVua3MucHVzaCh0aGlzLmNvZGVjLmtleS5kZWNvZGUodCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2h1bmtzLmpvaW4oXCIuXCIpO1xuICAgIH1cbiAgICB2YWxpZGF0ZUtleSA9IHZhbGlkYXRlS2V5O1xuICAgIHZhbGlkYXRlU2VhcmNoS2V5ID0gdmFsaWRhdGVTZWFyY2hLZXk7XG4gICAgaGFzV2lsZGNhcmRzID0gaGFzV2lsZGNhcmRzO1xuICAgIGNsb3NlKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGRhdGFMZW4oZGF0YSwgaCkge1xuICAgICAgICBjb25zdCBzbGVuID0gaCA/IGguZ2V0KEpzSGVhZGVycy5NZXNzYWdlU2l6ZUhkcikgfHwgXCJcIiA6IFwiXCI7XG4gICAgICAgIGlmIChzbGVuICE9PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoc2xlbiwgMTApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhLmxlbmd0aDtcbiAgICB9XG4gICAgc21Ub0VudHJ5KHNtKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBidWNrZXQ6IHRoaXMuYnVja2V0LFxuICAgICAgICAgICAga2V5OiBzbS5zdWJqZWN0LnN1YnN0cmluZyh0aGlzLnByZWZpeExlbiksXG4gICAgICAgICAgICB2YWx1ZTogc20uZGF0YSxcbiAgICAgICAgICAgIGRlbHRhOiAwLFxuICAgICAgICAgICAgY3JlYXRlZDogc20udGltZSxcbiAgICAgICAgICAgIHJldmlzaW9uOiBzbS5zZXEsXG4gICAgICAgICAgICBvcGVyYXRpb246IHNtLmhlYWRlci5nZXQoa3ZPcGVyYXRpb25IZHIpIHx8IFwiUFVUXCIsXG4gICAgICAgICAgICBsZW5ndGg6IHRoaXMuZGF0YUxlbihzbS5kYXRhLCBzbS5oZWFkZXIpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGptVG9FbnRyeShqbSkge1xuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmRlY29kZUtleShqbS5zdWJqZWN0LnN1YnN0cmluZyh0aGlzLnByZWZpeExlbikpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYnVja2V0OiB0aGlzLmJ1Y2tldCxcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgdmFsdWU6IGptLmRhdGEsXG4gICAgICAgICAgICBjcmVhdGVkOiBuZXcgRGF0ZShtaWxsaXMoam0uaW5mby50aW1lc3RhbXBOYW5vcykpLFxuICAgICAgICAgICAgcmV2aXNpb246IGptLnNlcSxcbiAgICAgICAgICAgIG9wZXJhdGlvbjogam0uaGVhZGVycz8uZ2V0KGt2T3BlcmF0aW9uSGRyKSB8fCBcIlBVVFwiLFxuICAgICAgICAgICAgZGVsdGE6IGptLmluZm8ucGVuZGluZyxcbiAgICAgICAgICAgIGxlbmd0aDogdGhpcy5kYXRhTGVuKGptLmRhdGEsIGptLmhlYWRlcnMpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNyZWF0ZShrLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1dChrLCBkYXRhLCB7XG4gICAgICAgICAgICBwcmV2aW91c1NlcTogMFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlKGssIGRhdGEsIHZlcnNpb24pIHtcbiAgICAgICAgaWYgKHZlcnNpb24gPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidmVyc2lvbiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnB1dChrLCBkYXRhLCB7XG4gICAgICAgICAgICBwcmV2aW91c1NlcTogdmVyc2lvblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgcHV0KGssIGRhdGEsIG9wdHMgPSB7fSkge1xuICAgICAgICBjb25zdCBlayA9IHRoaXMuZW5jb2RlS2V5KGspO1xuICAgICAgICB0aGlzLnZhbGlkYXRlS2V5KGVrKTtcbiAgICAgICAgY29uc3QgbyA9IHt9O1xuICAgICAgICBpZiAob3B0cy5wcmV2aW91c1NlcSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBoID0gaGVhZGVycygpO1xuICAgICAgICAgICAgby5oZWFkZXJzID0gaDtcbiAgICAgICAgICAgIGguc2V0KFwiTmF0cy1FeHBlY3RlZC1MYXN0LVN1YmplY3QtU2VxdWVuY2VcIiwgYCR7b3B0cy5wcmV2aW91c1NlcX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYSA9IGF3YWl0IHRoaXMuanMucHVibGlzaCh0aGlzLnN1YmplY3RGb3JLZXkoZWspLCBkYXRhLCBvKTtcbiAgICAgICAgcmV0dXJuIHBhLnNlcTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0KGssIG9wdHMpIHtcbiAgICAgICAgY29uc3QgZWsgPSB0aGlzLmVuY29kZUtleShrKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZUtleShlayk7XG4gICAgICAgIGxldCBhcmcgPSB7XG4gICAgICAgICAgICBsYXN0X2J5X3N1Ymo6IHRoaXMuZnVsbEtleU5hbWUoZWspXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRzICYmIG9wdHMucmV2aXNpb24gPiAwKSB7XG4gICAgICAgICAgICBhcmcgPSB7XG4gICAgICAgICAgICAgICAgc2VxOiBvcHRzLnJldmlzaW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBzbTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpcmVjdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGpzbWkgPSB0aGlzLmpzbTtcbiAgICAgICAgICAgICAgICBzbSA9IGF3YWl0IGpzbWkuZGlyZWN0LmdldE1lc3NhZ2UodGhpcy5idWNrZXROYW1lKCksIGFyZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNtID0gYXdhaXQgdGhpcy5qc20uc3RyZWFtcy5nZXRNZXNzYWdlKHRoaXMuYnVja2V0TmFtZSgpLCBhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qga2UgPSB0aGlzLnNtVG9FbnRyeShzbSk7XG4gICAgICAgICAgICBpZiAoa2Uua2V5ICE9PSBlaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGtlO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gRXJyb3JDb2RlLkpldFN0cmVhbTQwNE5vTWVzc2FnZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwdXJnZShrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWxldGVPclB1cmdlKGssIFwiUFVSR0VcIik7XG4gICAgfVxuICAgIGRlbGV0ZShrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWxldGVPclB1cmdlKGssIFwiREVMXCIpO1xuICAgIH1cbiAgICBhc3luYyBwdXJnZURlbGV0ZXMob2xkZXJNaWxsaXMgPSAzMCAqIDYwICogMTAwMCkge1xuICAgICAgICBjb25zdCBkb25lID0gZGVmZXJyZWQoKTtcbiAgICAgICAgY29uc3QgYnVmID0gW107XG4gICAgICAgIGNvbnN0IGkgPSBhd2FpdCB0aGlzLndhdGNoKHtcbiAgICAgICAgICAgIGtleTogXCI+XCIsXG4gICAgICAgICAgICBpbml0aWFsaXplZEZuOiAoKT0+e1xuICAgICAgICAgICAgICAgIGRvbmUucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgKGFzeW5jICgpPT57XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGUgb2YgaSl7XG4gICAgICAgICAgICAgICAgaWYgKGUub3BlcmF0aW9uID09PSBcIkRFTFwiIHx8IGUub3BlcmF0aW9uID09PSBcIlBVUkdFXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpLnRoZW4oKTtcbiAgICAgICAgYXdhaXQgZG9uZTtcbiAgICAgICAgaS5zdG9wKCk7XG4gICAgICAgIGNvbnN0IG1pbiA9IERhdGUubm93KCkgLSBvbGRlck1pbGxpcztcbiAgICAgICAgY29uc3QgcHJvbXMgPSBidWYubWFwKChlKT0+e1xuICAgICAgICAgICAgY29uc3Qgc3ViaiA9IHRoaXMuc3ViamVjdEZvcktleShlLmtleSk7XG4gICAgICAgICAgICBpZiAoZS5jcmVhdGVkLmdldFRpbWUoKSA+PSBtaW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5qc20uc3RyZWFtcy5wdXJnZSh0aGlzLnN0cmVhbSwge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IHN1YmosXG4gICAgICAgICAgICAgICAgICAgIGtlZXA6IDFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuanNtLnN0cmVhbXMucHVyZ2UodGhpcy5zdHJlYW0sIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiBzdWJqLFxuICAgICAgICAgICAgICAgICAgICBrZWVwOiAwXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwdXJnZWQgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9tcyk7XG4gICAgICAgIHB1cmdlZC51bnNoaWZ0KHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICBwdXJnZWQ6IDBcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwdXJnZWQucmVkdWNlKChwdiwgY3YpPT57XG4gICAgICAgICAgICBwdi5wdXJnZWQgKz0gY3YucHVyZ2VkO1xuICAgICAgICAgICAgcmV0dXJuIHB2O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX2RlbGV0ZU9yUHVyZ2Uoaywgb3ApIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1dpbGRjYXJkcyhrKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RvRGVsZXRlT3JQdXJnZShrLCBvcCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlciA9IGF3YWl0IHRoaXMua2V5cyhrKTtcbiAgICAgICAgY29uc3QgYnVmID0gW107XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgazEgb2YgaXRlcil7XG4gICAgICAgICAgICBidWYucHVzaCh0aGlzLl9kb0RlbGV0ZU9yUHVyZ2UoazEsIG9wKSk7XG4gICAgICAgICAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMTAwKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoYnVmKTtcbiAgICAgICAgICAgICAgICBidWYubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVmLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGJ1Zik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2RvRGVsZXRlT3JQdXJnZShrLCBvcCkge1xuICAgICAgICBjb25zdCBlayA9IHRoaXMuZW5jb2RlS2V5KGspO1xuICAgICAgICB0aGlzLnZhbGlkYXRlS2V5KGVrKTtcbiAgICAgICAgY29uc3QgaCA9IGhlYWRlcnMoKTtcbiAgICAgICAgaC5zZXQoa3ZPcGVyYXRpb25IZHIsIG9wKTtcbiAgICAgICAgaWYgKG9wID09PSBcIlBVUkdFXCIpIHtcbiAgICAgICAgICAgIGguc2V0KEpzSGVhZGVycy5Sb2xsdXBIZHIsIEpzSGVhZGVycy5Sb2xsdXBWYWx1ZVN1YmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuanMucHVibGlzaCh0aGlzLnN1YmplY3RGb3JLZXkoZWspLCBFbXB0eSwge1xuICAgICAgICAgICAgaGVhZGVyczogaFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2J1aWxkQ0MoaywgaGlzdG9yeSA9IGZhbHNlLCBvcHRzID0ge30pIHtcbiAgICAgICAgY29uc3QgZWsgPSB0aGlzLmVuY29kZUtleShrKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZVNlYXJjaEtleShrKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgXCJkZWxpdmVyX3BvbGljeVwiOiBoaXN0b3J5ID8gRGVsaXZlclBvbGljeS5BbGwgOiBEZWxpdmVyUG9saWN5Lkxhc3RQZXJTdWJqZWN0LFxuICAgICAgICAgICAgXCJhY2tfcG9saWN5XCI6IEFja1BvbGljeS5Ob25lLFxuICAgICAgICAgICAgXCJmaWx0ZXJfc3ViamVjdFwiOiB0aGlzLmZ1bGxLZXlOYW1lKGVrKSxcbiAgICAgICAgICAgIFwiZmxvd19jb250cm9sXCI6IHRydWUsXG4gICAgICAgICAgICBcImlkbGVfaGVhcnRiZWF0XCI6IG5hbm9zKDUgKiAxMDAwKVxuICAgICAgICB9LCBvcHRzKTtcbiAgICB9XG4gICAgcmVtb3ZlKGspIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVyZ2Uoayk7XG4gICAgfVxuICAgIGFzeW5jIGhpc3Rvcnkob3B0cyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGsgPSBvcHRzLmtleSA/PyBcIj5cIjtcbiAgICAgICAgY29uc3QgcWkgPSBuZXcgUXVldWVkSXRlcmF0b3JJbXBsKCk7XG4gICAgICAgIGNvbnN0IGNvID0ge307XG4gICAgICAgIGNvLmhlYWRlcnNfb25seSA9IG9wdHMuaGVhZGVyc19vbmx5IHx8IGZhbHNlO1xuICAgICAgICBsZXQgZm47XG4gICAgICAgIGZuID0gKCk9PntcbiAgICAgICAgICAgIHFpLnN0b3AoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgY29uc3QgY2MgPSB0aGlzLl9idWlsZENDKGssIHRydWUsIGNvKTtcbiAgICAgICAgY29uc3Qgc3ViaiA9IGNjLmZpbHRlcl9zdWJqZWN0O1xuICAgICAgICBjb25zdCBjb3B0cyA9IGNvbnN1bWVyT3B0cyhjYyk7XG4gICAgICAgIGNvcHRzLm9yZGVyZWRDb25zdW1lcigpO1xuICAgICAgICBjb3B0cy5jYWxsYmFjaygoZXJyLCBqbSk9PntcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBxaS5zdG9wKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGptKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IHRoaXMuam1Ub0VudHJ5KGptKTtcbiAgICAgICAgICAgICAgICBxaS5wdXNoKGUpO1xuICAgICAgICAgICAgICAgIHFpLnJlY2VpdmVkKys7XG4gICAgICAgICAgICAgICAgaWYgKGZuICYmIGNvdW50ID4gMCAmJiBxaS5yZWNlaXZlZCA+PSBjb3VudCB8fCBqbS5pbmZvLnBlbmRpbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcWkucHVzaChmbik7XG4gICAgICAgICAgICAgICAgICAgIGZuID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuanMuc3Vic2NyaWJlKHN1YmosIGNvcHRzKTtcbiAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICBjb25zdCB7IGluZm86IHsgbGFzdCAgfSAgfSA9IHN1YjtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdCA9IGxhc3QubnVtX3BlbmRpbmcgKyBsYXN0LmRlbGl2ZXJlZC5jb25zdW1lcl9zZXE7XG4gICAgICAgICAgICBpZiAoZXhwZWN0ID09PSAwIHx8IHFpLnJlY2VpdmVkID49IGV4cGVjdCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHFpLnN0b3AoZXJyKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICAgICAgICAgIGZuID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY291bnQgPSBleHBlY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcWkuX2RhdGEgPSBzdWI7XG4gICAgICAgIHFpLml0ZXJDbG9zZWQudGhlbigoKT0+e1xuICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdWIuY2xvc2VkLnRoZW4oKCk9PntcbiAgICAgICAgICAgIHFpLnN0b3AoKTtcbiAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgIHFpLnN0b3AoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBxaTtcbiAgICB9XG4gICAgYXN5bmMgd2F0Y2gob3B0cyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGsgPSBvcHRzLmtleSA/PyBcIj5cIjtcbiAgICAgICAgY29uc3QgcWkgPSBuZXcgUXVldWVkSXRlcmF0b3JJbXBsKCk7XG4gICAgICAgIGNvbnN0IGNvID0ge307XG4gICAgICAgIGNvLmhlYWRlcnNfb25seSA9IG9wdHMuaGVhZGVyc19vbmx5IHx8IGZhbHNlO1xuICAgICAgICBsZXQgZm4gPSBvcHRzLmluaXRpYWxpemVkRm47XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGNvbnN0IGNjID0gdGhpcy5fYnVpbGRDQyhrLCBmYWxzZSwgY28pO1xuICAgICAgICBjb25zdCBzdWJqID0gY2MuZmlsdGVyX3N1YmplY3Q7XG4gICAgICAgIGNvbnN0IGNvcHRzID0gY29uc3VtZXJPcHRzKGNjKTtcbiAgICAgICAgY29wdHMub3JkZXJlZENvbnN1bWVyKCk7XG4gICAgICAgIGNvcHRzLmNhbGxiYWNrKChlcnIsIGptKT0+e1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHFpLnN0b3AoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoam0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gdGhpcy5qbVRvRW50cnkoam0pO1xuICAgICAgICAgICAgICAgIHFpLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgcWkucmVjZWl2ZWQrKztcbiAgICAgICAgICAgICAgICBpZiAoZm4gJiYgKGNvdW50ID4gMCAmJiBxaS5yZWNlaXZlZCA+PSBjb3VudCB8fCBqbS5pbmZvLnBlbmRpbmcgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIHFpLnB1c2goZm4pO1xuICAgICAgICAgICAgICAgICAgICBmbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLmpzLnN1YnNjcmliZShzdWJqLCBjb3B0cyk7XG4gICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgY29uc3QgeyBpbmZvOiB7IGxhc3QgIH0gIH0gPSBzdWI7XG4gICAgICAgICAgICBjb25zdCBleHBlY3QgPSBsYXN0Lm51bV9wZW5kaW5nICsgbGFzdC5kZWxpdmVyZWQuY29uc3VtZXJfc2VxO1xuICAgICAgICAgICAgaWYgKGV4cGVjdCA9PT0gMCB8fCBxaS5yZWNlaXZlZCA+PSBleHBlY3QpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBxaS5zdG9wKGVycik7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgICAgICAgICBmbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvdW50ID0gZXhwZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHFpLl9kYXRhID0gc3ViO1xuICAgICAgICBxaS5pdGVyQ2xvc2VkLnRoZW4oKCk9PntcbiAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgc3ViLmNsb3NlZC50aGVuKCgpPT57XG4gICAgICAgICAgICBxaS5zdG9wKCk7XG4gICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICBxaS5zdG9wKGVycik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcWk7XG4gICAgfVxuICAgIGFzeW5jIGtleXMoayA9IFwiPlwiKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBuZXcgUXVldWVkSXRlcmF0b3JJbXBsKCk7XG4gICAgICAgIGNvbnN0IGNjID0gdGhpcy5fYnVpbGRDQyhrLCBmYWxzZSwge1xuICAgICAgICAgICAgaGVhZGVyc19vbmx5OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzdWJqID0gY2MuZmlsdGVyX3N1YmplY3Q7XG4gICAgICAgIGNvbnN0IGNvcHRzID0gY29uc3VtZXJPcHRzKGNjKTtcbiAgICAgICAgY29wdHMub3JkZXJlZENvbnN1bWVyKCk7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuanMuc3Vic2NyaWJlKHN1YmosIGNvcHRzKTtcbiAgICAgICAgKGFzeW5jICgpPT57XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGptIG9mIHN1Yil7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3AgPSBqbS5oZWFkZXJzPy5nZXQoa3ZPcGVyYXRpb25IZHIpO1xuICAgICAgICAgICAgICAgIGlmIChvcCAhPT0gXCJERUxcIiAmJiBvcCAhPT0gXCJQVVJHRVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZGVjb2RlS2V5KGptLnN1YmplY3Quc3Vic3RyaW5nKHRoaXMucHJlZml4TGVuKSk7XG4gICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoam0uaW5mby5wZW5kaW5nID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKS50aGVuKCgpPT57XG4gICAgICAgICAgICBrZXlzLnN0b3AoKTtcbiAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgIGtleXMuc3RvcChlcnIpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc2kgPSBzdWI7XG4gICAgICAgIGlmIChzaS5pbmZvLmxhc3QubnVtX3BlbmRpbmcgPT09IDApIHtcbiAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH1cbiAgICBwdXJnZUJ1Y2tldChvcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmpzbS5zdHJlYW1zLnB1cmdlKHRoaXMuYnVja2V0TmFtZSgpLCBvcHRzKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuanNtLnN0cmVhbXMuZGVsZXRlKHRoaXMuYnVja2V0TmFtZSgpKTtcbiAgICB9XG4gICAgYXN5bmMgc3RhdHVzKCkge1xuICAgICAgICBjb25zdCBqaSA9IHRoaXMuanM7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXIgPSBqaS5uYy5pbmZvPy5jbHVzdGVyID8/IFwiXCI7XG4gICAgICAgIGNvbnN0IHNpID0gYXdhaXQgdGhpcy5qc20uc3RyZWFtcy5pbmZvKHRoaXMuYnVja2V0TmFtZSgpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJ1Y2tldDogdGhpcy5idWNrZXROYW1lKCksXG4gICAgICAgICAgICB2YWx1ZXM6IHNpLnN0YXRlLm1lc3NhZ2VzLFxuICAgICAgICAgICAgaGlzdG9yeTogc2kuY29uZmlnLm1heF9tc2dzX3Blcl9zdWJqZWN0LFxuICAgICAgICAgICAgdHRsOiBtaWxsaXMoc2kuY29uZmlnLm1heF9hZ2UpLFxuICAgICAgICAgICAgYnVja2V0X2xvY2F0aW9uOiBjbHVzdGVyLFxuICAgICAgICAgICAgYmFja2luZ1N0b3JlOiBzaS5jb25maWcuc3RvcmFnZSxcbiAgICAgICAgICAgIHN0b3JhZ2U6IHNpLmNvbmZpZy5zdG9yYWdlLFxuICAgICAgICAgICAgcmVwbGljYXM6IHNpLmNvbmZpZy5udW1fcmVwbGljYXNcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBvYmplY3RTdG9yZVN0cmVhbU5hbWUoYnVja2V0KSB7XG4gICAgdmFsaWRhdGVCdWNrZXQoYnVja2V0KTtcbiAgICByZXR1cm4gYE9CSl8ke2J1Y2tldH1gO1xufVxuZnVuY3Rpb24gb2JqZWN0U3RvcmVCdWNrZXROYW1lKHN0cmVhbSkge1xuICAgIGlmIChzdHJlYW0uc3RhcnRzV2l0aChcIk9CSl9cIikpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5zdWJzdHJpbmcoNCk7XG4gICAgfVxuICAgIHJldHVybiBzdHJlYW07XG59XG5jbGFzcyBPYmplY3RTdG9yZUluZm9JbXBsIHtcbiAgICBzaTtcbiAgICBiYWNraW5nU3RvcmU7XG4gICAgY29uc3RydWN0b3Ioc2kpe1xuICAgICAgICB0aGlzLnNpID0gc2k7XG4gICAgICAgIHRoaXMuYmFja2luZ1N0b3JlID0gXCJKZXRTdHJlYW1cIjtcbiAgICB9XG4gICAgZ2V0IGJ1Y2tldCgpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdFN0b3JlQnVja2V0TmFtZSh0aGlzLnNpLmNvbmZpZy5uYW1lKTtcbiAgICB9XG4gICAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaS5jb25maWcuZGVzY3JpcHRpb24gPz8gXCJcIjtcbiAgICB9XG4gICAgZ2V0IHR0bCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2kuY29uZmlnLm1heF9hZ2U7XG4gICAgfVxuICAgIGdldCBzdG9yYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaS5jb25maWcuc3RvcmFnZTtcbiAgICB9XG4gICAgZ2V0IHJlcGxpY2FzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaS5jb25maWcubnVtX3JlcGxpY2FzO1xuICAgIH1cbiAgICBnZXQgc2VhbGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaS5jb25maWcuc2VhbGVkO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2kuc3RhdGUuYnl0ZXM7XG4gICAgfVxuICAgIGdldCBzdHJlYW1JbmZvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaTtcbiAgICB9XG59XG5jbGFzcyBPYmplY3RJbmZvSW1wbCB7XG4gICAgaW5mbztcbiAgICBoZHJzO1xuICAgIGNvbnN0cnVjdG9yKG9pKXtcbiAgICAgICAgdGhpcy5pbmZvID0gb2k7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmZvLm5hbWU7XG4gICAgfVxuICAgIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5mby5kZXNjcmlwdGlvbiA/PyBcIlwiO1xuICAgIH1cbiAgICBnZXQgaGVhZGVycygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhkcnMpIHtcbiAgICAgICAgICAgIHRoaXMuaGRycyA9IE1zZ0hkcnNJbXBsLmZyb21SZWNvcmQodGhpcy5pbmZvLmhlYWRlcnMgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmhkcnM7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmZvLm9wdGlvbnM7XG4gICAgfVxuICAgIGdldCBidWNrZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZm8uYnVja2V0O1xuICAgIH1cbiAgICBnZXQgY2h1bmtzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmZvLmNodW5rcztcbiAgICB9XG4gICAgZ2V0IGRlbGV0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZm8uZGVsZXRlZCA/PyBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IGRpZ2VzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5mby5kaWdlc3Q7XG4gICAgfVxuICAgIGdldCBtdGltZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5mby5tdGltZTtcbiAgICB9XG4gICAgZ2V0IG51aWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZm8ubnVpZDtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZm8uc2l6ZTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b1NlcnZlck9iamVjdFN0b3JlTWV0YShtZXRhKSB7XG4gICAgY29uc3QgdiA9IHtcbiAgICAgICAgbmFtZTogbWV0YS5uYW1lLFxuICAgICAgICBkZXNjcmlwdGlvbjogbWV0YS5kZXNjcmlwdGlvbiA/PyBcIlwiLFxuICAgICAgICBvcHRpb25zOiBtZXRhLm9wdGlvbnNcbiAgICB9O1xuICAgIGlmIChtZXRhLmhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgbWhpID0gbWV0YS5oZWFkZXJzO1xuICAgICAgICB2LmhlYWRlcnMgPSBtaGkudG9SZWNvcmQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59XG5mdW5jdGlvbiBtZXRhKG9pKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogb2kubmFtZSxcbiAgICAgICAgZGVzY3JpcHRpb246IG9pLmRlc2NyaXB0aW9uLFxuICAgICAgICBoZWFkZXJzOiBvaS5oZWFkZXJzLFxuICAgICAgICBvcHRpb25zOiBvaS5vcHRpb25zXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGVtcHR5UmVhZGFibGVTdHJlYW0oKSB7XG4gICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIHB1bGwgKGMpIHtcbiAgICAgICAgICAgIGMuZW5xdWV1ZShuZXcgVWludDhBcnJheSgwKSk7XG4gICAgICAgICAgICBjLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmNsYXNzIE9iamVjdFN0b3JlSW1wbCB7XG4gICAganNtO1xuICAgIGpzO1xuICAgIHN0cmVhbTtcbiAgICBuYW1lO1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGpzbSwganMpe1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmpzbSA9IGpzbTtcbiAgICAgICAgdGhpcy5qcyA9IGpzO1xuICAgIH1cbiAgICBfc2FuaXRpemVOYW1lKG5hbWUpIHtcbiAgICAgICAgaWYgKCFuYW1lIHx8IG5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihcIm5hbWUgY2Fubm90IGJlIGVtcHR5XCIpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoL1tcXC4gXS9nLCBcIl9cIik7XG4gICAgICAgIGxldCBlcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbGlkYXRlS2V5KG5hbWUpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgaW5mbyhuYW1lKSB7XG4gICAgICAgIGNvbnN0IGluZm8gPSBhd2FpdCB0aGlzLnJhd0luZm8obmFtZSk7XG4gICAgICAgIHJldHVybiBpbmZvID8gbmV3IE9iamVjdEluZm9JbXBsKGluZm8pIDogbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgbGlzdCgpIHtcbiAgICAgICAgY29uc3QgYnVmID0gW107XG4gICAgICAgIGNvbnN0IGl0ZXIgPSBhd2FpdCB0aGlzLndhdGNoKHtcbiAgICAgICAgICAgIGlnbm9yZURlbGV0ZXM6IHRydWUsXG4gICAgICAgICAgICBpbmNsdWRlSGlzdG9yeTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBpbmZvIG9mIGl0ZXIpe1xuICAgICAgICAgICAgaWYgKGluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1Zi5wdXNoKGluZm8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYnVmKTtcbiAgICB9XG4gICAgYXN5bmMgcmF3SW5mbyhuYW1lKSB7XG4gICAgICAgIGNvbnN0IHsgbmFtZTogb2JqICwgZXJyb3IgIH0gPSB0aGlzLl9zYW5pdGl6ZU5hbWUobmFtZSk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0gYCRPLiR7dGhpcy5uYW1lfS5NLiR7b2JqfWA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBtID0gYXdhaXQgdGhpcy5qc20uc3RyZWFtcy5nZXRNZXNzYWdlKHRoaXMuc3RyZWFtLCB7XG4gICAgICAgICAgICAgICAgbGFzdF9ieV9zdWJqOiBtZXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGpjID0gSlNPTkNvZGVjKCk7XG4gICAgICAgICAgICBjb25zdCBpbmZvID0gamMuZGVjb2RlKG0uZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09IFwiNDA0XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNlYWwoKSB7XG4gICAgICAgIGxldCBpbmZvID0gYXdhaXQgdGhpcy5qc20uc3RyZWFtcy5pbmZvKHRoaXMuc3RyZWFtKTtcbiAgICAgICAgaWYgKGluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJvYmplY3Qgc3RvcmUgbm90IGZvdW5kXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpbmZvLmNvbmZpZy5zZWFsZWQgPSB0cnVlO1xuICAgICAgICBpbmZvID0gYXdhaXQgdGhpcy5qc20uc3RyZWFtcy51cGRhdGUodGhpcy5zdHJlYW0sIGluZm8uY29uZmlnKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgT2JqZWN0U3RvcmVJbmZvSW1wbChpbmZvKSk7XG4gICAgfVxuICAgIGFzeW5jIHN0YXR1cyhvcHRzKSB7XG4gICAgICAgIGNvbnN0IGluZm8gPSBhd2FpdCB0aGlzLmpzbS5zdHJlYW1zLmluZm8odGhpcy5zdHJlYW0sIG9wdHMpO1xuICAgICAgICBpZiAoaW5mbyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIm9iamVjdCBzdG9yZSBub3QgZm91bmRcIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IE9iamVjdFN0b3JlSW5mb0ltcGwoaW5mbykpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5qc20uc3RyZWFtcy5kZWxldGUodGhpcy5zdHJlYW0pO1xuICAgIH1cbiAgICBhc3luYyBwdXQobWV0YSwgcnMpIHtcbiAgICAgICAgY29uc3QganNpID0gdGhpcy5qcztcbiAgICAgICAgY29uc3QgbWF4UGF5bG9hZCA9IGpzaS5uYy5pbmZvPy5tYXhfcGF5bG9hZCB8fCAxMDI0O1xuICAgICAgICBtZXRhID0gbWV0YSB8fCB7fTtcbiAgICAgICAgbWV0YS5vcHRpb25zID0gbWV0YS5vcHRpb25zIHx8IHt9O1xuICAgICAgICBsZXQgbWF4Q2h1bmsgPSBtZXRhLm9wdGlvbnM/Lm1heF9jaHVua19zaXplIHx8IDEyOCAqIDEwMjQ7XG4gICAgICAgIG1heENodW5rID0gbWF4Q2h1bmsgPiBtYXhQYXlsb2FkID8gbWF4UGF5bG9hZCA6IG1heENodW5rO1xuICAgICAgICBtZXRhLm9wdGlvbnMubWF4X2NodW5rX3NpemUgPSBtYXhDaHVuaztcbiAgICAgICAgY29uc3Qgb2xkID0gYXdhaXQgdGhpcy5pbmZvKG1ldGEubmFtZSk7XG4gICAgICAgIGNvbnN0IHsgbmFtZTogbiAsIGVycm9yICB9ID0gdGhpcy5fc2FuaXRpemVOYW1lKG1ldGEubmFtZSk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZCA9IG51aWQubmV4dCgpO1xuICAgICAgICBjb25zdCBjaHVua1N1YmogPSB0aGlzLl9jaHVua1N1YmplY3QoaWQpO1xuICAgICAgICBjb25zdCBtZXRhU3ViaiA9IHRoaXMuX21ldGFTdWJqZWN0KG4pO1xuICAgICAgICBjb25zdCBpbmZvID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBidWNrZXQ6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIG51aWQ6IGlkLFxuICAgICAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgICAgIGNodW5rczogMFxuICAgICAgICB9LCB0b1NlcnZlck9iamVjdFN0b3JlTWV0YShtZXRhKSk7XG4gICAgICAgIGNvbnN0IGQgPSBkZWZlcnJlZCgpO1xuICAgICAgICBjb25zdCBwcm9tcyA9IFtdO1xuICAgICAgICBjb25zdCBkYiA9IG5ldyBEYXRhQnVmZmVyKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSBycyA/IHJzLmdldFJlYWRlcigpIDogbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHNoYSA9IG5ldyBTSEEyNTYoKTtcbiAgICAgICAgICAgIHdoaWxlKHRydWUpe1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZG9uZSAsIHZhbHVlICB9ID0gcmVhZGVyID8gYXdhaXQgcmVhZGVyLnJlYWQoKSA6IHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRiLnNpemUoKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBkYi5kcmFpbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhLnVwZGF0ZShwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZm8uY2h1bmtzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZvLnNpemUgKz0gcGF5bG9hZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZvLm10aW1lID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlnZXN0ID0gc2hhLmRpZ2VzdChcImJhc2U2NFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhZCA9IGRpZ2VzdC5sZW5ndGggJSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFkZGluZyA9IHBhZCA+IDAgPyBcIj1cIi5yZXBlYXQocGFkKSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZvLmRpZ2VzdCA9IGBzaGEtMjU2PSR7ZGlnZXN0fSR7cGFkZGluZ31gO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5mby5kZWxldGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9tcy5wdXNoKHRoaXMuanMucHVibGlzaChjaHVua1N1YmosIHBheWxvYWQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBoID0gaGVhZGVycygpO1xuICAgICAgICAgICAgICAgICAgICBoLnNldChKc0hlYWRlcnMuUm9sbHVwSGRyLCBKc0hlYWRlcnMuUm9sbHVwVmFsdWVTdWJqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgcHJvbXMucHVzaCh0aGlzLmpzLnB1Ymxpc2gobWV0YVN1YmosIEpTT05Db2RlYygpLmVuY29kZShpbmZvKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21zLnB1c2godGhpcy5qc20uc3RyZWFtcy5wdXJnZSh0aGlzLnN0cmVhbSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcjogYCRPLiR7dGhpcy5uYW1lfS5DLiR7b2xkLm51aWR9YFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21zKTtcbiAgICAgICAgICAgICAgICAgICAgZC5yZXNvbHZlKG5ldyBPYmplY3RJbmZvSW1wbChpbmZvKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGIuZmlsbCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKGRiLnNpemUoKSA+IG1heENodW5rKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZm8uY2h1bmtzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZvLnNpemUgKz0gbWF4Q2h1bms7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkMSA9IGRiLmRyYWluKG1ldGEub3B0aW9ucy5tYXhfY2h1bmtfc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGEudXBkYXRlKHBheWxvYWQxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21zLnB1c2godGhpcy5qcy5wdWJsaXNoKGNodW5rU3ViaiwgcGF5bG9hZDEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmpzbS5zdHJlYW1zLnB1cmdlKHRoaXMuc3RyZWFtLCB7XG4gICAgICAgICAgICAgICAgZmlsdGVyOiBjaHVua1N1YmpcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZC5yZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0KG5hbWUpIHtcbiAgICAgICAgY29uc3QgaW5mbyA9IGF3YWl0IHRoaXMucmF3SW5mbyhuYW1lKTtcbiAgICAgICAgaWYgKGluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZm8ub3B0aW9ucyAmJiBpbmZvLm9wdGlvbnMubGluaykge1xuICAgICAgICAgICAgY29uc3QgbG4gPSBpbmZvLm9wdGlvbnMubGluay5uYW1lIHx8IFwiXCI7XG4gICAgICAgICAgICBpZiAobG4gPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJsaW5rIGlzIGEgYnVja2V0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3MgPSBhd2FpdCBPYmplY3RTdG9yZUltcGwuY3JlYXRlKHRoaXMuanMsIGluZm8ub3B0aW9ucy5saW5rLmJ1Y2tldCk7XG4gICAgICAgICAgICByZXR1cm4gb3MuZ2V0KGxuKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkID0gZGVmZXJyZWQoKTtcbiAgICAgICAgY29uc3QgciA9IHtcbiAgICAgICAgICAgIGluZm86IG5ldyBPYmplY3RJbmZvSW1wbChpbmZvKSxcbiAgICAgICAgICAgIGVycm9yOiBkXG4gICAgICAgIH07XG4gICAgICAgIGlmIChpbmZvLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHIuZGF0YSA9IGVtcHR5UmVhZGFibGVTdHJlYW0oKTtcbiAgICAgICAgICAgIGQucmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRyb2xsZXI7XG4gICAgICAgIGNvbnN0IG9jID0gY29uc3VtZXJPcHRzKCk7XG4gICAgICAgIG9jLm9yZGVyZWRDb25zdW1lcigpO1xuICAgICAgICBjb25zdCBzaGEgPSBuZXcgU0hBMjU2KCk7XG4gICAgICAgIGNvbnN0IHN1YmogPSBgJE8uJHt0aGlzLm5hbWV9LkMuJHtpbmZvLm51aWR9YDtcbiAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgdGhpcy5qcy5zdWJzY3JpYmUoc3Viaiwgb2MpO1xuICAgICAgICAoYXN5bmMgKCk9PntcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3Qgam0gb2Ygc3ViKXtcbiAgICAgICAgICAgICAgICBpZiAoam0uZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNoYS51cGRhdGUoam0uZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShqbS5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGptLmluZm8ucGVuZGluZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNoID0gc2hhLmRpZ2VzdChcImJhc2U2NFwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFkID0gaGFzaC5sZW5ndGggJSAzO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWRkaW5nID0gcGFkID4gMCA/IFwiPVwiLnJlcGVhdChwYWQpIDogXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlnZXN0ID0gYHNoYS0yNTY9JHtoYXNofSR7cGFkZGluZ31gO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlnZXN0ICE9PSBpbmZvLmRpZ2VzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihuZXcgRXJyb3IoYHJlY2VpdmVkIGEgY29ycnVwdCBvYmplY3QsIGRpZ2VzdHMgZG8gbm90IG1hdGNoIHJlY2VpdmVkOiAke2luZm8uZGlnZXN0fSBjYWxjdWxhdGVkICR7ZGlnZXN0fWApKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCkudGhlbigoKT0+e1xuICAgICAgICAgICAgZC5yZXNvbHZlKCk7XG4gICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKGVycik7XG4gICAgICAgICAgICBkLnJlamVjdChlcnIpO1xuICAgICAgICB9KTtcbiAgICAgICAgci5kYXRhID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIHN0YXJ0IChjKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlciA9IGM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FuY2VsICgpIHtcbiAgICAgICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByO1xuICAgIH1cbiAgICBsaW5rU3RvcmUobmFtZSwgYnVja2V0KSB7XG4gICAgICAgIGlmICghKGJ1Y2tldCBpbnN0YW5jZW9mIE9iamVjdFN0b3JlSW1wbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcImJ1Y2tldCByZXF1aXJlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvc2kgPSBidWNrZXQ7XG4gICAgICAgIGNvbnN0IHsgbmFtZTogbiAsIGVycm9yICB9ID0gdGhpcy5fc2FuaXRpemVOYW1lKG5hbWUpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6IG4sXG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgbGluazoge1xuICAgICAgICAgICAgICAgICAgICBidWNrZXQ6IG9zaS5uYW1lXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5wdXQobWV0YSwgbnVsbCk7XG4gICAgfVxuICAgIGFzeW5jIGxpbmsobmFtZSwgaW5mbykge1xuICAgICAgICBpZiAoaW5mby5kZWxldGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwib2JqZWN0IGlzIGRlbGV0ZWRcIikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbmFtZTogbiAsIGVycm9yICB9ID0gdGhpcy5fc2FuaXRpemVOYW1lKG5hbWUpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubmFtZSA9PT0gaW5mby5idWNrZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvcHkgPSBPYmplY3QuYXNzaWduKHt9LCBtZXRhKGluZm8pKTtcbiAgICAgICAgICAgIGNvcHkubmFtZSA9IG47XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudXBkYXRlKGluZm8ubmFtZSwgY29weSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaWkgPSBhd2FpdCB0aGlzLmluZm8obik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGluayA9IHtcbiAgICAgICAgICAgIGJ1Y2tldDogaW5mby5idWNrZXQsXG4gICAgICAgICAgICBuYW1lOiBpbmZvLm5hbWVcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbW0gPSB7XG4gICAgICAgICAgICBuYW1lOiBuLFxuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIGxpbms6IGxpbmtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0KG1tLCBudWxsKTtcbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlKG5hbWUpIHtcbiAgICAgICAgY29uc3QgaW5mbyA9IGF3YWl0IHRoaXMucmF3SW5mbyhuYW1lKTtcbiAgICAgICAgaWYgKGluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgICAgIHB1cmdlZDogMCxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5mby5kZWxldGVkID0gdHJ1ZTtcbiAgICAgICAgaW5mby5zaXplID0gMDtcbiAgICAgICAgaW5mby5jaHVua3MgPSAwO1xuICAgICAgICBpbmZvLmRpZ2VzdCA9IFwiXCI7XG4gICAgICAgIGNvbnN0IGpjID0gSlNPTkNvZGVjKCk7XG4gICAgICAgIGNvbnN0IGggPSBoZWFkZXJzKCk7XG4gICAgICAgIGguc2V0KEpzSGVhZGVycy5Sb2xsdXBIZHIsIEpzSGVhZGVycy5Sb2xsdXBWYWx1ZVN1YmplY3QpO1xuICAgICAgICBhd2FpdCB0aGlzLmpzLnB1Ymxpc2godGhpcy5fbWV0YVN1YmplY3QoaW5mby5uYW1lKSwgamMuZW5jb2RlKGluZm8pLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiBoXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5qc20uc3RyZWFtcy5wdXJnZSh0aGlzLnN0cmVhbSwge1xuICAgICAgICAgICAgZmlsdGVyOiB0aGlzLl9jaHVua1N1YmplY3QoaW5mby5udWlkKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlKG5hbWUsIG1ldGEgPSB7fSkge1xuICAgICAgICBjb25zdCBpbmZvID0gYXdhaXQgdGhpcy5yYXdJbmZvKG5hbWUpO1xuICAgICAgICBpZiAoaW5mbyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIm9iamVjdCBub3QgZm91bmRcIikpO1xuICAgICAgICB9XG4gICAgICAgIG1ldGEubmFtZSA9IG1ldGEubmFtZSA/PyBpbmZvLm5hbWU7XG4gICAgICAgIGNvbnN0IHsgbmFtZTogbiAsIGVycm9yICB9ID0gdGhpcy5fc2FuaXRpemVOYW1lKG1ldGEubmFtZSk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBtZXRhLm5hbWUgPSBuO1xuICAgICAgICBjb25zdCBpaSA9IE9iamVjdC5hc3NpZ24oe30sIGluZm8sIHRvU2VydmVyT2JqZWN0U3RvcmVNZXRhKG1ldGEpKTtcbiAgICAgICAgY29uc3QgamMgPSBKU09OQ29kZWMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuanMucHVibGlzaCh0aGlzLl9tZXRhU3ViamVjdChpaS5uYW1lKSwgamMuZW5jb2RlKGlpKSk7XG4gICAgfVxuICAgIGFzeW5jIHdhdGNoKG9wdHMgPSB7fSkge1xuICAgICAgICBvcHRzLmluY2x1ZGVIaXN0b3J5ID0gb3B0cy5pbmNsdWRlSGlzdG9yeSA/PyBmYWxzZTtcbiAgICAgICAgb3B0cy5pZ25vcmVEZWxldGVzID0gb3B0cy5pZ25vcmVEZWxldGVzID8/IGZhbHNlO1xuICAgICAgICBsZXQgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgcWkgPSBuZXcgUXVldWVkSXRlcmF0b3JJbXBsKCk7XG4gICAgICAgIGNvbnN0IHN1YmogPSB0aGlzLl9tZXRhU3ViamVjdEFsbCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5qc20uc3RyZWFtcy5nZXRNZXNzYWdlKHRoaXMuc3RyZWFtLCB7XG4gICAgICAgICAgICAgICAgbGFzdF9ieV9zdWJqOiBzdWJqXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09IFwiNDA0XCIpIHtcbiAgICAgICAgICAgICAgICBxaS5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcWkuc3RvcChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGpjID0gSlNPTkNvZGVjKCk7XG4gICAgICAgIGNvbnN0IGNvcHRzID0gY29uc3VtZXJPcHRzKCk7XG4gICAgICAgIGNvcHRzLm9yZGVyZWRDb25zdW1lcigpO1xuICAgICAgICBpZiAob3B0cy5pbmNsdWRlSGlzdG9yeSkge1xuICAgICAgICAgICAgY29wdHMuZGVsaXZlckxhc3RQZXJTdWJqZWN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICBjb3B0cy5kZWxpdmVyTmV3KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29wdHMuY2FsbGJhY2soKGVyciwgam0pPT57XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcWkuc3RvcChlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqbSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9pID0gamMuZGVjb2RlKGptLmRhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChvaS5kZWxldGVkICYmIG9wdHMuaWdub3JlRGVsZXRlcyA9PT0gdHJ1ZSkge30gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHFpLnB1c2gob2kpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoam0uaW5mbz8ucGVuZGluZyA9PT0gMCAmJiAhaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBxaS5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuanMuc3Vic2NyaWJlKHN1YmosIGNvcHRzKTtcbiAgICAgICAgcWkuX2RhdGEgPSBzdWI7XG4gICAgICAgIHFpLml0ZXJDbG9zZWQudGhlbigoKT0+e1xuICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdWIuY2xvc2VkLnRoZW4oKCk9PntcbiAgICAgICAgICAgIHFpLnN0b3AoKTtcbiAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgIHFpLnN0b3AoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBxaTtcbiAgICB9XG4gICAgX2NodW5rU3ViamVjdChpZCkge1xuICAgICAgICByZXR1cm4gYCRPLiR7dGhpcy5uYW1lfS5DLiR7aWR9YDtcbiAgICB9XG4gICAgX21ldGFTdWJqZWN0KG4pIHtcbiAgICAgICAgcmV0dXJuIGAkTy4ke3RoaXMubmFtZX0uTS4ke259YDtcbiAgICB9XG4gICAgX21ldGFTdWJqZWN0QWxsKCkge1xuICAgICAgICByZXR1cm4gYCRPLiR7dGhpcy5uYW1lfS5NLj5gO1xuICAgIH1cbiAgICBhc3luYyBpbml0KG9wdHMgPSB7fSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zdHJlYW0gPSBvYmplY3RTdG9yZVN0cmVhbU5hbWUodGhpcy5uYW1lKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzYyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdHMpO1xuICAgICAgICBzYy5uYW1lID0gdGhpcy5zdHJlYW07XG4gICAgICAgIHNjLmFsbG93X3JvbGx1cF9oZHJzID0gdHJ1ZTtcbiAgICAgICAgc2MuZGlzY2FyZCA9IERpc2NhcmRQb2xpY3kuTmV3O1xuICAgICAgICBzYy5zdWJqZWN0cyA9IFtcbiAgICAgICAgICAgIGAkTy4ke3RoaXMubmFtZX0uQy4+YCxcbiAgICAgICAgICAgIGAkTy4ke3RoaXMubmFtZX0uTS4+YFxuICAgICAgICBdO1xuICAgICAgICBpZiAob3B0cy5wbGFjZW1lbnQpIHtcbiAgICAgICAgICAgIHNjLnBsYWNlbWVudCA9IG9wdHMucGxhY2VtZW50O1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmpzbS5zdHJlYW1zLmluZm8oc2MubmFtZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycjEpIHtcbiAgICAgICAgICAgIGlmIChlcnIxLm1lc3NhZ2UgPT09IFwic3RyZWFtIG5vdCBmb3VuZFwiKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5qc20uc3RyZWFtcy5hZGQoc2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBjcmVhdGUoanMsIG5hbWUsIG9wdHMgPSB7fSkge1xuICAgICAgICBpZiAodHlwZW9mIGNyeXB0bz8uc3VidGxlPy5kaWdlc3QgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIm9iamVjdHN0b3JlOiB1bmFibGUgdG8gY2FsY3VsYXRlIGhhc2hlcyAtIGNyeXB0by5zdWJ0bGUuZGlnZXN0IHdpdGggc2hhMjU2IHN1cHBvcnQgaXMgcmVxdWlyZWRcIikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGpzaSA9IGpzO1xuICAgICAgICBsZXQganNvcHRzID0ganNpLm9wdHMgfHwge307XG4gICAgICAgIGNvbnN0IHRvID0ganNvcHRzLnRpbWVvdXQgfHwgMjAwMDtcbiAgICAgICAganNvcHRzID0gT2JqZWN0LmFzc2lnbihqc29wdHMsIHtcbiAgICAgICAgICAgIHRpbWVvdXQ6IHRvXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBqc20gPSBhd2FpdCBqc2kubmMuamV0c3RyZWFtTWFuYWdlcihqc29wdHMpO1xuICAgICAgICBjb25zdCBvcyA9IG5ldyBPYmplY3RTdG9yZUltcGwobmFtZSwganNtLCBqcyk7XG4gICAgICAgIGF3YWl0IG9zLmluaXQob3B0cyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUob3MpO1xuICAgIH1cbn1cbmNsYXNzIFZpZXdzSW1wbCB7XG4gICAganM7XG4gICAgY29uc3RydWN0b3IoanMpe1xuICAgICAgICB0aGlzLmpzID0ganM7XG4gICAgfVxuICAgIGt2KG5hbWUsIG9wdHMgPSB7fSkge1xuICAgICAgICBpZiAob3B0cy5iaW5kT25seSkge1xuICAgICAgICAgICAgcmV0dXJuIEJ1Y2tldC5iaW5kKHRoaXMuanMsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCdWNrZXQuY3JlYXRlKHRoaXMuanMsIG5hbWUsIG9wdHMpO1xuICAgIH1cbiAgICBvcyhuYW1lLCBvcHRzID0ge30pIHtcbiAgICAgICAgamV0c3RyZWFtUHJldmlldyh0aGlzLmpzLm5jKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdFN0b3JlSW1wbC5jcmVhdGUodGhpcy5qcywgbmFtZSwgb3B0cyk7XG4gICAgfVxufVxuY2xhc3MgSmV0U3RyZWFtQ2xpZW50SW1wbCBleHRlbmRzIEJhc2VBcGlDbGllbnQge1xuICAgIGFwaTtcbiAgICBjb25zdHJ1Y3RvcihuYywgb3B0cyl7XG4gICAgICAgIHN1cGVyKG5jLCBvcHRzKTtcbiAgICAgICAgdGhpcy5hcGkgPSBuZXcgQ29uc3VtZXJBUElJbXBsKG5jLCBvcHRzKTtcbiAgICB9XG4gICAgZ2V0IHZpZXdzKCkge1xuICAgICAgICByZXR1cm4gbmV3IFZpZXdzSW1wbCh0aGlzKTtcbiAgICB9XG4gICAgYXN5bmMgcHVibGlzaChzdWJqLCBkYXRhID0gRW1wdHksIG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIG9wdHMuZXhwZWN0ID0gb3B0cy5leHBlY3QgfHwge307XG4gICAgICAgIGNvbnN0IG1oID0gb3B0cz8uaGVhZGVycyB8fCBoZWFkZXJzKCk7XG4gICAgICAgIGlmIChvcHRzKSB7XG4gICAgICAgICAgICBpZiAob3B0cy5tc2dJRCkge1xuICAgICAgICAgICAgICAgIG1oLnNldChQdWJIZWFkZXJzLk1zZ0lkSGRyLCBvcHRzLm1zZ0lEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLmV4cGVjdC5sYXN0TXNnSUQpIHtcbiAgICAgICAgICAgICAgICBtaC5zZXQoUHViSGVhZGVycy5FeHBlY3RlZExhc3RNc2dJZEhkciwgb3B0cy5leHBlY3QubGFzdE1zZ0lEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLmV4cGVjdC5zdHJlYW1OYW1lKSB7XG4gICAgICAgICAgICAgICAgbWguc2V0KFB1YkhlYWRlcnMuRXhwZWN0ZWRTdHJlYW1IZHIsIG9wdHMuZXhwZWN0LnN0cmVhbU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHMuZXhwZWN0Lmxhc3RTZXF1ZW5jZSkge1xuICAgICAgICAgICAgICAgIG1oLnNldChQdWJIZWFkZXJzLkV4cGVjdGVkTGFzdFNlcUhkciwgYCR7b3B0cy5leHBlY3QubGFzdFNlcXVlbmNlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHMuZXhwZWN0Lmxhc3RTdWJqZWN0U2VxdWVuY2UpIHtcbiAgICAgICAgICAgICAgICBtaC5zZXQoUHViSGVhZGVycy5FeHBlY3RlZExhc3RTdWJqZWN0U2VxdWVuY2VIZHIsIGAke29wdHMuZXhwZWN0Lmxhc3RTdWJqZWN0U2VxdWVuY2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG8gPSBvcHRzLnRpbWVvdXQgfHwgdGhpcy50aW1lb3V0O1xuICAgICAgICBjb25zdCBybyA9IHt9O1xuICAgICAgICBpZiAodG8pIHtcbiAgICAgICAgICAgIHJvLnRpbWVvdXQgPSB0bztcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cykge1xuICAgICAgICAgICAgcm8uaGVhZGVycyA9IG1oO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IHJldHJpZXMgLCByZXRyeV9kZWxheSAgfSA9IG9wdHM7XG4gICAgICAgIHJldHJpZXMgPSByZXRyaWVzIHx8IDE7XG4gICAgICAgIHJldHJ5X2RlbGF5ID0gcmV0cnlfZGVsYXkgfHwgMjUwO1xuICAgICAgICBsZXQgcjtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHJldHJpZXM7IGkrKyl7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHIgPSBhd2FpdCB0aGlzLm5jLnJlcXVlc3Qoc3ViaiwgZGF0YSwgcm8pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmUgPSBlcnI7XG4gICAgICAgICAgICAgICAgaWYgKG5lLmNvZGUgPT09IFwiNTAzXCIgJiYgaSArIDEgPCByZXRyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGRlbGF5KHJldHJ5X2RlbGF5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhID0gdGhpcy5wYXJzZUpzUmVzcG9uc2Uocik7XG4gICAgICAgIGlmIChwYS5zdHJlYW0gPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHRocm93IE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLkpldFN0cmVhbUludmFsaWRBY2spO1xuICAgICAgICB9XG4gICAgICAgIHBhLmR1cGxpY2F0ZSA9IHBhLmR1cGxpY2F0ZSA/IHBhLmR1cGxpY2F0ZSA6IGZhbHNlO1xuICAgICAgICByZXR1cm4gcGE7XG4gICAgfVxuICAgIGFzeW5jIHB1bGwoc3RyZWFtLCBkdXJhYmxlLCBleHBpcmVzID0gMCkge1xuICAgICAgICB2YWxpZGF0ZVN0cmVhbU5hbWUoc3RyZWFtKTtcbiAgICAgICAgdmFsaWRhdGVEdXJhYmxlTmFtZShkdXJhYmxlKTtcbiAgICAgICAgbGV0IHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XG4gICAgICAgIGlmIChleHBpcmVzID4gdGltZW91dCkge1xuICAgICAgICAgICAgdGltZW91dCA9IGV4cGlyZXM7XG4gICAgICAgIH1cbiAgICAgICAgZXhwaXJlcyA9IGV4cGlyZXMgPCAwID8gMCA6IG5hbm9zKGV4cGlyZXMpO1xuICAgICAgICBjb25zdCBwdWxsT3B0cyA9IHtcbiAgICAgICAgICAgIGJhdGNoOiAxLFxuICAgICAgICAgICAgbm9fd2FpdDogZXhwaXJlcyA9PT0gMCxcbiAgICAgICAgICAgIGV4cGlyZXNcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbXNnID0gYXdhaXQgdGhpcy5uYy5yZXF1ZXN0KGAke3RoaXMucHJlZml4fS5DT05TVU1FUi5NU0cuTkVYVC4ke3N0cmVhbX0uJHtkdXJhYmxlfWAsIHRoaXMuamMuZW5jb2RlKHB1bGxPcHRzKSwge1xuICAgICAgICAgICAgbm9NdXg6IHRydWUsXG4gICAgICAgICAgICB0aW1lb3V0XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBlcnIgPSBjaGVja0pzRXJyb3IobXNnKTtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0pzTXNnKG1zZyk7XG4gICAgfVxuICAgIGZldGNoKHN0cmVhbSwgZHVyYWJsZSwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHZhbGlkYXRlU3RyZWFtTmFtZShzdHJlYW0pO1xuICAgICAgICB2YWxpZGF0ZUR1cmFibGVOYW1lKGR1cmFibGUpO1xuICAgICAgICBsZXQgdGltZXIgPSBudWxsO1xuICAgICAgICBjb25zdCB0cmFja0J5dGVzID0gKG9wdHMubWF4X2J5dGVzID8/IDApID4gMDtcbiAgICAgICAgbGV0IHJlY2VpdmVkQnl0ZXMgPSAwO1xuICAgICAgICBjb25zdCBtYXhfYnl0ZXMgPSB0cmFja0J5dGVzID8gb3B0cy5tYXhfYnl0ZXMgOiAwO1xuICAgICAgICBjb25zdCBhcmdzID0ge307XG4gICAgICAgIGFyZ3MuYmF0Y2ggPSBvcHRzLmJhdGNoIHx8IDE7XG4gICAgICAgIGlmIChtYXhfYnl0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZ2ID0gdGhpcy5uYy5wcm90b2NvbC5mZWF0dXJlcy5nZXQoRmVhdHVyZS5KU19QVUxMX01BWF9CWVRFUyk7XG4gICAgICAgICAgICBpZiAoIWZ2Lm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtYXhfYnl0ZXMgaXMgb25seSBzdXBwb3J0ZWQgb24gc2VydmVycyAke2Z2Lm1pbn0gb3IgYmV0dGVyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcmdzLm1heF9ieXRlcyA9IG1heF9ieXRlcztcbiAgICAgICAgfVxuICAgICAgICBhcmdzLm5vX3dhaXQgPSBvcHRzLm5vX3dhaXQgfHwgZmFsc2U7XG4gICAgICAgIGlmIChhcmdzLm5vX3dhaXQgJiYgYXJncy5leHBpcmVzKSB7XG4gICAgICAgICAgICBhcmdzLmV4cGlyZXMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4cGlyZXMgPSBvcHRzLmV4cGlyZXMgfHwgMDtcbiAgICAgICAgaWYgKGV4cGlyZXMpIHtcbiAgICAgICAgICAgIGFyZ3MuZXhwaXJlcyA9IG5hbm9zKGV4cGlyZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBpcmVzID09PSAwICYmIGFyZ3Mubm9fd2FpdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImV4cGlyZXMgb3Igbm9fd2FpdCBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBxaSA9IG5ldyBRdWV1ZWRJdGVyYXRvckltcGwoKTtcbiAgICAgICAgY29uc3Qgd2FudHMgPSBhcmdzLmJhdGNoO1xuICAgICAgICBsZXQgcmVjZWl2ZWQgPSAwO1xuICAgICAgICBxaS5kaXNwYXRjaGVkRm4gPSAobSk9PntcbiAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrQnl0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZWRCeXRlcyArPSBtLmRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWNlaXZlZCsrO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lciAmJiBtLmluZm8ucGVuZGluZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChxaS5nZXRQZW5kaW5nKCkgPT09IDEgJiYgbS5pbmZvLnBlbmRpbmcgPT09IDAgfHwgd2FudHMgPT09IHJlY2VpdmVkIHx8IG1heF9ieXRlcyA+IDAgJiYgcmVjZWl2ZWRCeXRlcyA+PSBtYXhfYnl0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcWkuc3RvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaW5ib3ggPSBjcmVhdGVJbmJveCh0aGlzLm5jLm9wdGlvbnMuaW5ib3hQcmVmaXgpO1xuICAgICAgICBjb25zdCBzdWIgPSB0aGlzLm5jLnN1YnNjcmliZShpbmJveCwge1xuICAgICAgICAgICAgbWF4OiBvcHRzLmJhdGNoLFxuICAgICAgICAgICAgY2FsbGJhY2s6IChlcnIsIG1zZyk9PntcbiAgICAgICAgICAgICAgICBpZiAoZXJyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGVyciA9IGNoZWNrSnNFcnJvcihtc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmF0c0Vycm9yKGVycikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHFpLnN0b3AoaGlkZU5vblRlcm1pbmFsSnNFcnJvcnMoZXJyKSA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxaS5zdG9wKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBxaS5yZWNlaXZlZCsrO1xuICAgICAgICAgICAgICAgICAgICBxaS5wdXNoKHRvSnNNc2cobXNnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGV4cGlyZXMpIHtcbiAgICAgICAgICAgIHRpbWVyID0gdGltZW91dChleHBpcmVzKTtcbiAgICAgICAgICAgIHRpbWVyLmNhdGNoKCgpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFzdWIuaXNDbG9zZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBzdWIuZHJhaW4oKTtcbiAgICAgICAgICAgICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIChhc3luYyAoKT0+e1xuICAgICAgICAgICAgYXdhaXQgc3ViLmNsb3NlZDtcbiAgICAgICAgICAgIGlmICh0aW1lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRpbWVyLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHFpLnN0b3AoKTtcbiAgICAgICAgfSkoKS5jYXRjaCgpO1xuICAgICAgICB0aGlzLm5jLnB1Ymxpc2goYCR7dGhpcy5wcmVmaXh9LkNPTlNVTUVSLk1TRy5ORVhULiR7c3RyZWFtfS4ke2R1cmFibGV9YCwgdGhpcy5qYy5lbmNvZGUoYXJncyksIHtcbiAgICAgICAgICAgIHJlcGx5OiBpbmJveFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHFpO1xuICAgIH1cbiAgICBhc3luYyBwdWxsU3Vic2NyaWJlKHN1YmplY3QsIG9wdHMgPSBjb25zdW1lck9wdHMoKSkge1xuICAgICAgICBjb25zdCBjc28gPSBhd2FpdCB0aGlzLl9wcm9jZXNzT3B0aW9ucyhzdWJqZWN0LCBvcHRzKTtcbiAgICAgICAgaWYgKGNzby5vcmRlcmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwdWxsIHN1YnNjcmliZXJzIGNhbm5vdCBiZSBiZSBvcmRlcmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY3NvLmF0dGFjaGVkKSB7XG4gICAgICAgICAgICBjc28uY29uZmlnLmZpbHRlcl9zdWJqZWN0ID0gc3ViamVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3NvLmNvbmZpZy5kZWxpdmVyX3N1YmplY3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbnN1bWVyIGluZm8gc3BlY2lmaWVzIGRlbGl2ZXJfc3ViamVjdCAtIHB1bGwgY29uc3VtZXJzIGNhbm5vdCBoYXZlIGRlbGl2ZXJfc3ViamVjdCBzZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWNrUG9saWN5ID0gY3NvLmNvbmZpZy5hY2tfcG9saWN5O1xuICAgICAgICBpZiAoYWNrUG9saWN5ID09PSBBY2tQb2xpY3kuTm9uZSB8fCBhY2tQb2xpY3kgPT09IEFja1BvbGljeS5BbGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFjayBwb2xpY3kgZm9yIHB1bGwgY29uc3VtZXJzIG11c3QgYmUgZXhwbGljaXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc28gPSB0aGlzLl9idWlsZFR5cGVkU3Vic2NyaXB0aW9uT3B0cyhjc28pO1xuICAgICAgICBjb25zdCBzdWIgPSBuZXcgSmV0U3RyZWFtUHVsbFN1YnNjcmlwdGlvbkltcGwodGhpcywgY3NvLmRlbGl2ZXIsIHNvKTtcbiAgICAgICAgc3ViLmluZm8gPSBjc287XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9tYXliZUNyZWF0ZUNvbnN1bWVyKGNzbyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YjtcbiAgICB9XG4gICAgYXN5bmMgc3Vic2NyaWJlKHN1YmplY3QsIG9wdHMgPSBjb25zdW1lck9wdHMoKSkge1xuICAgICAgICBjb25zdCBjc28gPSBhd2FpdCB0aGlzLl9wcm9jZXNzT3B0aW9ucyhzdWJqZWN0LCBvcHRzKTtcbiAgICAgICAgaWYgKCFjc28uaXNCaW5kICYmICFjc28uY29uZmlnLmRlbGl2ZXJfc3ViamVjdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHVzaCBjb25zdW1lciByZXF1aXJlcyBkZWxpdmVyX3N1YmplY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc28gPSB0aGlzLl9idWlsZFR5cGVkU3Vic2NyaXB0aW9uT3B0cyhjc28pO1xuICAgICAgICBjb25zdCBzdWIgPSBuZXcgSmV0U3RyZWFtU3Vic2NyaXB0aW9uSW1wbCh0aGlzLCBjc28uZGVsaXZlciwgc28pO1xuICAgICAgICBzdWIuaW5mbyA9IGNzbztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX21heWJlQ3JlYXRlQ29uc3VtZXIoY3NvKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3ViO1xuICAgIH1cbiAgICBhc3luYyBfcHJvY2Vzc09wdGlvbnMoc3ViamVjdCwgb3B0cyA9IGNvbnN1bWVyT3B0cygpKSB7XG4gICAgICAgIGNvbnN0IGpzaSA9IGlzQ29uc3VtZXJPcHRzQnVpbGRlcihvcHRzKSA/IG9wdHMuZ2V0T3B0cygpIDogb3B0cztcbiAgICAgICAganNpLmlzQmluZCA9IGlzQ29uc3VtZXJPcHRzQnVpbGRlcihvcHRzKSA/IG9wdHMuaXNCaW5kIDogZmFsc2U7XG4gICAgICAgIGpzaS5mbG93X2NvbnRyb2wgPSB7XG4gICAgICAgICAgICBoZWFydGJlYXRfY291bnQ6IDAsXG4gICAgICAgICAgICBmY19jb3VudDogMCxcbiAgICAgICAgICAgIGNvbnN1bWVyX3Jlc3RhcnRzOiAwXG4gICAgICAgIH07XG4gICAgICAgIGlmIChqc2kub3JkZXJlZCkge1xuICAgICAgICAgICAganNpLm9yZGVyZWRfY29uc3VtZXJfc2VxdWVuY2UgPSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtX3NlcTogMCxcbiAgICAgICAgICAgICAgICBkZWxpdmVyeV9zZXE6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoanNpLmNvbmZpZy5hY2tfcG9saWN5ICE9PSBBY2tQb2xpY3kuTm90U2V0ICYmIGpzaS5jb25maWcuYWNrX3BvbGljeSAhPT0gQWNrUG9saWN5Lk5vbmUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTmF0c0Vycm9yKFwib3JkZXJlZCBjb25zdW1lcjogYWNrX3BvbGljeSBjYW4gb25seSBiZSBzZXQgdG8gJ25vbmUnXCIsIEVycm9yQ29kZS5BcGlFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoanNpLmNvbmZpZy5kdXJhYmxlX25hbWUgJiYganNpLmNvbmZpZy5kdXJhYmxlX25hbWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOYXRzRXJyb3IoXCJvcmRlcmVkIGNvbnN1bWVyOiBkdXJhYmxlX25hbWUgY2Fubm90IGJlIHNldFwiLCBFcnJvckNvZGUuQXBpRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGpzaS5jb25maWcuZGVsaXZlcl9zdWJqZWN0ICYmIGpzaS5jb25maWcuZGVsaXZlcl9zdWJqZWN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTmF0c0Vycm9yKFwib3JkZXJlZCBjb25zdW1lcjogZGVsaXZlcl9zdWJqZWN0IGNhbm5vdCBiZSBzZXRcIiwgRXJyb3JDb2RlLkFwaUVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqc2kuY29uZmlnLm1heF9kZWxpdmVyICE9PSB1bmRlZmluZWQgJiYganNpLmNvbmZpZy5tYXhfZGVsaXZlciA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTmF0c0Vycm9yKFwib3JkZXJlZCBjb25zdW1lcjogbWF4X2RlbGl2ZXIgY2Fubm90IGJlIHNldFwiLCBFcnJvckNvZGUuQXBpRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGpzaS5jb25maWcuZGVsaXZlcl9ncm91cCAmJiBqc2kuY29uZmlnLmRlbGl2ZXJfZ3JvdXAubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOYXRzRXJyb3IoXCJvcmRlcmVkIGNvbnN1bWVyOiBkZWxpdmVyX2dyb3VwIGNhbm5vdCBiZSBzZXRcIiwgRXJyb3JDb2RlLkFwaUVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGpzaS5jb25maWcuZGVsaXZlcl9zdWJqZWN0ID0gY3JlYXRlSW5ib3godGhpcy5uYy5vcHRpb25zLmluYm94UHJlZml4KTtcbiAgICAgICAgICAgIGpzaS5jb25maWcuYWNrX3BvbGljeSA9IEFja1BvbGljeS5Ob25lO1xuICAgICAgICAgICAganNpLmNvbmZpZy5tYXhfZGVsaXZlciA9IDE7XG4gICAgICAgICAgICBqc2kuY29uZmlnLmZsb3dfY29udHJvbCA9IHRydWU7XG4gICAgICAgICAgICBqc2kuY29uZmlnLmlkbGVfaGVhcnRiZWF0ID0ganNpLmNvbmZpZy5pZGxlX2hlYXJ0YmVhdCB8fCBuYW5vcyg1MDAwKTtcbiAgICAgICAgICAgIGpzaS5jb25maWcuYWNrX3dhaXQgPSBuYW5vcygyMiAqIDYwICogNjAgKiAxMDAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoanNpLmNvbmZpZy5hY2tfcG9saWN5ID09PSBBY2tQb2xpY3kuTm90U2V0KSB7XG4gICAgICAgICAgICBqc2kuY29uZmlnLmFja19wb2xpY3kgPSBBY2tQb2xpY3kuQWxsO1xuICAgICAgICB9XG4gICAgICAgIGpzaS5hcGkgPSB0aGlzO1xuICAgICAgICBqc2kuY29uZmlnID0ganNpLmNvbmZpZyB8fCB7fTtcbiAgICAgICAganNpLnN0cmVhbSA9IGpzaS5zdHJlYW0gPyBqc2kuc3RyZWFtIDogYXdhaXQgdGhpcy5maW5kU3RyZWFtKHN1YmplY3QpO1xuICAgICAgICBqc2kuYXR0YWNoZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGpzaS5jb25maWcuZHVyYWJsZV9uYW1lKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZm8gPSBhd2FpdCB0aGlzLmFwaS5pbmZvKGpzaS5zdHJlYW0sIGpzaS5jb25maWcuZHVyYWJsZV9uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5mby5jb25maWcuZmlsdGVyX3N1YmplY3QgJiYgaW5mby5jb25maWcuZmlsdGVyX3N1YmplY3QgIT09IHN1YmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInN1YmplY3QgZG9lcyBub3QgbWF0Y2ggY29uc3VtZXJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcW4gPSBqc2kuY29uZmlnLmRlbGl2ZXJfZ3JvdXAgPz8gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHFuID09PSBcIlwiICYmIGluZm8ucHVzaF9ib3VuZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGUgc3Vic2NyaXB0aW9uYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcnFuID0gaW5mby5jb25maWcuZGVsaXZlcl9ncm91cCA/PyBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAocW4gIT09IHJxbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJxbiA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZHVyYWJsZSByZXF1aXJlcyBubyBxdWV1ZSBncm91cGApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGR1cmFibGUgcmVxdWlyZXMgcXVldWUgZ3JvdXAgJyR7cnFufSdgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBqc2kubGFzdCA9IGluZm87XG4gICAgICAgICAgICAgICAgICAgIGpzaS5jb25maWcgPSBpbmZvLmNvbmZpZztcbiAgICAgICAgICAgICAgICAgICAganNpLmF0dGFjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFqc2kuY29uZmlnLmR1cmFibGVfbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAganNpLm5hbWUgPSBpbmZvLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyLmNvZGUgIT09IFwiNDA0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWpzaS5hdHRhY2hlZCkge1xuICAgICAgICAgICAganNpLmNvbmZpZy5maWx0ZXJfc3ViamVjdCA9IHN1YmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAganNpLmRlbGl2ZXIgPSBqc2kuY29uZmlnLmRlbGl2ZXJfc3ViamVjdCB8fCBjcmVhdGVJbmJveCh0aGlzLm5jLm9wdGlvbnMuaW5ib3hQcmVmaXgpO1xuICAgICAgICByZXR1cm4ganNpO1xuICAgIH1cbiAgICBfYnVpbGRUeXBlZFN1YnNjcmlwdGlvbk9wdHMoanNpKSB7XG4gICAgICAgIGNvbnN0IHNvID0ge307XG4gICAgICAgIHNvLmFkYXB0ZXIgPSBtc2dBZGFwdGVyKGpzaS5jYWxsYmFja0ZuID09PSB1bmRlZmluZWQpO1xuICAgICAgICBzby5pbmdlc3Rpb25GaWx0ZXJGbiA9IEpldFN0cmVhbUNsaWVudEltcGwuaW5nZXN0aW9uRm4oanNpLm9yZGVyZWQpO1xuICAgICAgICBzby5wcm90b2NvbEZpbHRlckZuID0gKGptLCBpbmdlc3QgPSBmYWxzZSk9PntcbiAgICAgICAgICAgIGNvbnN0IGpzbWkgPSBqbTtcbiAgICAgICAgICAgIGlmIChpc0Zsb3dDb250cm9sTXNnKGpzbWkubXNnKSkge1xuICAgICAgICAgICAgICAgIGlmICghaW5nZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGpzbWkubXNnLnJlc3BvbmQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIGlmICghanNpLm1hY2sgJiYganNpLmNvbmZpZy5hY2tfcG9saWN5ICE9PSBBY2tQb2xpY3kuTm9uZSkge1xuICAgICAgICAgICAgc28uZGlzcGF0Y2hlZEZuID0gYXV0b0Fja0pzTXNnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqc2kuY2FsbGJhY2tGbikge1xuICAgICAgICAgICAgc28uY2FsbGJhY2sgPSBqc2kuY2FsbGJhY2tGbjtcbiAgICAgICAgfVxuICAgICAgICBzby5tYXggPSBqc2kubWF4IHx8IDA7XG4gICAgICAgIHNvLnF1ZXVlID0ganNpLnF1ZXVlO1xuICAgICAgICByZXR1cm4gc287XG4gICAgfVxuICAgIGFzeW5jIF9tYXliZUNyZWF0ZUNvbnN1bWVyKGpzaSkge1xuICAgICAgICBpZiAoanNpLmF0dGFjaGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGpzaS5pc0JpbmQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5hYmxlIHRvIGJpbmQgLSBkdXJhYmxlIGNvbnN1bWVyICR7anNpLmNvbmZpZy5kdXJhYmxlX25hbWV9IGRvZXNuJ3QgZXhpc3QgaW4gJHtqc2kuc3RyZWFtfWApO1xuICAgICAgICB9XG4gICAgICAgIGpzaS5jb25maWcgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGRlbGl2ZXJfcG9saWN5OiBEZWxpdmVyUG9saWN5LkFsbCxcbiAgICAgICAgICAgIGFja19wb2xpY3k6IEFja1BvbGljeS5FeHBsaWNpdCxcbiAgICAgICAgICAgIGFja193YWl0OiBuYW5vcygzMCAqIDEwMDApLFxuICAgICAgICAgICAgcmVwbGF5X3BvbGljeTogUmVwbGF5UG9saWN5Lkluc3RhbnRcbiAgICAgICAgfSwganNpLmNvbmZpZyk7XG4gICAgICAgIGNvbnN0IGNpID0gYXdhaXQgdGhpcy5hcGkuYWRkKGpzaS5zdHJlYW0sIGpzaS5jb25maWcpO1xuICAgICAgICBqc2kubmFtZSA9IGNpLm5hbWU7XG4gICAgICAgIGpzaS5jb25maWcgPSBjaS5jb25maWc7XG4gICAgICAgIGpzaS5sYXN0ID0gY2k7XG4gICAgfVxuICAgIHN0YXRpYyBpbmdlc3Rpb25GbihvcmRlcmVkKSB7XG4gICAgICAgIHJldHVybiAoam0sIGN0eCk9PntcbiAgICAgICAgICAgIGNvbnN0IGpzdWIgPSBjdHg7XG4gICAgICAgICAgICBpZiAoIWptKSByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGluZ2VzdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcHJvdG9jb2w6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgam1pID0gam07XG4gICAgICAgICAgICBpZiAoaXNIZWFydGJlYXRNc2coam1pLm1zZykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmdlc3QgPSBvcmRlcmVkID8ganN1Yi5fY2hlY2tIYk9yZGVyQ29uc3VtZXIoam1pLm1zZykgOiB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICghb3JkZXJlZCkge1xuICAgICAgICAgICAgICAgICAgICBqc3ViLmluZm8uZmxvd19jb250cm9sLmhlYXJ0YmVhdF9jb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpbmdlc3QsXG4gICAgICAgICAgICAgICAgICAgIHByb3RvY29sOiB0cnVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNGbG93Q29udHJvbE1zZyhqbWkubXNnKSkge1xuICAgICAgICAgICAgICAgIGpzdWIuaW5mby5mbG93X2NvbnRyb2wuZmNfY291bnQrKztcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpbmdlc3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHByb3RvY29sOiB0cnVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGluZ2VzdDEgPSBvcmRlcmVkID8ganN1Yi5fY2hlY2tPcmRlcmVkQ29uc3VtZXIoam0pIDogdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaW5nZXN0OiBpbmdlc3QxLFxuICAgICAgICAgICAgICAgIHByb3RvY29sOiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5jbGFzcyBOYXRzQ29ubmVjdGlvbkltcGwge1xuICAgIG9wdGlvbnM7XG4gICAgcHJvdG9jb2w7XG4gICAgZHJhaW5pbmc7XG4gICAgbGlzdGVuZXJzO1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpe1xuICAgICAgICB0aGlzLmRyYWluaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRzKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICB9XG4gICAgc3RhdGljIGNvbm5lY3Qob3B0cyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KT0+e1xuICAgICAgICAgICAgY29uc3QgbmMgPSBuZXcgTmF0c0Nvbm5lY3Rpb25JbXBsKG9wdHMpO1xuICAgICAgICAgICAgUHJvdG9jb2xIYW5kbGVyLmNvbm5lY3QobmMub3B0aW9ucywgbmMpLnRoZW4oKHBoKT0+e1xuICAgICAgICAgICAgICAgIG5jLnByb3RvY29sID0gcGg7XG4gICAgICAgICAgICAgICAgKGFzeW5jIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHMgb2YgcGguc3RhdHVzKCkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmMubGlzdGVuZXJzLmZvckVhY2goKGwpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbC5wdXNoKHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUobmMpO1xuICAgICAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm90b2NvbC5jbG9zZWQ7XG4gICAgfVxuICAgIGFzeW5jIGNsb3NlKCkge1xuICAgICAgICBhd2FpdCB0aGlzLnByb3RvY29sLmNsb3NlKCk7XG4gICAgfVxuICAgIF9jaGVjayhzdWJqZWN0LCBzdWIsIHB1Yikge1xuICAgICAgICBpZiAodGhpcy5pc0Nsb3NlZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBOYXRzRXJyb3IuZXJyb3JGb3JDb2RlKEVycm9yQ29kZS5Db25uZWN0aW9uQ2xvc2VkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3ViICYmIHRoaXMuaXNEcmFpbmluZygpKSB7XG4gICAgICAgICAgICB0aHJvdyBOYXRzRXJyb3IuZXJyb3JGb3JDb2RlKEVycm9yQ29kZS5Db25uZWN0aW9uRHJhaW5pbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwdWIgJiYgdGhpcy5wcm90b2NvbC5ub01vcmVQdWJsaXNoaW5nKSB7XG4gICAgICAgICAgICB0aHJvdyBOYXRzRXJyb3IuZXJyb3JGb3JDb2RlKEVycm9yQ29kZS5Db25uZWN0aW9uRHJhaW5pbmcpO1xuICAgICAgICB9XG4gICAgICAgIHN1YmplY3QgPSBzdWJqZWN0IHx8IFwiXCI7XG4gICAgICAgIGlmIChzdWJqZWN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgTmF0c0Vycm9yLmVycm9yRm9yQ29kZShFcnJvckNvZGUuQmFkU3ViamVjdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHVibGlzaChzdWJqZWN0LCBkYXRhID0gRW1wdHksIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fY2hlY2soc3ViamVjdCwgZmFsc2UsIHRydWUpO1xuICAgICAgICBpZiAoZGF0YSAmJiAhaXNVaW50OEFycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICB0aHJvdyBOYXRzRXJyb3IuZXJyb3JGb3JDb2RlKEVycm9yQ29kZS5CYWRQYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb3RvY29sLnB1Ymxpc2goc3ViamVjdCwgZGF0YSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN1YnNjcmliZShzdWJqZWN0LCBvcHRzID0ge30pIHtcbiAgICAgICAgdGhpcy5fY2hlY2soc3ViamVjdCwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICBjb25zdCBzdWIgPSBuZXcgU3Vic2NyaXB0aW9uSW1wbCh0aGlzLnByb3RvY29sLCBzdWJqZWN0LCBvcHRzKTtcbiAgICAgICAgdGhpcy5wcm90b2NvbC5zdWJzY3JpYmUoc3ViKTtcbiAgICAgICAgcmV0dXJuIHN1YjtcbiAgICB9XG4gICAgX3Jlc3ViKHMsIHN1YmplY3QsIG1heCkge1xuICAgICAgICB0aGlzLl9jaGVjayhzdWJqZWN0LCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IHNpID0gcztcbiAgICAgICAgc2kubWF4ID0gbWF4O1xuICAgICAgICBpZiAobWF4KSB7XG4gICAgICAgICAgICBzaS5tYXggPSBtYXggKyBzaS5yZWNlaXZlZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb3RvY29sLnJlc3ViKHNpLCBzdWJqZWN0KTtcbiAgICB9XG4gICAgcmVxdWVzdE1hbnkoc3ViamVjdCwgZGF0YSA9IEVtcHR5LCBvcHRzID0ge1xuICAgICAgICBtYXhXYWl0OiAxMDAwLFxuICAgICAgICBtYXhNZXNzYWdlczogLTFcbiAgICB9KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVjayhzdWJqZWN0LCB0cnVlLCB0cnVlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRzLnN0cmF0ZWd5ID0gb3B0cy5zdHJhdGVneSB8fCBSZXF1ZXN0U3RyYXRlZ3kuVGltZXI7XG4gICAgICAgIG9wdHMubWF4V2FpdCA9IG9wdHMubWF4V2FpdCB8fCAxMDAwO1xuICAgICAgICBpZiAob3B0cy5tYXhXYWl0IDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBOYXRzRXJyb3IoXCJ0aW1lb3V0XCIsIEVycm9yQ29kZS5JbnZhbGlkT3B0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcWkgPSBuZXcgUXVldWVkSXRlcmF0b3JJbXBsKCk7XG4gICAgICAgIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICAgICAgICBxaS5wdXNoKCgpPT57XG4gICAgICAgICAgICAgICAgcWkuc3RvcCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2FsbGJhY2soZXJyLCBtc2cpIHtcbiAgICAgICAgICAgIGlmIChlcnIgfHwgbXNnID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBxaS5wdXNoKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcWkucHVzaChtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLm5vTXV4KSB7XG4gICAgICAgICAgICBjb25zdCBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICAgICAgICAgICAgbGV0IG1heCA9IHR5cGVvZiBvcHRzLm1heE1lc3NhZ2VzID09PSBcIm51bWJlclwiICYmIG9wdHMubWF4TWVzc2FnZXMgPiAwID8gb3B0cy5tYXhNZXNzYWdlcyA6IC0xO1xuICAgICAgICAgICAgY29uc3Qgc3ViID0gdGhpcy5zdWJzY3JpYmUoY3JlYXRlSW5ib3godGhpcy5vcHRpb25zLmluYm94UHJlZml4KSwge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiAoZXJyLCBtc2cpPT57XG4gICAgICAgICAgICAgICAgICAgIGlmIChtc2cuZGF0YS5sZW5ndGggPT09IDAgJiYgbXNnPy5oZWFkZXJzPy5zdGF0dXMgPT09IEVycm9yQ29kZS5Ob1Jlc3BvbmRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9IE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLk5vUmVzcG9uZGVycyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyLnN0YWNrICs9IGBcXG5cXG4ke3N0YWNrfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWwoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBtc2cpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0cy5zdHJhdGVneSA9PT0gUmVxdWVzdFN0cmF0ZWd5LkNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXgtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0cy5zdHJhdGVneSA9PT0gUmVxdWVzdFN0cmF0ZWd5LkppdHRlclRpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVycygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAzMDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLnN0cmF0ZWd5ID09PSBSZXF1ZXN0U3RyYXRlZ3kuU2VudGluZWxNc2cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtc2cgJiYgbXNnLmRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN1Yi5jbG9zZWQudGhlbigoKT0+e1xuICAgICAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICAgICAgcWkucHVzaChlcnIpO1xuICAgICAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgY2FuY2VsID0gKGVycik9PntcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHFpLnB1c2goZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lcnMoKTtcbiAgICAgICAgICAgICAgICBzdWIuZHJhaW4oKS50aGVuKCgpPT57XG4gICAgICAgICAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaCgoX2Vycik9PntcbiAgICAgICAgICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHFpLml0ZXJDbG9zZWQudGhlbigoKT0+e1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZXJzKCk7XG4gICAgICAgICAgICAgICAgc3ViPy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfSkuY2F0Y2goKF9lcnIpPT57XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lcnMoKTtcbiAgICAgICAgICAgICAgICBzdWI/LnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHN1YmplY3QsIEVtcHR5LCB7XG4gICAgICAgICAgICAgICAgICAgIHJlcGx5OiBzdWIuZ2V0U3ViamVjdCgpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIxKSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsKGVycjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRpbWVyID0gc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgIGNhbmNlbCgpO1xuICAgICAgICAgICAgfSwgb3B0cy5tYXhXYWl0KTtcbiAgICAgICAgICAgIGNvbnN0IGNsZWFyVGltZXJzID0gKCk9PntcbiAgICAgICAgICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgcm1vID0gb3B0cztcbiAgICAgICAgICAgIHJtby5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgcWkuaXRlckNsb3NlZC50aGVuKCgpPT57XG4gICAgICAgICAgICAgICAgci5jYW5jZWwoKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICAgICAgci5jYW5jZWwoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgciA9IG5ldyBSZXF1ZXN0TWFueSh0aGlzLnByb3RvY29sLm11eFN1YnNjcmlwdGlvbnMsIHN1YmplY3QsIHJtbyk7XG4gICAgICAgICAgICB0aGlzLnByb3RvY29sLnJlcXVlc3Qocik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaChzdWJqZWN0LCBkYXRhLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlcGx5OiBgJHt0aGlzLnByb3RvY29sLm11eFN1YnNjcmlwdGlvbnMuYmFzZUluYm94fSR7ci50b2tlbn1gLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBvcHRzLmhlYWRlcnNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycjIpIHtcbiAgICAgICAgICAgICAgICByLmNhbmNlbChlcnIyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHFpKTtcbiAgICB9XG4gICAgcmVxdWVzdChzdWJqZWN0LCBkYXRhID0gRW1wdHksIG9wdHMgPSB7XG4gICAgICAgIHRpbWVvdXQ6IDEwMDAsXG4gICAgICAgIG5vTXV4OiBmYWxzZVxuICAgIH0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrKHN1YmplY3QsIHRydWUsIHRydWUpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIG9wdHMudGltZW91dCA9IG9wdHMudGltZW91dCB8fCAxMDAwO1xuICAgICAgICBpZiAob3B0cy50aW1lb3V0IDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBOYXRzRXJyb3IoXCJ0aW1lb3V0XCIsIEVycm9yQ29kZS5JbnZhbGlkT3B0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRzLm5vTXV4ICYmIG9wdHMucmVwbHkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgTmF0c0Vycm9yKFwicmVwbHkgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIG5vTXV4XCIsIEVycm9yQ29kZS5JbnZhbGlkT3B0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMubm9NdXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGluYm94ID0gb3B0cy5yZXBseSA/IG9wdHMucmVwbHkgOiBjcmVhdGVJbmJveCh0aGlzLm9wdGlvbnMuaW5ib3hQcmVmaXgpO1xuICAgICAgICAgICAgY29uc3QgZCA9IGRlZmVycmVkKCk7XG4gICAgICAgICAgICBjb25zdCBlcnJDdHggPSBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IHRoaXMuc3Vic2NyaWJlKGluYm94LCB7XG4gICAgICAgICAgICAgICAgbWF4OiAxLFxuICAgICAgICAgICAgICAgIHRpbWVvdXQ6IG9wdHMudGltZW91dCxcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogKGVyciwgbXNnKT0+e1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyLmNvZGUgIT09IEVycm9yQ29kZS5UaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyLnN0YWNrICs9IGBcXG5cXG4ke2VyckN0eC5zdGFja31gO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZC5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9IGlzUmVxdWVzdEVycm9yKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyLnN0YWNrICs9IGBcXG5cXG4ke2VyckN0eC5zdGFja31gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQucmVzb2x2ZShtc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdWIucmVxdWVzdFN1YmplY3QgPSBzdWJqZWN0O1xuICAgICAgICAgICAgdGhpcy5wcm90b2NvbC5wdWJsaXNoKHN1YmplY3QsIGRhdGEsIHtcbiAgICAgICAgICAgICAgICByZXBseTogaW5ib3gsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogb3B0cy5oZWFkZXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgciA9IG5ldyBSZXF1ZXN0T25lKHRoaXMucHJvdG9jb2wubXV4U3Vic2NyaXB0aW9ucywgc3ViamVjdCwgb3B0cyk7XG4gICAgICAgICAgICB0aGlzLnByb3RvY29sLnJlcXVlc3Qocik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaChzdWJqZWN0LCBkYXRhLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlcGx5OiBgJHt0aGlzLnByb3RvY29sLm11eFN1YnNjcmlwdGlvbnMuYmFzZUluYm94fSR7ci50b2tlbn1gLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBvcHRzLmhlYWRlcnNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycjEpIHtcbiAgICAgICAgICAgICAgICByLmNhbmNlbChlcnIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHAgPSBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgICAgIHIudGltZXIsXG4gICAgICAgICAgICAgICAgci5kZWZlcnJlZFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBwLmNhdGNoKCgpPT57XG4gICAgICAgICAgICAgICAgci5jYW5jZWwoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmx1c2goKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChOYXRzRXJyb3IuZXJyb3JGb3JDb2RlKEVycm9yQ29kZS5Db25uZWN0aW9uQ2xvc2VkKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdG9jb2wuZmx1c2goKTtcbiAgICB9XG4gICAgZHJhaW4oKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChOYXRzRXJyb3IuZXJyb3JGb3JDb2RlKEVycm9yQ29kZS5Db25uZWN0aW9uQ2xvc2VkKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNEcmFpbmluZygpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoTmF0c0Vycm9yLmVycm9yRm9yQ29kZShFcnJvckNvZGUuQ29ubmVjdGlvbkRyYWluaW5nKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcmFpbmluZyA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3RvY29sLmRyYWluKCk7XG4gICAgfVxuICAgIGlzQ2xvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm90b2NvbC5pc0Nsb3NlZCgpO1xuICAgIH1cbiAgICBpc0RyYWluaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kcmFpbmluZztcbiAgICB9XG4gICAgZ2V0U2VydmVyKCkge1xuICAgICAgICBjb25zdCBzcnYgPSB0aGlzLnByb3RvY29sLmdldFNlcnZlcigpO1xuICAgICAgICByZXR1cm4gc3J2ID8gc3J2Lmxpc3RlbiA6IFwiXCI7XG4gICAgfVxuICAgIHN0YXR1cygpIHtcbiAgICAgICAgY29uc3QgaXRlciA9IG5ldyBRdWV1ZWRJdGVyYXRvckltcGwoKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMucHVzaChpdGVyKTtcbiAgICAgICAgcmV0dXJuIGl0ZXI7XG4gICAgfVxuICAgIGdldCBpbmZvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm90b2NvbC5pc0Nsb3NlZCgpID8gdW5kZWZpbmVkIDogdGhpcy5wcm90b2NvbC5pbmZvO1xuICAgIH1cbiAgICBzdGF0cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluQnl0ZXM6IHRoaXMucHJvdG9jb2wuaW5CeXRlcyxcbiAgICAgICAgICAgIG91dEJ5dGVzOiB0aGlzLnByb3RvY29sLm91dEJ5dGVzLFxuICAgICAgICAgICAgaW5Nc2dzOiB0aGlzLnByb3RvY29sLmluTXNncyxcbiAgICAgICAgICAgIG91dE1zZ3M6IHRoaXMucHJvdG9jb2wub3V0TXNnc1xuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBqZXRzdHJlYW1NYW5hZ2VyKG9wdHMgPSB7fSkge1xuICAgICAgICBjb25zdCBhZG0gPSBuZXcgSmV0U3RyZWFtTWFuYWdlckltcGwodGhpcywgb3B0cyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBhZG0uZ2V0QWNjb3VudEluZm8oKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zdCBuZSA9IGVycjtcbiAgICAgICAgICAgIGlmIChuZS5jb2RlID09PSBFcnJvckNvZGUuTm9SZXNwb25kZXJzKSB7XG4gICAgICAgICAgICAgICAgbmUuY29kZSA9IEVycm9yQ29kZS5KZXRTdHJlYW1Ob3RFbmFibGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFkbTtcbiAgICB9XG4gICAgamV0c3RyZWFtKG9wdHMgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IEpldFN0cmVhbUNsaWVudEltcGwodGhpcywgb3B0cyk7XG4gICAgfVxuICAgIGdldFNlcnZlclZlcnNpb24oKSB7XG4gICAgICAgIGNvbnN0IGluZm8gPSB0aGlzLmluZm87XG4gICAgICAgIHJldHVybiBpbmZvID8gcGFyc2VTZW1WZXIoaW5mby52ZXJzaW9uKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgYXN5bmMgcnR0KCkge1xuICAgICAgICBpZiAoIXRoaXMucHJvdG9jb2wuX2Nsb3NlZCAmJiAhdGhpcy5wcm90b2NvbC5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLkRpc2Nvbm5lY3QpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgYXdhaXQgdGhpcy5mbHVzaCgpO1xuICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIHN0YXJ0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrT3B0aW9ucyhpbmZvLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBwcm90byAsIHRsc19yZXF1aXJlZDogdGxzUmVxdWlyZWQgLCB0bHNfYXZhaWxhYmxlOiB0bHNBdmFpbGFibGUgIH0gPSBpbmZvO1xuICAgIGlmICgocHJvdG8gPT09IHVuZGVmaW5lZCB8fCBwcm90byA8IDEpICYmIG9wdGlvbnMubm9FY2hvKSB7XG4gICAgICAgIHRocm93IG5ldyBOYXRzRXJyb3IoXCJub0VjaG9cIiwgRXJyb3JDb2RlLlNlcnZlck9wdGlvbk5vdEF2YWlsYWJsZSk7XG4gICAgfVxuICAgIGNvbnN0IHRscyA9IHRsc1JlcXVpcmVkIHx8IHRsc0F2YWlsYWJsZSB8fCBmYWxzZTtcbiAgICBpZiAob3B0aW9ucy50bHMgJiYgIXRscykge1xuICAgICAgICB0aHJvdyBuZXcgTmF0c0Vycm9yKFwidGxzXCIsIEVycm9yQ29kZS5TZXJ2ZXJPcHRpb25Ob3RBdmFpbGFibGUpO1xuICAgIH1cbn1cbmNsYXNzIEpldFN0cmVhbVN1YnNjcmlwdGlvbkltcGwgZXh0ZW5kcyBUeXBlZFN1YnNjcmlwdGlvbiB7XG4gICAganM7XG4gICAgY29uc3RydWN0b3IoanMsIHN1YmplY3QsIG9wdHMpe1xuICAgICAgICBzdXBlcihqcy5uYywgc3ViamVjdCwgb3B0cyk7XG4gICAgICAgIHRoaXMuanMgPSBqcztcbiAgICB9XG4gICAgc2V0IGluZm8oaW5mbykge1xuICAgICAgICB0aGlzLnN1Yi5pbmZvID0gaW5mbztcbiAgICB9XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1Yi5pbmZvO1xuICAgIH1cbiAgICBfcmVzZXRPcmRlcmVkQ29uc3VtZXIoc3NlcSkge1xuICAgICAgICBpZiAodGhpcy5pbmZvID09PSBudWxsIHx8IHRoaXMuc3ViLmlzQ2xvc2VkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdEZWxpdmVyID0gY3JlYXRlSW5ib3godGhpcy5qcy5uYy5vcHRpb25zLmluYm94UHJlZml4KTtcbiAgICAgICAgY29uc3QgbmNpID0gdGhpcy5qcy5uYztcbiAgICAgICAgbmNpLl9yZXN1Yih0aGlzLnN1YiwgbmV3RGVsaXZlcik7XG4gICAgICAgIGNvbnN0IGluZm8gPSB0aGlzLmluZm87XG4gICAgICAgIGluZm8ub3JkZXJlZF9jb25zdW1lcl9zZXF1ZW5jZS5kZWxpdmVyeV9zZXEgPSAwO1xuICAgICAgICBpbmZvLmZsb3dfY29udHJvbC5oZWFydGJlYXRfY291bnQgPSAwO1xuICAgICAgICBpbmZvLmZsb3dfY29udHJvbC5mY19jb3VudCA9IDA7XG4gICAgICAgIGluZm8uZmxvd19jb250cm9sLmNvbnN1bWVyX3Jlc3RhcnRzKys7XG4gICAgICAgIGluZm8uZGVsaXZlciA9IG5ld0RlbGl2ZXI7XG4gICAgICAgIGluZm8uY29uZmlnLmRlbGl2ZXJfc3ViamVjdCA9IG5ld0RlbGl2ZXI7XG4gICAgICAgIGluZm8uY29uZmlnLmRlbGl2ZXJfcG9saWN5ID0gRGVsaXZlclBvbGljeS5TdGFydFNlcXVlbmNlO1xuICAgICAgICBpbmZvLmNvbmZpZy5vcHRfc3RhcnRfc2VxID0gc3NlcTtcbiAgICAgICAgY29uc3Qgc3ViaiA9IGAke2luZm8uYXBpLnByZWZpeH0uQ09OU1VNRVIuQ1JFQVRFLiR7aW5mby5zdHJlYW19YDtcbiAgICAgICAgdGhpcy5qcy5fcmVxdWVzdChzdWJqLCB0aGlzLmluZm8uY29uZmlnKS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgY29uc3QgbmVyciA9IG5ldyBOYXRzRXJyb3IoYHVuYWJsZSB0byByZWNyZWF0ZSBvcmRlcmVkIGNvbnN1bWVyICR7aW5mby5zdHJlYW19IGF0IHNlcSAke3NzZXF9YCwgRXJyb3JDb2RlLlJlcXVlc3RFcnJvciwgZXJyKTtcbiAgICAgICAgICAgIHRoaXMuc3ViLmNhbGxiYWNrKG5lcnIsIHt9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9jaGVja0hiT3JkZXJDb25zdW1lcihtc2cpIHtcbiAgICAgICAgY29uc3Qgcm0gPSBtc2cuaGVhZGVycy5nZXQoSnNIZWFkZXJzLkNvbnN1bWVyU3RhbGxlZEhkcik7XG4gICAgICAgIGlmIChybSAhPT0gXCJcIikge1xuICAgICAgICAgICAgY29uc3QgbmNpID0gdGhpcy5qcy5uYztcbiAgICAgICAgICAgIG5jaS5wdWJsaXNoKHJtKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXN0RGVsaXZlcmVkID0gcGFyc2VJbnQobXNnLmhlYWRlcnMuZ2V0KEpzSGVhZGVycy5MYXN0Q29uc3VtZXJTZXFIZHIpLCAxMCk7XG4gICAgICAgIGNvbnN0IG9yZGVyZWQgPSB0aGlzLmluZm8ub3JkZXJlZF9jb25zdW1lcl9zZXF1ZW5jZTtcbiAgICAgICAgdGhpcy5pbmZvLmZsb3dfY29udHJvbC5oZWFydGJlYXRfY291bnQrKztcbiAgICAgICAgaWYgKGxhc3REZWxpdmVyZWQgIT09IG9yZGVyZWQuZGVsaXZlcnlfc2VxKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNldE9yZGVyZWRDb25zdW1lcihvcmRlcmVkLnN0cmVhbV9zZXEgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIF9jaGVja09yZGVyZWRDb25zdW1lcihqbSkge1xuICAgICAgICBjb25zdCBvcmRlcmVkID0gdGhpcy5pbmZvLm9yZGVyZWRfY29uc3VtZXJfc2VxdWVuY2U7XG4gICAgICAgIGNvbnN0IHNzZXEgPSBqbS5pbmZvLnN0cmVhbVNlcXVlbmNlO1xuICAgICAgICBjb25zdCBkc2VxID0gam0uaW5mby5kZWxpdmVyeVNlcXVlbmNlO1xuICAgICAgICBpZiAoZHNlcSAhPSBvcmRlcmVkLmRlbGl2ZXJ5X3NlcSArIDEpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0T3JkZXJlZENvbnN1bWVyKG9yZGVyZWQuc3RyZWFtX3NlcSArIDEpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG9yZGVyZWQuZGVsaXZlcnlfc2VxID0gZHNlcTtcbiAgICAgICAgb3JkZXJlZC5zdHJlYW1fc2VxID0gc3NlcTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGFzeW5jIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0Nsb3NlZCgpKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmRyYWluKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgamluZm8gPSB0aGlzLnN1Yi5pbmZvO1xuICAgICAgICBjb25zdCBuYW1lID0gamluZm8uY29uZmlnLmR1cmFibGVfbmFtZSB8fCBqaW5mby5uYW1lO1xuICAgICAgICBjb25zdCBzdWJqID0gYCR7amluZm8uYXBpLnByZWZpeH0uQ09OU1VNRVIuREVMRVRFLiR7amluZm8uc3RyZWFtfS4ke25hbWV9YDtcbiAgICAgICAgYXdhaXQgamluZm8uYXBpLl9yZXF1ZXN0KHN1YmopO1xuICAgIH1cbiAgICBhc3luYyBjb25zdW1lckluZm8oKSB7XG4gICAgICAgIGNvbnN0IGppbmZvID0gdGhpcy5zdWIuaW5mbztcbiAgICAgICAgY29uc3QgbmFtZSA9IGppbmZvLmNvbmZpZy5kdXJhYmxlX25hbWUgfHwgamluZm8ubmFtZTtcbiAgICAgICAgY29uc3Qgc3ViaiA9IGAke2ppbmZvLmFwaS5wcmVmaXh9LkNPTlNVTUVSLklORk8uJHtqaW5mby5zdHJlYW19LiR7bmFtZX1gO1xuICAgICAgICBjb25zdCBjaSA9IGF3YWl0IGppbmZvLmFwaS5fcmVxdWVzdChzdWJqKTtcbiAgICAgICAgamluZm8ubGFzdCA9IGNpO1xuICAgICAgICByZXR1cm4gY2k7XG4gICAgfVxufVxuY2xhc3MgSmV0U3RyZWFtUHVsbFN1YnNjcmlwdGlvbkltcGwgZXh0ZW5kcyBKZXRTdHJlYW1TdWJzY3JpcHRpb25JbXBsIHtcbiAgICBjb25zdHJ1Y3Rvcihqcywgc3ViamVjdCwgb3B0cyl7XG4gICAgICAgIHN1cGVyKGpzLCBzdWJqZWN0LCBvcHRzKTtcbiAgICB9XG4gICAgcHVsbChvcHRzID0ge1xuICAgICAgICBiYXRjaDogMVxuICAgIH0pIHtcbiAgICAgICAgY29uc3QgeyBzdHJlYW0gLCBjb25maWcgLCBuYW1lICB9ID0gdGhpcy5zdWIuaW5mbztcbiAgICAgICAgY29uc3QgY29uc3VtZXIgPSBjb25maWcuZHVyYWJsZV9uYW1lID8/IG5hbWU7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB7fTtcbiAgICAgICAgYXJncy5iYXRjaCA9IG9wdHMuYmF0Y2ggfHwgMTtcbiAgICAgICAgYXJncy5ub193YWl0ID0gb3B0cy5ub193YWl0IHx8IGZhbHNlO1xuICAgICAgICBpZiAoKG9wdHMubWF4X2J5dGVzID8/IDApID4gMCkge1xuICAgICAgICAgICAgY29uc3QgZnYgPSB0aGlzLmpzLm5jLnByb3RvY29sLmZlYXR1cmVzLmdldChGZWF0dXJlLkpTX1BVTExfTUFYX0JZVEVTKTtcbiAgICAgICAgICAgIGlmICghZnYub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1heF9ieXRlcyBpcyBvbmx5IHN1cHBvcnRlZCBvbiBzZXJ2ZXJzICR7ZnYubWlufSBvciBiZXR0ZXJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFyZ3MubWF4X2J5dGVzID0gb3B0cy5tYXhfYnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuZXhwaXJlcyAmJiBvcHRzLmV4cGlyZXMgPiAwKSB7XG4gICAgICAgICAgICBhcmdzLmV4cGlyZXMgPSBuYW5vcyhvcHRzLmV4cGlyZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluZm8pIHtcbiAgICAgICAgICAgIGNvbnN0IGFwaSA9IHRoaXMuaW5mby5hcGk7XG4gICAgICAgICAgICBjb25zdCBzdWJqID0gYCR7YXBpLnByZWZpeH0uQ09OU1VNRVIuTVNHLk5FWFQuJHtzdHJlYW19LiR7Y29uc3VtZXJ9YDtcbiAgICAgICAgICAgIGNvbnN0IHJlcGx5ID0gdGhpcy5zdWIuc3ViamVjdDtcbiAgICAgICAgICAgIGFwaS5uYy5wdWJsaXNoKHN1YmosIGFwaS5qYy5lbmNvZGUoYXJncyksIHtcbiAgICAgICAgICAgICAgICByZXBseTogcmVwbHlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbXNnQWRhcHRlcihpdGVyYXRvcikge1xuICAgIGlmIChpdGVyYXRvcikge1xuICAgICAgICByZXR1cm4gaXRlck1zZ0FkYXB0ZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNiTXNnQWRhcHRlcjtcbiAgICB9XG59XG5mdW5jdGlvbiBjYk1zZ0FkYXB0ZXIoZXJyLCBtc2cpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICBudWxsXG4gICAgICAgIF07XG4gICAgfVxuICAgIGVyciA9IGNoZWNrSnNFcnJvcihtc2cpO1xuICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbnVsbCxcbiAgICAgICAgdG9Kc01zZyhtc2cpXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGl0ZXJNc2dBZGFwdGVyKGVyciwgbXNnKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICBdO1xuICAgIH1cbiAgICBjb25zdCBuZSA9IGNoZWNrSnNFcnJvcihtc2cpO1xuICAgIGlmIChuZSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgaGlkZU5vblRlcm1pbmFsSnNFcnJvcnMobmUpLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgICBudWxsLFxuICAgICAgICB0b0pzTXNnKG1zZylcbiAgICBdO1xufVxuZnVuY3Rpb24gaGlkZU5vblRlcm1pbmFsSnNFcnJvcnMobmUpIHtcbiAgICBpZiAobmUgIT09IG51bGwpIHtcbiAgICAgICAgc3dpdGNoKG5lLmNvZGUpe1xuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuSmV0U3RyZWFtNDA0Tm9NZXNzYWdlczpcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLkpldFN0cmVhbTQwOFJlcXVlc3RUaW1lb3V0OlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuSmV0U3RyZWFtNDA5OlxuICAgICAgICAgICAgICAgIGlmIChpc1Rlcm1pbmFsNDA5KG5lKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBhdXRvQWNrSnNNc2coZGF0YSkge1xuICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGRhdGEuYWNrKCk7XG4gICAgfVxufVxuY29uc3QgamV0c3RyZWFtUHJldmlldyA9ICgoKT0+e1xuICAgIGxldCBvbmNlID0gZmFsc2U7XG4gICAgcmV0dXJuIChuY2kpPT57XG4gICAgICAgIGlmICghb25jZSkge1xuICAgICAgICAgICAgb25jZSA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCB7IGxhbmcgIH0gPSBuY2k/LnByb3RvY29sPy50cmFuc3BvcnQ7XG4gICAgICAgICAgICBpZiAobGFuZykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBcXHUwMDFCWzMzbSA+PiBqZXRzdHJlYW0ncyBtYXRlcmlhbGl6ZWQgdmlld3Mgb2JqZWN0IHN0b3JlIGZ1bmN0aW9uYWxpdHkgaW4gJHtsYW5nfSBpcyBiZXRhIGZ1bmN0aW9uYWxpdHkgXFx1MDAxQlswbWApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgXFx1MDAxQlszM20gPj4gamV0c3RyZWFtJ3MgbWF0ZXJpYWxpemVkIHZpZXdzIG9iamVjdCBzdG9yZSBmdW5jdGlvbmFsaXR5IGlzIGJldGEgZnVuY3Rpb25hbGl0eSBcXHUwMDFCWzBtYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcbmNsYXNzIEJhc2U2NENvZGVjIHtcbiAgICBzdGF0aWMgZW5jb2RlKGJ5dGVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYnl0ZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBidG9hKGJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhID0gQXJyYXkuZnJvbShieXRlcyk7XG4gICAgICAgIHJldHVybiBidG9hKFN0cmluZy5mcm9tQ2hhckNvZGUoLi4uYSkpO1xuICAgIH1cbiAgICBzdGF0aWMgZGVjb2RlKHMsIGJpbmFyeSA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGJpbiA9IGF0b2Iocyk7XG4gICAgICAgIGlmICghYmluYXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gYmluO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYmluLmxlbmd0aCk7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBiaW4ubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgYnl0ZXNbaV0gPSBiaW4uY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxufVxuY2xhc3MgQmFzZTY0VXJsQ29kZWMge1xuICAgIHN0YXRpYyBlbmNvZGUoYnl0ZXMpIHtcbiAgICAgICAgcmV0dXJuIEJhc2U2NFVybENvZGVjLnRvQjY0VVJMRW5jb2RpbmcoQmFzZTY0Q29kZWMuZW5jb2RlKGJ5dGVzKSk7XG4gICAgfVxuICAgIHN0YXRpYyBkZWNvZGUocywgYmluYXJ5ID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIEJhc2U2NENvZGVjLmRlY29kZShCYXNlNjRVcmxDb2RlYy5mcm9tQjY0VVJMRW5jb2RpbmcocyksIGJpbmFyeSk7XG4gICAgfVxuICAgIHN0YXRpYyB0b0I2NFVSTEVuY29kaW5nKGI2NHN0cikge1xuICAgICAgICBiNjRzdHIgPSBiNjRzdHIucmVwbGFjZSgvPS9nLCBcIlwiKTtcbiAgICAgICAgYjY0c3RyID0gYjY0c3RyLnJlcGxhY2UoL1xcKy9nLCBcIi1cIik7XG4gICAgICAgIHJldHVybiBiNjRzdHIucmVwbGFjZSgvXFwvL2csIFwiX1wiKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CNjRVUkxFbmNvZGluZyhiNjRzdHIpIHtcbiAgICAgICAgYjY0c3RyID0gYjY0c3RyLnJlcGxhY2UoL18vZywgXCIvXCIpO1xuICAgICAgICBiNjRzdHIgPSBiNjRzdHIucmVwbGFjZSgvLS9nLCBcIitcIik7XG4gICAgICAgIHJldHVybiBiNjRzdHI7XG4gICAgfVxufVxuY29uc3QgVkVSU0lPTiA9IFwiMS45LjBcIjtcbmNvbnN0IExBTkcgPSBcIm5hdHMud3NcIjtcbmNsYXNzIFdzVHJhbnNwb3J0IHtcbiAgICB2ZXJzaW9uO1xuICAgIGxhbmc7XG4gICAgY2xvc2VFcnJvcjtcbiAgICBjb25uZWN0ZWQ7XG4gICAgZG9uZTtcbiAgICBzb2NrZXQ7XG4gICAgb3B0aW9ucztcbiAgICBzb2NrZXRDbG9zZWQ7XG4gICAgZW5jcnlwdGVkO1xuICAgIHBlZWtlZDtcbiAgICB5aWVsZHM7XG4gICAgc2lnbmFsO1xuICAgIGNsb3NlZE5vdGlmaWNhdGlvbjtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLnZlcnNpb24gPSBWRVJTSU9OO1xuICAgICAgICB0aGlzLmxhbmcgPSBMQU5HO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zb2NrZXRDbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbmNyeXB0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wZWVrZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy55aWVsZHMgPSBbXTtcbiAgICAgICAgdGhpcy5zaWduYWwgPSBkZWZlcnJlZCgpO1xuICAgICAgICB0aGlzLmNsb3NlZE5vdGlmaWNhdGlvbiA9IGRlZmVycmVkKCk7XG4gICAgfVxuICAgIGFzeW5jIGNvbm5lY3Qoc2VydmVyLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBjb25uTG9jayA9IGRlZmVycmVkKCk7XG4gICAgICAgIGlmIChvcHRpb25zLnRscykge1xuICAgICAgICAgICAgY29ubkxvY2sucmVqZWN0KG5ldyBOYXRzRXJyb3IoXCJ0bHNcIiwgRXJyb3JDb2RlLkludmFsaWRPcHRpb24pKTtcbiAgICAgICAgICAgIHJldHVybiBjb25uTG9jaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBjb25zdCB1ID0gc2VydmVyLnNyYztcbiAgICAgICAgaWYgKG9wdGlvbnMud3NGYWN0b3J5KSB7XG4gICAgICAgICAgICBjb25zdCB7IHNvY2tldCAsIGVuY3J5cHRlZCAgfSA9IGF3YWl0IG9wdGlvbnMud3NGYWN0b3J5KHNlcnZlci5zcmMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQgPSBzb2NrZXQ7XG4gICAgICAgICAgICB0aGlzLmVuY3J5cHRlZCA9IGVuY3J5cHRlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZW5jcnlwdGVkID0gdS5pbmRleE9mKFwid3NzOi8vXCIpID09PSAwO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQgPSBuZXcgV2ViU29ja2V0KHUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG4gICAgICAgIHRoaXMuc29ja2V0Lm9ub3BlbiA9ICgpPT57fTtcbiAgICAgICAgdGhpcy5zb2NrZXQub25tZXNzYWdlID0gKG1lKT0+e1xuICAgICAgICAgICAgdGhpcy55aWVsZHMucHVzaChuZXcgVWludDhBcnJheShtZS5kYXRhKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5wZWVrZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNpZ25hbC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdCA9IERhdGFCdWZmZXIuY29uY2F0KC4uLnRoaXMueWllbGRzKTtcbiAgICAgICAgICAgIGNvbnN0IHBtID0gZXh0cmFjdFByb3RvY29sTWVzc2FnZSh0KTtcbiAgICAgICAgICAgIGlmIChwbSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG0gPSBJTkZPLmV4ZWMocG0pO1xuICAgICAgICAgICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIiEhIVwiLCByZW5kZXIodCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbm5Mb2NrLnJlamVjdChuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkIHJlc3BvbnNlIGZyb20gc2VydmVyXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmZvID0gSlNPTi5wYXJzZShtWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tPcHRpb25zKGluZm8sIHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVla2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNpZ25hbC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5Mb2NrLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubkxvY2sucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uY2xvc2UgPSAoZXZ0KT0+e1xuICAgICAgICAgICAgdGhpcy5zb2NrZXRDbG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IHJlYXNvbjtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbmUpIHJldHVybjtcbiAgICAgICAgICAgIGlmICghZXZ0Lndhc0NsZWFuKSB7XG4gICAgICAgICAgICAgICAgcmVhc29uID0gbmV3IEVycm9yKGV2dC5yZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY2xvc2VkKHJlYXNvbik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uZXJyb3IgPSAoZSk9PntcbiAgICAgICAgICAgIGNvbnN0IGV2dCA9IGU7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgTmF0c0Vycm9yKGV2dC5tZXNzYWdlLCBFcnJvckNvZGUuVW5rbm93biwgbmV3IEVycm9yKGV2dC5lcnJvcikpO1xuICAgICAgICAgICAgaWYgKCFjb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBjb25uTG9jay5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xvc2VkKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjb25uTG9jaztcbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5fY2xvc2VkKHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgfVxuICAgIGFzeW5jIF9jbG9zZWQoZXJyLCBpbnRlcm5hbCA9IHRydWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3RlZCkgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5kb25lKSByZXR1cm47XG4gICAgICAgIHRoaXMuY2xvc2VFcnJvciA9IGVycjtcbiAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgIHdoaWxlKCF0aGlzLnNvY2tldENsb3NlZCAmJiB0aGlzLnNvY2tldC5idWZmZXJlZEFtb3VudCA+IDApe1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuc29ja2V0LmJ1ZmZlcmVkQW1vdW50KTtcbiAgICAgICAgICAgICAgICBhd2FpdCBkZWxheSgxMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5jbG9zZShlcnIgPyAxMDAyIDogMTAwMCwgZXJyID8gZXJyLm1lc3NhZ2UgOiB1bmRlZmluZWQpO1xuICAgICAgICB9IGNhdGNoIChlcnIxKSB7fVxuICAgICAgICBpZiAoaW50ZXJuYWwpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VkTm90aWZpY2F0aW9uLnJlc29sdmUoZXJyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXNDbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvbmU7XG4gICAgfVxuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZXJhdGUoKTtcbiAgICB9XG4gICAgYXN5bmMgKml0ZXJhdGUoKSB7XG4gICAgICAgIHdoaWxlKHRydWUpe1xuICAgICAgICAgICAgaWYgKHRoaXMueWllbGRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2lnbmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeWllbGRzID0gdGhpcy55aWVsZHM7XG4gICAgICAgICAgICB0aGlzLnlpZWxkcyA9IFtdO1xuICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHlpZWxkcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oYD4gJHtyZW5kZXIoeWllbGRzW2ldKX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeWllbGQgeWllbGRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnlpZWxkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB5aWVsZHMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnlpZWxkcyA9IHlpZWxkcztcbiAgICAgICAgICAgICAgICB0aGlzLnNpZ25hbCA9IGRlZmVycmVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNFbmNyeXB0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RlZCAmJiB0aGlzLmVuY3J5cHRlZDtcbiAgICB9XG4gICAgc2VuZChmcmFtZSkge1xuICAgICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmQoZnJhbWUuYnVmZmVyKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oYDwgJHtyZW5kZXIoZnJhbWUpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGAhISEgJHtyZW5kZXIoZnJhbWUpfTogJHtlcnJ9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xvc2UoZXJyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9zZWQoZXJyLCBmYWxzZSk7XG4gICAgfVxuICAgIGNsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2VkTm90aWZpY2F0aW9uO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHdzVXJsUGFyc2VGbih1KSB7XG4gICAgY29uc3QgdXQgPSAvXiguKjpcXC9cXC8pKC4qKS87XG4gICAgaWYgKCF1dC50ZXN0KHUpKSB7XG4gICAgICAgIHUgPSBgaHR0cHM6Ly8ke3V9YDtcbiAgICB9XG4gICAgbGV0IHVybCA9IG5ldyBVUkwodSk7XG4gICAgY29uc3Qgc3JjUHJvdG8gPSB1cmwucHJvdG9jb2wudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoc3JjUHJvdG8gIT09IFwiaHR0cHM6XCIgJiYgc3JjUHJvdG8gIT09IFwiaHR0cFwiKSB7XG4gICAgICAgIHUgPSB1LnJlcGxhY2UoL14oLio6XFwvXFwvKSguKikvZ20sIFwiJDJcIik7XG4gICAgICAgIHVybCA9IG5ldyBVUkwoYGh0dHA6Ly8ke3V9YCk7XG4gICAgfVxuICAgIGxldCBwcm90b2NvbDtcbiAgICBsZXQgcG9ydDtcbiAgICBjb25zdCBob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgIGNvbnN0IHBhdGggPSB1cmwucGF0aG5hbWU7XG4gICAgY29uc3Qgc2VhcmNoID0gdXJsLnNlYXJjaCB8fCBcIlwiO1xuICAgIHN3aXRjaChzcmNQcm90byl7XG4gICAgICAgIGNhc2UgXCJodHRwOlwiOlxuICAgICAgICBjYXNlIFwid3M6XCI6XG4gICAgICAgIGNhc2UgXCJuYXRzOlwiOlxuICAgICAgICAgICAgcG9ydCA9IHVybC5wb3J0IHx8IFwiODBcIjtcbiAgICAgICAgICAgIHByb3RvY29sID0gXCJ3czpcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcG9ydCA9IHVybC5wb3J0IHx8IFwiNDQzXCI7XG4gICAgICAgICAgICBwcm90b2NvbCA9IFwid3NzOlwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBgJHtwcm90b2NvbH0vLyR7aG9zdH06JHtwb3J0fSR7cGF0aH0ke3NlYXJjaH1gO1xufVxuZnVuY3Rpb24gY29ubmVjdChvcHRzID0ge30pIHtcbiAgICBzZXRUcmFuc3BvcnRGYWN0b3J5KHtcbiAgICAgICAgZGVmYXVsdFBvcnQ6IDQ0MyxcbiAgICAgICAgdXJsUGFyc2VGbjogd3NVcmxQYXJzZUZuLFxuICAgICAgICBmYWN0b3J5OiAoKT0+e1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBXc1RyYW5zcG9ydCgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIE5hdHNDb25uZWN0aW9uSW1wbC5jb25uZWN0KG9wdHMpO1xufVxuZXhwb3J0IHsgY29ubmVjdCBhcyBjb25uZWN0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/nats.ws/esm/nats.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["pages/_app","main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fdgee%2FDocuments%2FRethink%2Fkubecon22%2Fdemo%2Fpages%2Findex.tsx&page=%2F!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);